<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>LSD: lsd.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a></div>
<h1>lsd.c</h1><a href="lsd_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/*----------------------------------------------------------------------------</span>
00002 <span class="comment"></span>
00003 <span class="comment">  LSD - Line Segment Detector on digital images</span>
00004 <span class="comment"></span>
00005 <span class="comment">  This code is part of the following publication and was subject</span>
00006 <span class="comment">  to peer review:</span>
00007 <span class="comment"></span>
00008 <span class="comment">    "LSD: a Line Segment Detector" by Rafael Grompone von Gioi,</span>
00009 <span class="comment">    Jeremie Jakubowicz, Jean-Michel Morel, and Gregory Randall,</span>
00010 <span class="comment">    Image Processing On Line, 2012. DOI:10.5201/ipol.2012.gjmr-lsd</span>
00011 <span class="comment">    http://dx.doi.org/10.5201/ipol.2012.gjmr-lsd</span>
00012 <span class="comment"></span>
00013 <span class="comment">  Copyright (c) 2007-2011 rafael grompone von gioi &lt;grompone@gmail.com&gt;</span>
00014 <span class="comment"></span>
00015 <span class="comment">  This program is free software: you can redistribute it and/or modify</span>
00016 <span class="comment">  it under the terms of the GNU Affero General Public License as</span>
00017 <span class="comment">  published by the Free Software Foundation, either version 3 of the</span>
00018 <span class="comment">  License, or (at your option) any later version.</span>
00019 <span class="comment"></span>
00020 <span class="comment">  This program is distributed in the hope that it will be useful,</span>
00021 <span class="comment">  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00022 <span class="comment">  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the</span>
00023 <span class="comment">  GNU Affero General Public License for more details.</span>
00024 <span class="comment"></span>
00025 <span class="comment">  You should have received a copy of the GNU Affero General Public License</span>
00026 <span class="comment">  along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
00027 <span class="comment"></span>
00028 <span class="comment">  ----------------------------------------------------------------------------*/</span>
00029 
00030 <span class="comment">/*----------------------------------------------------------------------------*/</span><span class="comment"></span>
00031 <span class="comment">/** @file lsd.c</span>
00032 <span class="comment">    LSD module code</span>
00033 <span class="comment">    @author rafael grompone von gioi &lt;grompone@gmail.com&gt;</span>
00034 <span class="comment"> */</span>
00035 <span class="comment">/*----------------------------------------------------------------------------*/</span>
00036 
00037 <span class="comment">/*----------------------------------------------------------------------------*/</span><span class="comment"></span>
00038 <span class="comment">/** @mainpage LSD code documentation</span>
00039 <span class="comment"></span>
00040 <span class="comment">    This is an implementation of the Line Segment Detector described</span>
00041 <span class="comment">    in the paper:</span>
00042 <span class="comment"></span>
00043 <span class="comment">      "LSD: A Fast Line Segment Detector with a False Detection Control"</span>
00044 <span class="comment">      by Rafael Grompone von Gioi, Jeremie Jakubowicz, Jean-Michel Morel,</span>
00045 <span class="comment">      and Gregory Randall, IEEE Transactions on Pattern Analysis and</span>
00046 <span class="comment">      Machine Intelligence, vol. 32, no. 4, pp. 722-732, April, 2010.</span>
00047 <span class="comment"></span>
00048 <span class="comment">    and in more details in the CMLA Technical Report:</span>
00049 <span class="comment"></span>
00050 <span class="comment">      "LSD: A Line Segment Detector, Technical Report",</span>
00051 <span class="comment">      by Rafael Grompone von Gioi, Jeremie Jakubowicz, Jean-Michel Morel,</span>
00052 <span class="comment">      Gregory Randall, CMLA, ENS Cachan, 2010.</span>
00053 <span class="comment"></span>
00054 <span class="comment">    The version implemented here includes some further improvements</span>
00055 <span class="comment">    described in the following publication, of which this code is part:</span>
00056 <span class="comment"></span>
00057 <span class="comment">      "LSD: a Line Segment Detector" by Rafael Grompone von Gioi,</span>
00058 <span class="comment">      Jeremie Jakubowicz, Jean-Michel Morel, and Gregory Randall,</span>
00059 <span class="comment">      Image Processing On Line, 2012. DOI:10.5201/ipol.2012.gjmr-lsd</span>
00060 <span class="comment">      http://dx.doi.org/10.5201/ipol.2012.gjmr-lsd</span>
00061 <span class="comment"></span>
00062 <span class="comment">    The module's main function is lsd().</span>
00063 <span class="comment"></span>
00064 <span class="comment">    The source code is contained in two files: lsd.h and lsd.c.</span>
00065 <span class="comment"></span>
00066 <span class="comment">    HISTORY:</span>
00067 <span class="comment">    - version 1.6 - nov 2011:</span>
00068 <span class="comment">                              - changes in the interface,</span>
00069 <span class="comment">                              - max_grad parameter removed,</span>
00070 <span class="comment">                              - the factor 11 was added to the number of test</span>
00071 <span class="comment">                                to consider the different precision values</span>
00072 <span class="comment">                                tested,</span>
00073 <span class="comment">                              - a minor bug corrected in the gradient sorting</span>
00074 <span class="comment">                                code,</span>
00075 <span class="comment">                              - the algorithm now also returns p and log_nfa</span>
00076 <span class="comment">                                for each detection,</span>
00077 <span class="comment">                              - a minor bug was corrected in the image scaling,</span>
00078 <span class="comment">                              - the angle comparison in "isaligned" changed</span>
00079 <span class="comment">                                from &lt; to &lt;=,</span>
00080 <span class="comment">                              - "eps" variable renamed "log_eps",</span>
00081 <span class="comment">                              - "lsd_scale_region" interface was added,</span>
00082 <span class="comment">                              - minor changes to comments.</span>
00083 <span class="comment">    - version 1.5 - dec 2010: Changes in 'refine', -W option added,</span>
00084 <span class="comment">                              and more comments added.</span>
00085 <span class="comment">    - version 1.4 - jul 2010: lsd_scale interface added and doxygen doc.</span>
00086 <span class="comment">    - version 1.3 - feb 2010: Multiple bug correction and improved code.</span>
00087 <span class="comment">    - version 1.2 - dec 2009: First full Ansi C Language version.</span>
00088 <span class="comment">    - version 1.1 - sep 2009: Systematic subsampling to scale 0.8 and</span>
00089 <span class="comment">                              correction to partially handle "angle problem".</span>
00090 <span class="comment">    - version 1.0 - jan 2009: First complete Megawave2 and Ansi C Language</span>
00091 <span class="comment">                              version.</span>
00092 <span class="comment"></span>
00093 <span class="comment">    @author rafael grompone von gioi &lt;grompone@gmail.com&gt;</span>
00094 <span class="comment"> */</span>
00095 <span class="comment">/*----------------------------------------------------------------------------*/</span>
00096 
00097 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00098 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00099 <span class="preprocessor">#include &lt;math.h&gt;</span>
00100 <span class="preprocessor">#include &lt;limits.h&gt;</span>
00101 <span class="preprocessor">#include &lt;float.h&gt;</span>
00102 <span class="preprocessor">#include "<a class="code" href="lsd_8h.html">lsd.h</a>"</span>
00103 <span class="comment"></span>
00104 <span class="comment">/** ln(10) */</span>
00105 <span class="preprocessor">#ifndef M_LN10</span>
<a name="l00106"></a><a class="code" href="lsd_8c.html#a0">00106</a> <span class="preprocessor"></span><span class="preprocessor">#define M_LN10 2.30258509299404568402</span>
00107 <span class="preprocessor"></span><span class="preprocessor">#endif </span><span class="comment">/* !M_LN10 */</span>
00108 <span class="comment"></span>
00109 <span class="comment">/** PI */</span>
00110 <span class="preprocessor">#ifndef M_PI</span>
<a name="l00111"></a><a class="code" href="lsd_8c.html#a1">00111</a> <span class="preprocessor"></span><span class="preprocessor">#define M_PI   3.14159265358979323846</span>
00112 <span class="preprocessor"></span><span class="preprocessor">#endif </span><span class="comment">/* !M_PI */</span>
00113 
00114 <span class="preprocessor">#ifndef FALSE</span>
<a name="l00115"></a><a class="code" href="lsd_8c.html#a2">00115</a> <span class="preprocessor"></span><span class="preprocessor">#define FALSE 0</span>
00116 <span class="preprocessor"></span><span class="preprocessor">#endif </span><span class="comment">/* !FALSE */</span>
00117 
00118 <span class="preprocessor">#ifndef TRUE</span>
<a name="l00119"></a><a class="code" href="lsd_8c.html#a3">00119</a> <span class="preprocessor"></span><span class="preprocessor">#define TRUE 1</span>
00120 <span class="preprocessor"></span><span class="preprocessor">#endif </span><span class="comment">/* !TRUE */</span>
00121 <span class="comment"></span>
00122 <span class="comment">/** Label for pixels with undefined gradient. */</span>
<a name="l00123"></a><a class="code" href="lsd_8c.html#a4">00123</a> <span class="preprocessor">#define NOTDEF -1024.0</span>
00124 <span class="preprocessor"></span><span class="comment"></span>
00125 <span class="comment">/** 3/2 pi */</span>
<a name="l00126"></a><a class="code" href="lsd_8c.html#a5">00126</a> <span class="preprocessor">#define M_3_2_PI 4.71238898038</span>
00127 <span class="preprocessor"></span><span class="comment"></span>
00128 <span class="comment">/** 2 pi */</span>
<a name="l00129"></a><a class="code" href="lsd_8c.html#a6">00129</a> <span class="preprocessor">#define M_2__PI  6.28318530718</span>
00130 <span class="preprocessor"></span><span class="comment"></span>
00131 <span class="comment">/** Label for pixels not used in yet. */</span>
<a name="l00132"></a><a class="code" href="lsd_8c.html#a7">00132</a> <span class="preprocessor">#define NOTUSED 0</span>
00133 <span class="preprocessor"></span><span class="comment"></span>
00134 <span class="comment">/** Label for pixels already used in detection. */</span>
<a name="l00135"></a><a class="code" href="lsd_8c.html#a8">00135</a> <span class="preprocessor">#define USED    1</span>
00136 <span class="preprocessor"></span>
00137 <span class="comment">/*----------------------------------------------------------------------------*/</span><span class="comment"></span>
00138 <span class="comment">/** Chained list of coordinates.</span>
00139 <span class="comment"> */</span>
<a name="l00140"></a><a class="code" href="structcoorlist.html">00140</a> <span class="keyword">struct </span><a class="code" href="structcoorlist.html">coorlist</a>
00141 {
<a name="l00142"></a><a class="code" href="structcoorlist.html#o1">00142</a>   <span class="keywordtype">int</span> <a class="code" href="structcoorlist.html#o0">x</a>,<a class="code" href="structcoorlist.html#o1">y</a>;
<a name="l00143"></a><a class="code" href="structcoorlist.html#o2">00143</a>   <span class="keyword">struct </span><a class="code" href="structcoorlist.html">coorlist</a> * <a class="code" href="structcoorlist.html#o2">next</a>;
00144 };
00145 
00146 <span class="comment">/*----------------------------------------------------------------------------*/</span><span class="comment"></span>
00147 <span class="comment">/** A point (or pixel).</span>
00148 <span class="comment"> */</span>
<a name="l00149"></a><a class="code" href="structpoint.html#o1">00149</a> <span class="keyword">struct </span><a class="code" href="structpoint.html">point</a> {<span class="keywordtype">int</span> <a class="code" href="structpoint.html#o0">x</a>,<a class="code" href="structpoint.html#o1">y</a>;};
00150 
00151 
00152 <span class="comment">/*----------------------------------------------------------------------------*/</span>
00153 <span class="comment">/*------------------------- Miscellaneous functions --------------------------*/</span>
00154 <span class="comment">/*----------------------------------------------------------------------------*/</span>
00155 
00156 <span class="comment">/*----------------------------------------------------------------------------*/</span><span class="comment"></span>
00157 <span class="comment">/** Fatal error, print a message to standard-error output and exit.</span>
00158 <span class="comment"> */</span>
<a name="l00159"></a><a class="code" href="lsd_8c.html#a16">00159</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="lsd_8c.html#a16">error</a>(<span class="keywordtype">char</span> * msg)
00160 {
00161   fprintf(stderr,<span class="stringliteral">"LSD Error: %s\n"</span>,msg);
00162   exit(EXIT_FAILURE);
00163 }
00164 
00165 <span class="comment">/*----------------------------------------------------------------------------*/</span><span class="comment"></span>
00166 <span class="comment">/** Doubles relative error factor</span>
00167 <span class="comment"> */</span>
<a name="l00168"></a><a class="code" href="lsd_8c.html#a9">00168</a> <span class="preprocessor">#define RELATIVE_ERROR_FACTOR 100.0</span>
00169 <span class="preprocessor"></span>
00170 <span class="comment">/*----------------------------------------------------------------------------*/</span><span class="comment"></span>
00171 <span class="comment">/** Compare doubles by relative error.</span>
00172 <span class="comment"></span>
00173 <span class="comment">    The resulting rounding error after floating point computations</span>
00174 <span class="comment">    depend on the specific operations done. The same number computed by</span>
00175 <span class="comment">    different algorithms could present different rounding errors. For a</span>
00176 <span class="comment">    useful comparison, an estimation of the relative rounding error</span>
00177 <span class="comment">    should be considered and compared to a factor times EPS. The factor</span>
00178 <span class="comment">    should be related to the cumulated rounding error in the chain of</span>
00179 <span class="comment">    computation. Here, as a simplification, a fixed factor is used.</span>
00180 <span class="comment"> */</span>
<a name="l00181"></a><a class="code" href="lsd_8c.html#a17">00181</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="lsd_8c.html#a17">double_equal</a>(<span class="keywordtype">double</span> a, <span class="keywordtype">double</span> b)
00182 {
00183   <span class="keywordtype">double</span> abs_diff,aa,bb,abs_max;
00184 
00185   <span class="comment">/* trivial case */</span>
00186   <span class="keywordflow">if</span>( a == b ) <span class="keywordflow">return</span> <a class="code" href="lsd_8c.html#a3">TRUE</a>;
00187 
00188   abs_diff = fabs(a-b);
00189   aa = fabs(a);
00190   bb = fabs(b);
00191   abs_max = aa &gt; bb ? aa : bb;
00192 
00193   <span class="comment">/* DBL_MIN is the smallest normalized number, thus, the smallest</span>
00194 <span class="comment">     number whose relative error is bounded by DBL_EPSILON. For</span>
00195 <span class="comment">     smaller numbers, the same quantization steps as for DBL_MIN</span>
00196 <span class="comment">     are used. Then, for smaller numbers, a meaningful "relative"</span>
00197 <span class="comment">     error should be computed by dividing the difference by DBL_MIN. */</span>
00198   <span class="keywordflow">if</span>( abs_max &lt; DBL_MIN ) abs_max = DBL_MIN;
00199 
00200   <span class="comment">/* equal if relative error &lt;= factor x eps */</span>
00201   <span class="keywordflow">return</span> (abs_diff / abs_max) &lt;= (<a class="code" href="lsd_8c.html#a9">RELATIVE_ERROR_FACTOR</a> * DBL_EPSILON);
00202 }
00203 
00204 <span class="comment">/*----------------------------------------------------------------------------*/</span><span class="comment"></span>
00205 <span class="comment">/** Computes Euclidean distance between point (x1,y1) and point (x2,y2).</span>
00206 <span class="comment"> */</span>
<a name="l00207"></a><a class="code" href="lsd_8c.html#a18">00207</a> <span class="keyword">static</span> <span class="keywordtype">double</span> <a class="code" href="lsd_8c.html#a18">dist</a>(<span class="keywordtype">double</span> x1, <span class="keywordtype">double</span> y1, <span class="keywordtype">double</span> x2, <span class="keywordtype">double</span> y2)
00208 {
00209   <span class="keywordflow">return</span> sqrt( (x2-x1)*(x2-x1) + (y2-y1)*(y2-y1) );
00210 }
00211 
00212 
00213 <span class="comment">/*----------------------------------------------------------------------------*/</span>
00214 <span class="comment">/*----------------------- 'list of n-tuple' data type ------------------------*/</span>
00215 <span class="comment">/*----------------------------------------------------------------------------*/</span>
00216 
00217 <span class="comment">/*----------------------------------------------------------------------------*/</span><span class="comment"></span>
00218 <span class="comment">/** 'list of n-tuple' data type</span>
00219 <span class="comment"></span>
00220 <span class="comment">    The i-th component of the j-th n-tuple of an n-tuple list 'ntl'</span>
00221 <span class="comment">    is accessed with:</span>
00222 <span class="comment"></span>
00223 <span class="comment">      ntl-&gt;values[ i + j * ntl-&gt;dim ]</span>
00224 <span class="comment"></span>
00225 <span class="comment">    The dimension of the n-tuple (n) is:</span>
00226 <span class="comment"></span>
00227 <span class="comment">      ntl-&gt;dim</span>
00228 <span class="comment"></span>
00229 <span class="comment">    The number of n-tuples in the list is:</span>
00230 <span class="comment"></span>
00231 <span class="comment">      ntl-&gt;size</span>
00232 <span class="comment"></span>
00233 <span class="comment">    The maximum number of n-tuples that can be stored in the</span>
00234 <span class="comment">    list with the allocated memory at a given time is given by:</span>
00235 <span class="comment"></span>
00236 <span class="comment">      ntl-&gt;max_size</span>
00237 <span class="comment"> */</span>
<a name="l00238"></a><a class="code" href="structntuple__list__s.html">00238</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structntuple__list__s.html">ntuple_list_s</a>
00239 {
<a name="l00240"></a><a class="code" href="structntuple__list__s.html#o0">00240</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="structntuple__list__s.html#o0">size</a>;
<a name="l00241"></a><a class="code" href="structntuple__list__s.html#o1">00241</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="structntuple__list__s.html#o1">max_size</a>;
<a name="l00242"></a><a class="code" href="structntuple__list__s.html#o2">00242</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="structntuple__list__s.html#o2">dim</a>;
<a name="l00243"></a><a class="code" href="structntuple__list__s.html#o3">00243</a>   <span class="keywordtype">double</span> * <a class="code" href="structntuple__list__s.html#o3">values</a>;
00244 } * <a class="code" href="structntuple__list__s.html">ntuple_list</a>;
00245 
00246 <span class="comment">/*----------------------------------------------------------------------------*/</span><span class="comment"></span>
00247 <span class="comment">/** Free memory used in n-tuple 'in'.</span>
00248 <span class="comment"> */</span>
<a name="l00249"></a><a class="code" href="lsd_8c.html#a19">00249</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="lsd_8c.html#a19">free_ntuple_list</a>(<a class="code" href="structntuple__list__s.html">ntuple_list</a> in)
00250 {
00251   <span class="keywordflow">if</span>( in == NULL || in-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a> == NULL )
00252     <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"free_ntuple_list: invalid n-tuple input."</span>);
00253   free( (<span class="keywordtype">void</span> *) in-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a> );
00254   free( (<span class="keywordtype">void</span> *) in );
00255 }
00256 
00257 <span class="comment">/*----------------------------------------------------------------------------*/</span><span class="comment"></span>
00258 <span class="comment">/** Create an n-tuple list and allocate memory for one element.</span>
00259 <span class="comment">    @param dim the dimension (n) of the n-tuple.</span>
00260 <span class="comment"> */</span>
<a name="l00261"></a><a class="code" href="lsd_8c.html#a20">00261</a> <span class="keyword">static</span> <a class="code" href="structntuple__list__s.html">ntuple_list</a> <a class="code" href="lsd_8c.html#a20">new_ntuple_list</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim)
00262 {
00263   <a class="code" href="structntuple__list__s.html">ntuple_list</a> n_tuple;
00264 
00265   <span class="comment">/* check parameters */</span>
00266   <span class="keywordflow">if</span>( dim == 0 ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"new_ntuple_list: 'dim' must be positive."</span>);
00267 
00268   <span class="comment">/* get memory for list structure */</span>
00269   n_tuple = (<a class="code" href="structntuple__list__s.html">ntuple_list</a>) malloc( <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structntuple__list__s.html">ntuple_list_s</a>) );
00270   <span class="keywordflow">if</span>( n_tuple == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"not enough memory."</span>);
00271 
00272   <span class="comment">/* initialize list */</span>
00273   n_tuple-&gt;<a class="code" href="structntuple__list__s.html#o0">size</a> = 0;
00274   n_tuple-&gt;<a class="code" href="structntuple__list__s.html#o1">max_size</a> = 1;
00275   n_tuple-&gt;<a class="code" href="structntuple__list__s.html#o2">dim</a> = dim;
00276 
00277   <span class="comment">/* get memory for tuples */</span>
00278   n_tuple-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a> = (<span class="keywordtype">double</span> *) malloc( dim*n_tuple-&gt;<a class="code" href="structntuple__list__s.html#o1">max_size</a> * <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>) );
00279   <span class="keywordflow">if</span>( n_tuple-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a> == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"not enough memory."</span>);
00280 
00281   <span class="keywordflow">return</span> n_tuple;
00282 }
00283 
00284 <span class="comment">/*----------------------------------------------------------------------------*/</span><span class="comment"></span>
00285 <span class="comment">/** Enlarge the allocated memory of an n-tuple list.</span>
00286 <span class="comment"> */</span>
<a name="l00287"></a><a class="code" href="lsd_8c.html#a21">00287</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="lsd_8c.html#a21">enlarge_ntuple_list</a>(<a class="code" href="structntuple__list__s.html">ntuple_list</a> n_tuple)
00288 {
00289   <span class="comment">/* check parameters */</span>
00290   <span class="keywordflow">if</span>( n_tuple == NULL || n_tuple-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a> == NULL || n_tuple-&gt;<a class="code" href="structntuple__list__s.html#o1">max_size</a> == 0 )
00291     <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"enlarge_ntuple_list: invalid n-tuple."</span>);
00292 
00293   <span class="comment">/* duplicate number of tuples */</span>
00294   n_tuple-&gt;<a class="code" href="structntuple__list__s.html#o1">max_size</a> *= 2;
00295 
00296   <span class="comment">/* realloc memory */</span>
00297   n_tuple-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a> = (<span class="keywordtype">double</span> *) realloc( (<span class="keywordtype">void</span> *) n_tuple-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a>,
00298                       n_tuple-&gt;<a class="code" href="structntuple__list__s.html#o2">dim</a> * n_tuple-&gt;<a class="code" href="structntuple__list__s.html#o1">max_size</a> * <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>) );
00299   <span class="keywordflow">if</span>( n_tuple-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a> == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"not enough memory."</span>);
00300 }
00301 
00302 <span class="comment">/*----------------------------------------------------------------------------*/</span><span class="comment"></span>
00303 <span class="comment">/** Add a 7-tuple to an n-tuple list.</span>
00304 <span class="comment"> */</span>
<a name="l00305"></a><a class="code" href="lsd_8c.html#a22">00305</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="lsd_8c.html#a22">add_7tuple</a>( <a class="code" href="structntuple__list__s.html">ntuple_list</a> out, <span class="keywordtype">double</span> v1, <span class="keywordtype">double</span> v2, <span class="keywordtype">double</span> v3,
00306                         <span class="keywordtype">double</span> v4, <span class="keywordtype">double</span> v5, <span class="keywordtype">double</span> v6, <span class="keywordtype">double</span> v7 )
00307 {
00308   <span class="comment">/* check parameters */</span>
00309   <span class="keywordflow">if</span>( out == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"add_7tuple: invalid n-tuple input."</span>);
00310   <span class="keywordflow">if</span>( out-&gt;<a class="code" href="structntuple__list__s.html#o2">dim</a> != 7 ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"add_7tuple: the n-tuple must be a 7-tuple."</span>);
00311 
00312   <span class="comment">/* if needed, alloc more tuples to 'out' */</span>
00313   <span class="keywordflow">if</span>( out-&gt;<a class="code" href="structntuple__list__s.html#o0">size</a> == out-&gt;<a class="code" href="structntuple__list__s.html#o1">max_size</a> ) <a class="code" href="lsd_8c.html#a21">enlarge_ntuple_list</a>(out);
00314   <span class="keywordflow">if</span>( out-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a> == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"add_7tuple: invalid n-tuple input."</span>);
00315 
00316   <span class="comment">/* add new 7-tuple */</span>
00317   out-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a>[ out-&gt;<a class="code" href="structntuple__list__s.html#o0">size</a> * out-&gt;<a class="code" href="structntuple__list__s.html#o2">dim</a> + 0 ] = v1;
00318   out-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a>[ out-&gt;<a class="code" href="structntuple__list__s.html#o0">size</a> * out-&gt;<a class="code" href="structntuple__list__s.html#o2">dim</a> + 1 ] = v2;
00319   out-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a>[ out-&gt;<a class="code" href="structntuple__list__s.html#o0">size</a> * out-&gt;<a class="code" href="structntuple__list__s.html#o2">dim</a> + 2 ] = v3;
00320   out-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a>[ out-&gt;<a class="code" href="structntuple__list__s.html#o0">size</a> * out-&gt;<a class="code" href="structntuple__list__s.html#o2">dim</a> + 3 ] = v4;
00321   out-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a>[ out-&gt;<a class="code" href="structntuple__list__s.html#o0">size</a> * out-&gt;<a class="code" href="structntuple__list__s.html#o2">dim</a> + 4 ] = v5;
00322   out-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a>[ out-&gt;<a class="code" href="structntuple__list__s.html#o0">size</a> * out-&gt;<a class="code" href="structntuple__list__s.html#o2">dim</a> + 5 ] = v6;
00323   out-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a>[ out-&gt;<a class="code" href="structntuple__list__s.html#o0">size</a> * out-&gt;<a class="code" href="structntuple__list__s.html#o2">dim</a> + 6 ] = v7;
00324 
00325   <span class="comment">/* update number of tuples counter */</span>
00326   out-&gt;<a class="code" href="structntuple__list__s.html#o0">size</a>++;
00327 }
00328 
00329 
00330 <span class="comment">/*----------------------------------------------------------------------------*/</span>
00331 <span class="comment">/*----------------------------- Image Data Types -----------------------------*/</span>
00332 <span class="comment">/*----------------------------------------------------------------------------*/</span>
00333 
00334 <span class="comment">/*----------------------------------------------------------------------------*/</span><span class="comment"></span>
00335 <span class="comment">/** char image data type</span>
00336 <span class="comment"></span>
00337 <span class="comment">    The pixel value at (x,y) is accessed by:</span>
00338 <span class="comment"></span>
00339 <span class="comment">      image-&gt;data[ x + y * image-&gt;xsize ]</span>
00340 <span class="comment"></span>
00341 <span class="comment">    with x and y integer.</span>
00342 <span class="comment"> */</span>
<a name="l00343"></a><a class="code" href="structimage__char__s.html">00343</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structimage__char__s.html">image_char_s</a>
00344 {
<a name="l00345"></a><a class="code" href="structimage__char__s.html#o0">00345</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> * <a class="code" href="structimage__char__s.html#o0">data</a>;
<a name="l00346"></a><a class="code" href="structimage__char__s.html#o2">00346</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="structimage__char__s.html#o1">xsize</a>,<a class="code" href="structimage__char__s.html#o2">ysize</a>;
00347 } * <a class="code" href="structimage__char__s.html">image_char</a>;
00348 
00349 <span class="comment">/*----------------------------------------------------------------------------*/</span><span class="comment"></span>
00350 <span class="comment">/** Free memory used in image_char 'i'.</span>
00351 <span class="comment"> */</span>
<a name="l00352"></a><a class="code" href="lsd_8c.html#a23">00352</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="lsd_8c.html#a23">free_image_char</a>(<a class="code" href="structimage__char__s.html">image_char</a> i)
00353 {
00354   <span class="keywordflow">if</span>( i == NULL || i-&gt;<a class="code" href="structimage__char__s.html#o0">data</a> == NULL )
00355     <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"free_image_char: invalid input image."</span>);
00356   free( (<span class="keywordtype">void</span> *) i-&gt;<a class="code" href="structimage__char__s.html#o0">data</a> );
00357   free( (<span class="keywordtype">void</span> *) i );
00358 }
00359 
00360 <span class="comment">/*----------------------------------------------------------------------------*/</span><span class="comment"></span>
00361 <span class="comment">/** Create a new image_char of size 'xsize' times 'ysize'.</span>
00362 <span class="comment"> */</span>
<a name="l00363"></a><a class="code" href="lsd_8c.html#a24">00363</a> <span class="keyword">static</span> <a class="code" href="structimage__char__s.html">image_char</a> <a class="code" href="lsd_8c.html#a24">new_image_char</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> xsize, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ysize)
00364 {
00365   <a class="code" href="structimage__char__s.html">image_char</a> image;
00366 
00367   <span class="comment">/* check parameters */</span>
00368   <span class="keywordflow">if</span>( xsize == 0 || ysize == 0 ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"new_image_char: invalid image size."</span>);
00369 
00370   <span class="comment">/* get memory */</span>
00371   image = (<a class="code" href="structimage__char__s.html">image_char</a>) malloc( <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structimage__char__s.html">image_char_s</a>) );
00372   <span class="keywordflow">if</span>( image == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"not enough memory."</span>);
00373   image-&gt;<a class="code" href="structimage__char__s.html#o0">data</a> = (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *) calloc( (size_t) (xsize*ysize),
00374                                           <span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>) );
00375   <span class="keywordflow">if</span>( image-&gt;<a class="code" href="structimage__char__s.html#o0">data</a> == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"not enough memory."</span>);
00376 
00377   <span class="comment">/* set image size */</span>
00378   image-&gt;<a class="code" href="structimage__char__s.html#o1">xsize</a> = xsize;
00379   image-&gt;<a class="code" href="structimage__char__s.html#o2">ysize</a> = ysize;
00380 
00381   <span class="keywordflow">return</span> image;
00382 }
00383 
00384 <span class="comment">/*----------------------------------------------------------------------------*/</span><span class="comment"></span>
00385 <span class="comment">/** Create a new image_char of size 'xsize' times 'ysize',</span>
00386 <span class="comment">    initialized to the value 'fill_value'.</span>
00387 <span class="comment"> */</span>
<a name="l00388"></a><a class="code" href="lsd_8c.html#a25">00388</a> <span class="keyword">static</span> <a class="code" href="structimage__char__s.html">image_char</a> <a class="code" href="lsd_8c.html#a25">new_image_char_ini</a>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> xsize, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ysize,
00389                                       <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> fill_value )
00390 {
00391   <a class="code" href="structimage__char__s.html">image_char</a> image = <a class="code" href="lsd_8c.html#a24">new_image_char</a>(xsize,ysize); <span class="comment">/* create image */</span>
00392   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N = xsize*ysize;
00393   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i;
00394 
00395   <span class="comment">/* check parameters */</span>
00396   <span class="keywordflow">if</span>( image == NULL || image-&gt;<a class="code" href="structimage__char__s.html#o0">data</a> == NULL )
00397     <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"new_image_char_ini: invalid image."</span>);
00398 
00399   <span class="comment">/* initialize */</span>
00400   <span class="keywordflow">for</span>(i=0; i&lt;N; i++) image-&gt;<a class="code" href="structimage__char__s.html#o0">data</a>[i] = fill_value;
00401 
00402   <span class="keywordflow">return</span> image;
00403 }
00404 
00405 <span class="comment">/*----------------------------------------------------------------------------*/</span><span class="comment"></span>
00406 <span class="comment">/** int image data type</span>
00407 <span class="comment"></span>
00408 <span class="comment">    The pixel value at (x,y) is accessed by:</span>
00409 <span class="comment"></span>
00410 <span class="comment">      image-&gt;data[ x + y * image-&gt;xsize ]</span>
00411 <span class="comment"></span>
00412 <span class="comment">    with x and y integer.</span>
00413 <span class="comment"> */</span>
<a name="l00414"></a><a class="code" href="structimage__int__s.html">00414</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structimage__int__s.html">image_int_s</a>
00415 {
<a name="l00416"></a><a class="code" href="structimage__int__s.html#o0">00416</a>   <span class="keywordtype">int</span> * <a class="code" href="structimage__int__s.html#o0">data</a>;
<a name="l00417"></a><a class="code" href="structimage__int__s.html#o2">00417</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="structimage__int__s.html#o1">xsize</a>,<a class="code" href="structimage__int__s.html#o2">ysize</a>;
00418 } * <a class="code" href="structimage__int__s.html">image_int</a>;
00419 
00420 <span class="comment">/*----------------------------------------------------------------------------*/</span><span class="comment"></span>
00421 <span class="comment">/** Create a new image_int of size 'xsize' times 'ysize'.</span>
00422 <span class="comment"> */</span>
<a name="l00423"></a><a class="code" href="lsd_8c.html#a26">00423</a> <span class="keyword">static</span> <a class="code" href="structimage__int__s.html">image_int</a> <a class="code" href="lsd_8c.html#a26">new_image_int</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> xsize, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ysize)
00424 {
00425   <a class="code" href="structimage__int__s.html">image_int</a> image;
00426 
00427   <span class="comment">/* check parameters */</span>
00428   <span class="keywordflow">if</span>( xsize == 0 || ysize == 0 ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"new_image_int: invalid image size."</span>);
00429 
00430   <span class="comment">/* get memory */</span>
00431   image = (<a class="code" href="structimage__int__s.html">image_int</a>) malloc( <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structimage__int__s.html">image_int_s</a>) );
00432   <span class="keywordflow">if</span>( image == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"not enough memory."</span>);
00433   image-&gt;<a class="code" href="structimage__int__s.html#o0">data</a> = (<span class="keywordtype">int</span> *) calloc( (size_t) (xsize*ysize), <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>) );
00434   <span class="keywordflow">if</span>( image-&gt;<a class="code" href="structimage__int__s.html#o0">data</a> == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"not enough memory."</span>);
00435 
00436   <span class="comment">/* set image size */</span>
00437   image-&gt;<a class="code" href="structimage__int__s.html#o1">xsize</a> = xsize;
00438   image-&gt;<a class="code" href="structimage__int__s.html#o2">ysize</a> = ysize;
00439 
00440   <span class="keywordflow">return</span> image;
00441 }
00442 
00443 <span class="comment">/*----------------------------------------------------------------------------*/</span><span class="comment"></span>
00444 <span class="comment">/** Create a new image_int of size 'xsize' times 'ysize',</span>
00445 <span class="comment">    initialized to the value 'fill_value'.</span>
00446 <span class="comment"> */</span>
<a name="l00447"></a><a class="code" href="lsd_8c.html#a27">00447</a> <span class="keyword">static</span> <a class="code" href="structimage__int__s.html">image_int</a> <a class="code" href="lsd_8c.html#a27">new_image_int_ini</a>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> xsize, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ysize,
00448                                     <span class="keywordtype">int</span> fill_value )
00449 {
00450   <a class="code" href="structimage__int__s.html">image_int</a> image = <a class="code" href="lsd_8c.html#a26">new_image_int</a>(xsize,ysize); <span class="comment">/* create image */</span>
00451   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N = xsize*ysize;
00452   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i;
00453 
00454   <span class="comment">/* initialize */</span>
00455   <span class="keywordflow">for</span>(i=0; i&lt;N; i++) image-&gt;<a class="code" href="structimage__int__s.html#o0">data</a>[i] = fill_value;
00456 
00457   <span class="keywordflow">return</span> image;
00458 }
00459 
00460 <span class="comment">/*----------------------------------------------------------------------------*/</span><span class="comment"></span>
00461 <span class="comment">/** double image data type</span>
00462 <span class="comment"></span>
00463 <span class="comment">    The pixel value at (x,y) is accessed by:</span>
00464 <span class="comment"></span>
00465 <span class="comment">      image-&gt;data[ x + y * image-&gt;xsize ]</span>
00466 <span class="comment"></span>
00467 <span class="comment">    with x and y integer.</span>
00468 <span class="comment"> */</span>
<a name="l00469"></a><a class="code" href="structimage__double__s.html">00469</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structimage__double__s.html">image_double_s</a>
00470 {
<a name="l00471"></a><a class="code" href="structimage__double__s.html#o0">00471</a>   <span class="keywordtype">double</span> * <a class="code" href="structimage__double__s.html#o0">data</a>;
<a name="l00472"></a><a class="code" href="structimage__double__s.html#o2">00472</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="structimage__double__s.html#o1">xsize</a>,<a class="code" href="structimage__double__s.html#o2">ysize</a>;
00473 } * <a class="code" href="structimage__double__s.html">image_double</a>;
00474 
00475 <span class="comment">/*----------------------------------------------------------------------------*/</span><span class="comment"></span>
00476 <span class="comment">/** Free memory used in image_double 'i'.</span>
00477 <span class="comment"> */</span>
<a name="l00478"></a><a class="code" href="lsd_8c.html#a28">00478</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="lsd_8c.html#a28">free_image_double</a>(<a class="code" href="structimage__double__s.html">image_double</a> i)
00479 {
00480   <span class="keywordflow">if</span>( i == NULL || i-&gt;<a class="code" href="structimage__double__s.html#o0">data</a> == NULL )
00481     <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"free_image_double: invalid input image."</span>);
00482   free( (<span class="keywordtype">void</span> *) i-&gt;<a class="code" href="structimage__double__s.html#o0">data</a> );
00483   free( (<span class="keywordtype">void</span> *) i );
00484 }
00485 
00486 <span class="comment">/*----------------------------------------------------------------------------*/</span><span class="comment"></span>
00487 <span class="comment">/** Create a new image_double of size 'xsize' times 'ysize'.</span>
00488 <span class="comment"> */</span>
<a name="l00489"></a><a class="code" href="lsd_8c.html#a29">00489</a> <span class="keyword">static</span> <a class="code" href="structimage__double__s.html">image_double</a> <a class="code" href="lsd_8c.html#a29">new_image_double</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> xsize, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ysize)
00490 {
00491   <a class="code" href="structimage__double__s.html">image_double</a> image;
00492 
00493   <span class="comment">/* check parameters */</span>
00494   <span class="keywordflow">if</span>( xsize == 0 || ysize == 0 ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"new_image_double: invalid image size."</span>);
00495 
00496   <span class="comment">/* get memory */</span>
00497   image = (<a class="code" href="structimage__double__s.html">image_double</a>) malloc( <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structimage__double__s.html">image_double_s</a>) );
00498   <span class="keywordflow">if</span>( image == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"not enough memory."</span>);
00499   image-&gt;<a class="code" href="structimage__double__s.html#o0">data</a> = (<span class="keywordtype">double</span> *) calloc( (size_t) (xsize*ysize), <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>) );
00500   <span class="keywordflow">if</span>( image-&gt;<a class="code" href="structimage__double__s.html#o0">data</a> == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"not enough memory."</span>);
00501 
00502   <span class="comment">/* set image size */</span>
00503   image-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a> = xsize;
00504   image-&gt;<a class="code" href="structimage__double__s.html#o2">ysize</a> = ysize;
00505 
00506   <span class="keywordflow">return</span> image;
00507 }
00508 
00509 <span class="comment">/*----------------------------------------------------------------------------*/</span><span class="comment"></span>
00510 <span class="comment">/** Create a new image_double of size 'xsize' times 'ysize'</span>
00511 <span class="comment">    with the data pointed by 'data'.</span>
00512 <span class="comment"> */</span>
<a name="l00513"></a><a class="code" href="lsd_8c.html#a30">00513</a> <span class="keyword">static</span> <a class="code" href="structimage__double__s.html">image_double</a> <a class="code" href="lsd_8c.html#a30">new_image_double_ptr</a>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> xsize,
00514                                           <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ysize, <span class="keywordtype">double</span> * data )
00515 {
00516   <a class="code" href="structimage__double__s.html">image_double</a> image;
00517 
00518   <span class="comment">/* check parameters */</span>
00519   <span class="keywordflow">if</span>( xsize == 0 || ysize == 0 )
00520     <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"new_image_double_ptr: invalid image size."</span>);
00521   <span class="keywordflow">if</span>( data == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"new_image_double_ptr: NULL data pointer."</span>);
00522 
00523   <span class="comment">/* get memory */</span>
00524   image = (<a class="code" href="structimage__double__s.html">image_double</a>) malloc( <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structimage__double__s.html">image_double_s</a>) );
00525   <span class="keywordflow">if</span>( image == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"not enough memory."</span>);
00526 
00527   <span class="comment">/* set image */</span>
00528   image-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a> = xsize;
00529   image-&gt;<a class="code" href="structimage__double__s.html#o2">ysize</a> = ysize;
00530   image-&gt;<a class="code" href="structimage__double__s.html#o0">data</a> = data;
00531 
00532   <span class="keywordflow">return</span> image;
00533 }
00534 
00535 
00536 <span class="comment">/*----------------------------------------------------------------------------*/</span>
00537 <span class="comment">/*----------------------------- Gaussian filter ------------------------------*/</span>
00538 <span class="comment">/*----------------------------------------------------------------------------*/</span>
00539 
00540 <span class="comment">/*----------------------------------------------------------------------------*/</span><span class="comment"></span>
00541 <span class="comment">/** Compute a Gaussian kernel of length 'kernel-&gt;dim',</span>
00542 <span class="comment">    standard deviation 'sigma', and centered at value 'mean'.</span>
00543 <span class="comment"></span>
00544 <span class="comment">    For example, if mean=0.5, the Gaussian will be centered</span>
00545 <span class="comment">    in the middle point between values 'kernel-&gt;values[0]'</span>
00546 <span class="comment">    and 'kernel-&gt;values[1]'.</span>
00547 <span class="comment"> */</span>
<a name="l00548"></a><a class="code" href="lsd_8c.html#a31">00548</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="lsd_8c.html#a31">gaussian_kernel</a>(<a class="code" href="structntuple__list__s.html">ntuple_list</a> kernel, <span class="keywordtype">double</span> sigma, <span class="keywordtype">double</span> mean)
00549 {
00550   <span class="keywordtype">double</span> sum = 0.0;
00551   <span class="keywordtype">double</span> val;
00552   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i;
00553 
00554   <span class="comment">/* check parameters */</span>
00555   <span class="keywordflow">if</span>( kernel == NULL || kernel-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a> == NULL )
00556     <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"gaussian_kernel: invalid n-tuple 'kernel'."</span>);
00557   <span class="keywordflow">if</span>( sigma &lt;= 0.0 ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"gaussian_kernel: 'sigma' must be positive."</span>);
00558 
00559   <span class="comment">/* compute Gaussian kernel */</span>
00560   <span class="keywordflow">if</span>( kernel-&gt;<a class="code" href="structntuple__list__s.html#o1">max_size</a> &lt; 1 ) <a class="code" href="lsd_8c.html#a21">enlarge_ntuple_list</a>(kernel);
00561   kernel-&gt;<a class="code" href="structntuple__list__s.html#o0">size</a> = 1;
00562   <span class="keywordflow">for</span>(i=0;i&lt;kernel-&gt;<a class="code" href="structntuple__list__s.html#o2">dim</a>;i++)
00563     {
00564       val = ( (<span class="keywordtype">double</span>) i - mean ) / sigma;
00565       kernel-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a>[i] = exp( -0.5 * val * val );
00566       sum += kernel-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a>[i];
00567     }
00568 
00569   <span class="comment">/* normalization */</span>
00570   <span class="keywordflow">if</span>( sum &gt;= 0.0 ) <span class="keywordflow">for</span>(i=0;i&lt;kernel-&gt;<a class="code" href="structntuple__list__s.html#o2">dim</a>;i++) kernel-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a>[i] /= sum;
00571 }
00572 
00573 <span class="comment">/*----------------------------------------------------------------------------*/</span><span class="comment"></span>
00574 <span class="comment">/** Scale the input image 'in' by a factor 'scale' by Gaussian sub-sampling.</span>
00575 <span class="comment"></span>
00576 <span class="comment">    For example, scale=0.8 will give a result at 80% of the original size.</span>
00577 <span class="comment"></span>
00578 <span class="comment">    The image is convolved with a Gaussian kernel</span>
00579 <span class="comment">    @f[</span>
00580 <span class="comment">        G(x,y) = \frac{1}{2\pi\sigma^2} e^{-\frac{x^2+y^2}{2\sigma^2}}</span>
00581 <span class="comment">    @f]</span>
00582 <span class="comment">    before the sub-sampling to prevent aliasing.</span>
00583 <span class="comment"></span>
00584 <span class="comment">    The standard deviation sigma given by:</span>
00585 <span class="comment">    -  sigma = sigma_scale / scale,   if scale &lt;  1.0</span>
00586 <span class="comment">    -  sigma = sigma_scale,           if scale &gt;= 1.0</span>
00587 <span class="comment"></span>
00588 <span class="comment">    To be able to sub-sample at non-integer steps, some interpolation</span>
00589 <span class="comment">    is needed. In this implementation, the interpolation is done by</span>
00590 <span class="comment">    the Gaussian kernel, so both operations (filtering and sampling)</span>
00591 <span class="comment">    are done at the same time. The Gaussian kernel is computed</span>
00592 <span class="comment">    centered on the coordinates of the required sample. In this way,</span>
00593 <span class="comment">    when applied, it gives directly the result of convolving the image</span>
00594 <span class="comment">    with the kernel and interpolated to that particular position.</span>
00595 <span class="comment"></span>
00596 <span class="comment">    A fast algorithm is done using the separability of the Gaussian</span>
00597 <span class="comment">    kernel. Applying the 2D Gaussian kernel is equivalent to applying</span>
00598 <span class="comment">    first a horizontal 1D Gaussian kernel and then a vertical 1D</span>
00599 <span class="comment">    Gaussian kernel (or the other way round). The reason is that</span>
00600 <span class="comment">    @f[</span>
00601 <span class="comment">        G(x,y) = G(x) * G(y)</span>
00602 <span class="comment">    @f]</span>
00603 <span class="comment">    where</span>
00604 <span class="comment">    @f[</span>
00605 <span class="comment">        G(x) = \frac{1}{\sqrt{2\pi}\sigma} e^{-\frac{x^2}{2\sigma^2}}.</span>
00606 <span class="comment">    @f]</span>
00607 <span class="comment">    The algorithm first applies a combined Gaussian kernel and sampling</span>
00608 <span class="comment">    in the x axis, and then the combined Gaussian kernel and sampling</span>
00609 <span class="comment">    in the y axis.</span>
00610 <span class="comment"> */</span>
<a name="l00611"></a><a class="code" href="lsd_8c.html#a32">00611</a> <span class="keyword">static</span> <a class="code" href="structimage__double__s.html">image_double</a> <a class="code" href="lsd_8c.html#a32">gaussian_sampler</a>( <a class="code" href="structimage__double__s.html">image_double</a> in, <span class="keywordtype">double</span> scale,
00612                                       <span class="keywordtype">double</span> sigma_scale )
00613 {
00614   <a class="code" href="structimage__double__s.html">image_double</a> aux,out;
00615   <a class="code" href="structntuple__list__s.html">ntuple_list</a> kernel;
00616   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N,M,h,n,x,y,i;
00617   <span class="keywordtype">int</span> xc,yc,j,double_x_size,double_y_size;
00618   <span class="keywordtype">double</span> sigma,xx,yy,sum,prec;
00619 
00620   <span class="comment">/* check parameters */</span>
00621   <span class="keywordflow">if</span>( in == NULL || in-&gt;<a class="code" href="structimage__double__s.html#o0">data</a> == NULL || in-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a> == 0 || in-&gt;<a class="code" href="structimage__double__s.html#o2">ysize</a> == 0 )
00622     <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"gaussian_sampler: invalid image."</span>);
00623   <span class="keywordflow">if</span>( scale &lt;= 0.0 ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"gaussian_sampler: 'scale' must be positive."</span>);
00624   <span class="keywordflow">if</span>( sigma_scale &lt;= 0.0 )
00625     <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"gaussian_sampler: 'sigma_scale' must be positive."</span>);
00626 
00627   <span class="comment">/* compute new image size and get memory for images */</span>
00628   <span class="keywordflow">if</span>( in-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a> * scale &gt; (<span class="keywordtype">double</span>) UINT_MAX ||
00629       in-&gt;<a class="code" href="structimage__double__s.html#o2">ysize</a> * scale &gt; (<span class="keywordtype">double</span>) UINT_MAX )
00630     <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"gaussian_sampler: the output image size exceeds the handled size."</span>);
00631   N = (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>) ceil( in-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a> * scale );
00632   M = (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>) ceil( in-&gt;<a class="code" href="structimage__double__s.html#o2">ysize</a> * scale );
00633   aux = <a class="code" href="lsd_8c.html#a29">new_image_double</a>(N,in-&gt;<a class="code" href="structimage__double__s.html#o2">ysize</a>);
00634   out = <a class="code" href="lsd_8c.html#a29">new_image_double</a>(N,M);
00635 
00636   <span class="comment">/* sigma, kernel size and memory for the kernel */</span>
00637   sigma = scale &lt; 1.0 ? sigma_scale / scale : sigma_scale;
00638   <span class="comment">/*</span>
00639 <span class="comment">     The size of the kernel is selected to guarantee that the</span>
00640 <span class="comment">     the first discarded term is at least 10^prec times smaller</span>
00641 <span class="comment">     than the central value. For that, h should be larger than x, with</span>
00642 <span class="comment">       e^(-x^2/2sigma^2) = 1/10^prec.</span>
00643 <span class="comment">     Then,</span>
00644 <span class="comment">       x = sigma * sqrt( 2 * prec * ln(10) ).</span>
00645 <span class="comment">   */</span>
00646   prec = 3.0;
00647   h = (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>) ceil( sigma * sqrt( 2.0 * prec * log(10.0) ) );
00648   n = 1+2*h; <span class="comment">/* kernel size */</span>
00649   kernel = <a class="code" href="lsd_8c.html#a20">new_ntuple_list</a>(n);
00650 
00651   <span class="comment">/* auxiliary double image size variables */</span>
00652   double_x_size = (<span class="keywordtype">int</span>) (2 * in-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a>);
00653   double_y_size = (<span class="keywordtype">int</span>) (2 * in-&gt;<a class="code" href="structimage__double__s.html#o2">ysize</a>);
00654 
00655   <span class="comment">/* First subsampling: x axis */</span>
00656   <span class="keywordflow">for</span>(x=0;x&lt;aux-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a>;x++)
00657     {
00658       <span class="comment">/*</span>
00659 <span class="comment">         x   is the coordinate in the new image.</span>
00660 <span class="comment">         xx  is the corresponding x-value in the original size image.</span>
00661 <span class="comment">         xc  is the integer value, the pixel coordinate of xx.</span>
00662 <span class="comment">       */</span>
00663       xx = (<span class="keywordtype">double</span>) x / scale;
00664       <span class="comment">/* coordinate (0.0,0.0) is in the center of pixel (0,0),</span>
00665 <span class="comment">         so the pixel with xc=0 get the values of xx from -0.5 to 0.5 */</span>
00666       xc = (<span class="keywordtype">int</span>) floor( xx + 0.5 );
00667       <a class="code" href="lsd_8c.html#a31">gaussian_kernel</a>( kernel, sigma, (<span class="keywordtype">double</span>) h + xx - (<span class="keywordtype">double</span>) xc );
00668       <span class="comment">/* the kernel must be computed for each x because the fine</span>
00669 <span class="comment">         offset xx-xc is different in each case */</span>
00670 
00671       <span class="keywordflow">for</span>(y=0;y&lt;aux-&gt;<a class="code" href="structimage__double__s.html#o2">ysize</a>;y++)
00672         {
00673           sum = 0.0;
00674           <span class="keywordflow">for</span>(i=0;i&lt;kernel-&gt;<a class="code" href="structntuple__list__s.html#o2">dim</a>;i++)
00675             {
00676               j = xc - h + i;
00677 
00678               <span class="comment">/* symmetry boundary condition */</span>
00679               <span class="keywordflow">while</span>( j &lt; 0 ) j += double_x_size;
00680               <span class="keywordflow">while</span>( j &gt;= double_x_size ) j -= double_x_size;
00681               <span class="keywordflow">if</span>( j &gt;= (<span class="keywordtype">int</span>) in-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a> ) j = double_x_size-1-j;
00682 
00683               sum += in-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>[ j + y * in-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a> ] * kernel-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a>[i];
00684             }
00685           aux-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>[ x + y * aux-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a> ] = sum;
00686         }
00687     }
00688 
00689   <span class="comment">/* Second subsampling: y axis */</span>
00690   <span class="keywordflow">for</span>(y=0;y&lt;out-&gt;<a class="code" href="structimage__double__s.html#o2">ysize</a>;y++)
00691     {
00692       <span class="comment">/*</span>
00693 <span class="comment">         y   is the coordinate in the new image.</span>
00694 <span class="comment">         yy  is the corresponding x-value in the original size image.</span>
00695 <span class="comment">         yc  is the integer value, the pixel coordinate of xx.</span>
00696 <span class="comment">       */</span>
00697       yy = (<span class="keywordtype">double</span>) y / scale;
00698       <span class="comment">/* coordinate (0.0,0.0) is in the center of pixel (0,0),</span>
00699 <span class="comment">         so the pixel with yc=0 get the values of yy from -0.5 to 0.5 */</span>
00700       yc = (<span class="keywordtype">int</span>) floor( yy + 0.5 );
00701       <a class="code" href="lsd_8c.html#a31">gaussian_kernel</a>( kernel, sigma, (<span class="keywordtype">double</span>) h + yy - (<span class="keywordtype">double</span>) yc );
00702       <span class="comment">/* the kernel must be computed for each y because the fine</span>
00703 <span class="comment">         offset yy-yc is different in each case */</span>
00704 
00705       <span class="keywordflow">for</span>(x=0;x&lt;out-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a>;x++)
00706         {
00707           sum = 0.0;
00708           <span class="keywordflow">for</span>(i=0;i&lt;kernel-&gt;<a class="code" href="structntuple__list__s.html#o2">dim</a>;i++)
00709             {
00710               j = yc - h + i;
00711 
00712               <span class="comment">/* symmetry boundary condition */</span>
00713               <span class="keywordflow">while</span>( j &lt; 0 ) j += double_y_size;
00714               <span class="keywordflow">while</span>( j &gt;= double_y_size ) j -= double_y_size;
00715               <span class="keywordflow">if</span>( j &gt;= (<span class="keywordtype">int</span>) in-&gt;<a class="code" href="structimage__double__s.html#o2">ysize</a> ) j = double_y_size-1-j;
00716 
00717               sum += aux-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>[ x + j * aux-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a> ] * kernel-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a>[i];
00718             }
00719           out-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>[ x + y * out-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a> ] = sum;
00720         }
00721     }
00722 
00723   <span class="comment">/* free memory */</span>
00724   <a class="code" href="lsd_8c.html#a19">free_ntuple_list</a>(kernel);
00725   <a class="code" href="lsd_8c.html#a28">free_image_double</a>(aux);
00726 
00727   <span class="keywordflow">return</span> out;
00728 }
00729 
00730 
00731 <span class="comment">/*----------------------------------------------------------------------------*/</span>
00732 <span class="comment">/*--------------------------------- Gradient ---------------------------------*/</span>
00733 <span class="comment">/*----------------------------------------------------------------------------*/</span>
00734 
00735 <span class="comment">/*----------------------------------------------------------------------------*/</span><span class="comment"></span>
00736 <span class="comment">/** Computes the direction of the level line of 'in' at each point.</span>
00737 <span class="comment"></span>
00738 <span class="comment">    The result is:</span>
00739 <span class="comment">    - an image_double with the angle at each pixel, or NOTDEF if not defined.</span>
00740 <span class="comment">    - the image_double 'modgrad' (a pointer is passed as argument)</span>
00741 <span class="comment">      with the gradient magnitude at each point.</span>
00742 <span class="comment">    - a list of pixels 'list_p' roughly ordered by decreasing</span>
00743 <span class="comment">      gradient magnitude. (The order is made by classifying points</span>
00744 <span class="comment">      into bins by gradient magnitude. The parameters 'n_bins' and</span>
00745 <span class="comment">      'max_grad' specify the number of bins and the gradient modulus</span>
00746 <span class="comment">      at the highest bin. The pixels in the list would be in</span>
00747 <span class="comment">      decreasing gradient magnitude, up to a precision of the size of</span>
00748 <span class="comment">      the bins.)</span>
00749 <span class="comment">    - a pointer 'mem_p' to the memory used by 'list_p' to be able to</span>
00750 <span class="comment">      free the memory when it is not used anymore.</span>
00751 <span class="comment"> */</span>
<a name="l00752"></a><a class="code" href="lsd_8c.html#a33">00752</a> <span class="keyword">static</span> <a class="code" href="structimage__double__s.html">image_double</a> <a class="code" href="lsd_8c.html#a33">ll_angle</a>( <a class="code" href="structimage__double__s.html">image_double</a> in, <span class="keywordtype">double</span> threshold,
00753                               <span class="keyword">struct</span> <a class="code" href="structcoorlist.html">coorlist</a> ** list_p, <span class="keywordtype">void</span> ** mem_p,
00754                               <a class="code" href="structimage__double__s.html">image_double</a> * modgrad, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_bins )
00755 {
00756   <a class="code" href="structimage__double__s.html">image_double</a> g;
00757   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n,p,x,y,adr,i;
00758   <span class="keywordtype">double</span> com1,com2,gx,gy,norm,norm2;
00759   <span class="comment">/* the rest of the variables are used for pseudo-ordering</span>
00760 <span class="comment">     the gradient magnitude values */</span>
00761   <span class="keywordtype">int</span> list_count = 0;
00762   <span class="keyword">struct </span><a class="code" href="structcoorlist.html">coorlist</a> * list;
00763   <span class="keyword">struct </span><a class="code" href="structcoorlist.html">coorlist</a> ** range_l_s; <span class="comment">/* array of pointers to start of bin list */</span>
00764   <span class="keyword">struct </span><a class="code" href="structcoorlist.html">coorlist</a> ** range_l_e; <span class="comment">/* array of pointers to end of bin list */</span>
00765   <span class="keyword">struct </span><a class="code" href="structcoorlist.html">coorlist</a> * start;
00766   <span class="keyword">struct </span><a class="code" href="structcoorlist.html">coorlist</a> * end;
00767   <span class="keywordtype">double</span> max_grad = 0.0;
00768 
00769   <span class="comment">/* check parameters */</span>
00770   <span class="keywordflow">if</span>( in == NULL || in-&gt;<a class="code" href="structimage__double__s.html#o0">data</a> == NULL || in-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a> == 0 || in-&gt;<a class="code" href="structimage__double__s.html#o2">ysize</a> == 0 )
00771     <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"ll_angle: invalid image."</span>);
00772   <span class="keywordflow">if</span>( threshold &lt; 0.0 ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"ll_angle: 'threshold' must be positive."</span>);
00773   <span class="keywordflow">if</span>( list_p == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"ll_angle: NULL pointer 'list_p'."</span>);
00774   <span class="keywordflow">if</span>( mem_p == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"ll_angle: NULL pointer 'mem_p'."</span>);
00775   <span class="keywordflow">if</span>( modgrad == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"ll_angle: NULL pointer 'modgrad'."</span>);
00776   <span class="keywordflow">if</span>( n_bins == 0 ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"ll_angle: 'n_bins' must be positive."</span>);
00777 
00778   <span class="comment">/* image size shortcuts */</span>
00779   n = in-&gt;<a class="code" href="structimage__double__s.html#o2">ysize</a>;
00780   p = in-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a>;
00781 
00782   <span class="comment">/* allocate output image */</span>
00783   g = <a class="code" href="lsd_8c.html#a29">new_image_double</a>(in-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a>,in-&gt;<a class="code" href="structimage__double__s.html#o2">ysize</a>);
00784 
00785   <span class="comment">/* get memory for the image of gradient modulus */</span>
00786   *modgrad = <a class="code" href="lsd_8c.html#a29">new_image_double</a>(in-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a>,in-&gt;<a class="code" href="structimage__double__s.html#o2">ysize</a>);
00787 
00788   <span class="comment">/* get memory for "ordered" list of pixels */</span>
00789   list = (<span class="keyword">struct </span><a class="code" href="structcoorlist.html">coorlist</a> *) calloc( (size_t) (n*p), <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structcoorlist.html">coorlist</a>) );
00790   *mem_p = (<span class="keywordtype">void</span> *) list;
00791   range_l_s = (<span class="keyword">struct </span><a class="code" href="structcoorlist.html">coorlist</a> **) calloc( (size_t) n_bins,
00792                                            <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structcoorlist.html">coorlist</a> *) );
00793   range_l_e = (<span class="keyword">struct </span><a class="code" href="structcoorlist.html">coorlist</a> **) calloc( (size_t) n_bins,
00794                                            <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structcoorlist.html">coorlist</a> *) );
00795   <span class="keywordflow">if</span>( list == NULL || range_l_s == NULL || range_l_e == NULL )
00796     <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"not enough memory."</span>);
00797   <span class="keywordflow">for</span>(i=0;i&lt;n_bins;i++) range_l_s[i] = range_l_e[i] = NULL;
00798 
00799   <span class="comment">/* 'undefined' on the down and right boundaries */</span>
00800   <span class="keywordflow">for</span>(x=0;x&lt;p;x++) g-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>[(n-1)*p+x] = <a class="code" href="lsd_8c.html#a4">NOTDEF</a>;
00801   <span class="keywordflow">for</span>(y=0;y&lt;n;y++) g-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>[p*y+p-1]   = <a class="code" href="lsd_8c.html#a4">NOTDEF</a>;
00802 
00803   <span class="comment">/* compute gradient on the remaining pixels */</span>
00804   <span class="keywordflow">for</span>(x=0;x&lt;p-1;x++)
00805     <span class="keywordflow">for</span>(y=0;y&lt;n-1;y++)
00806       {
00807         adr = y*p+x;
00808 
00809         <span class="comment">/*</span>
00810 <span class="comment">           Norm 2 computation using 2x2 pixel window:</span>
00811 <span class="comment">             A B</span>
00812 <span class="comment">             C D</span>
00813 <span class="comment">           and</span>
00814 <span class="comment">             com1 = D-A,  com2 = B-C.</span>
00815 <span class="comment">           Then</span>
00816 <span class="comment">             gx = B+D - (A+C)   horizontal difference</span>
00817 <span class="comment">             gy = C+D - (A+B)   vertical difference</span>
00818 <span class="comment">           com1 and com2 are just to avoid 2 additions.</span>
00819 <span class="comment">         */</span>
00820         com1 = in-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>[adr+p+1] - in-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>[adr];
00821         com2 = in-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>[adr+1]   - in-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>[adr+p];
00822 
00823         gx = com1+com2; <span class="comment">/* gradient x component */</span>
00824         gy = com1-com2; <span class="comment">/* gradient y component */</span>
00825         norm2 = gx*gx+gy*gy;
00826         norm = sqrt( norm2 / 4.0 ); <span class="comment">/* gradient norm */</span>
00827 
00828         (*modgrad)-&gt;data[adr] = norm; <span class="comment">/* store gradient norm */</span>
00829 
00830         <span class="keywordflow">if</span>( norm &lt;= threshold ) <span class="comment">/* norm too small, gradient no defined */</span>
00831           g-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>[adr] = <a class="code" href="lsd_8c.html#a4">NOTDEF</a>; <span class="comment">/* gradient angle not defined */</span>
00832         <span class="keywordflow">else</span>
00833           {
00834             <span class="comment">/* gradient angle computation */</span>
00835             g-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>[adr] = atan2(gx,-gy);
00836 
00837             <span class="comment">/* look for the maximum of the gradient */</span>
00838             <span class="keywordflow">if</span>( norm &gt; max_grad ) max_grad = norm;
00839           }
00840       }
00841 
00842   <span class="comment">/* compute histogram of gradient values */</span>
00843   <span class="keywordflow">for</span>(x=0;x&lt;p-1;x++)
00844     <span class="keywordflow">for</span>(y=0;y&lt;n-1;y++)
00845       {
00846         norm = (*modgrad)-&gt;data[y*p+x];
00847 
00848         <span class="comment">/* store the point in the right bin according to its norm */</span>
00849         i = (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>) (norm * (<span class="keywordtype">double</span>) n_bins / max_grad);
00850         <span class="keywordflow">if</span>( i &gt;= n_bins ) i = n_bins-1;
00851         <span class="keywordflow">if</span>( range_l_e[i] == NULL )
00852           range_l_s[i] = range_l_e[i] = list+list_count++;
00853         <span class="keywordflow">else</span>
00854           {
00855             range_l_e[i]-&gt;next = list+list_count;
00856             range_l_e[i] = list+list_count++;
00857           }
00858         range_l_e[i]-&gt;x = (<span class="keywordtype">int</span>) x;
00859         range_l_e[i]-&gt;y = (<span class="keywordtype">int</span>) y;
00860         range_l_e[i]-&gt;next = NULL;
00861       }
00862 
00863   <span class="comment">/* Make the list of pixels (almost) ordered by norm value.</span>
00864 <span class="comment">     It starts by the larger bin, so the list starts by the</span>
00865 <span class="comment">     pixels with the highest gradient value. Pixels would be ordered</span>
00866 <span class="comment">     by norm value, up to a precision given by max_grad/n_bins.</span>
00867 <span class="comment">   */</span>
00868   <span class="keywordflow">for</span>(i=n_bins-1; i&gt;0 &amp;&amp; range_l_s[i]==NULL; i--);
00869   start = range_l_s[i];
00870   end = range_l_e[i];
00871   <span class="keywordflow">if</span>( start != NULL )
00872     <span class="keywordflow">while</span>(i&gt;0)
00873       {
00874         --i;
00875         <span class="keywordflow">if</span>( range_l_s[i] != NULL )
00876           {
00877             end-&gt;next = range_l_s[i];
00878             end = range_l_e[i];
00879           }
00880       }
00881   *list_p = start;
00882 
00883   <span class="comment">/* free memory */</span>
00884   free( (<span class="keywordtype">void</span> *) range_l_s );
00885   free( (<span class="keywordtype">void</span> *) range_l_e );
00886 
00887   <span class="keywordflow">return</span> g;
00888 }
00889 
00890 <span class="comment">/*----------------------------------------------------------------------------*/</span><span class="comment"></span>
00891 <span class="comment">/** Is point (x,y) aligned to angle theta, up to precision 'prec'?</span>
00892 <span class="comment"> */</span>
<a name="l00893"></a><a class="code" href="lsd_8c.html#a34">00893</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="lsd_8c.html#a34">isaligned</a>( <span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y, <a class="code" href="structimage__double__s.html">image_double</a> angles, <span class="keywordtype">double</span> theta,
00894                       <span class="keywordtype">double</span> prec )
00895 {
00896   <span class="keywordtype">double</span> a;
00897 
00898   <span class="comment">/* check parameters */</span>
00899   <span class="keywordflow">if</span>( angles == NULL || angles-&gt;<a class="code" href="structimage__double__s.html#o0">data</a> == NULL )
00900     <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"isaligned: invalid image 'angles'."</span>);
00901   <span class="keywordflow">if</span>( x &lt; 0 || y &lt; 0 || x &gt;= (<span class="keywordtype">int</span>) angles-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a> || y &gt;= (<span class="keywordtype">int</span>) angles-&gt;<a class="code" href="structimage__double__s.html#o2">ysize</a> )
00902     <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"isaligned: (x,y) out of the image."</span>);
00903   <span class="keywordflow">if</span>( prec &lt; 0.0 ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"isaligned: 'prec' must be positive."</span>);
00904 
00905   <span class="comment">/* angle at pixel (x,y) */</span>
00906   a = angles-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>[ x + y * angles-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a> ];
00907 
00908   <span class="comment">/* pixels whose level-line angle is not defined</span>
00909 <span class="comment">     are considered as NON-aligned */</span>
00910   <span class="keywordflow">if</span>( a == <a class="code" href="lsd_8c.html#a4">NOTDEF</a> ) <span class="keywordflow">return</span> <a class="code" href="lsd_8c.html#a2">FALSE</a>;  <span class="comment">/* there is no need to call the function</span>
00911 <span class="comment">                                      'double_equal' here because there is</span>
00912 <span class="comment">                                      no risk of problems related to the</span>
00913 <span class="comment">                                      comparison doubles, we are only</span>
00914 <span class="comment">                                      interested in the exact NOTDEF value */</span>
00915 
00916   <span class="comment">/* it is assumed that 'theta' and 'a' are in the range [-pi,pi] */</span>
00917   theta -= a;
00918   <span class="keywordflow">if</span>( theta &lt; 0.0 ) theta = -theta;
00919   <span class="keywordflow">if</span>( theta &gt; <a class="code" href="lsd_8c.html#a5">M_3_2_PI</a> )
00920     {
00921       theta -= <a class="code" href="lsd_8c.html#a6">M_2__PI</a>;
00922       <span class="keywordflow">if</span>( theta &lt; 0.0 ) theta = -theta;
00923     }
00924 
00925   <span class="keywordflow">return</span> theta &lt;= prec;
00926 }
00927 
00928 <span class="comment">/*----------------------------------------------------------------------------*/</span><span class="comment"></span>
00929 <span class="comment">/** Absolute value angle difference.</span>
00930 <span class="comment"> */</span>
<a name="l00931"></a><a class="code" href="lsd_8c.html#a35">00931</a> <span class="keyword">static</span> <span class="keywordtype">double</span> <a class="code" href="lsd_8c.html#a35">angle_diff</a>(<span class="keywordtype">double</span> a, <span class="keywordtype">double</span> b)
00932 {
00933   a -= b;
00934   <span class="keywordflow">while</span>( a &lt;= -<a class="code" href="lsd_8c.html#a1">M_PI</a> ) a += <a class="code" href="lsd_8c.html#a6">M_2__PI</a>;
00935   <span class="keywordflow">while</span>( a &gt;   <a class="code" href="lsd_8c.html#a1">M_PI</a> ) a -= <a class="code" href="lsd_8c.html#a6">M_2__PI</a>;
00936   <span class="keywordflow">if</span>( a &lt; 0.0 ) a = -a;
00937   <span class="keywordflow">return</span> a;
00938 }
00939 
00940 <span class="comment">/*----------------------------------------------------------------------------*/</span><span class="comment"></span>
00941 <span class="comment">/** Signed angle difference.</span>
00942 <span class="comment"> */</span>
<a name="l00943"></a><a class="code" href="lsd_8c.html#a36">00943</a> <span class="keyword">static</span> <span class="keywordtype">double</span> <a class="code" href="lsd_8c.html#a36">angle_diff_signed</a>(<span class="keywordtype">double</span> a, <span class="keywordtype">double</span> b)
00944 {
00945   a -= b;
00946   <span class="keywordflow">while</span>( a &lt;= -<a class="code" href="lsd_8c.html#a1">M_PI</a> ) a += <a class="code" href="lsd_8c.html#a6">M_2__PI</a>;
00947   <span class="keywordflow">while</span>( a &gt;   <a class="code" href="lsd_8c.html#a1">M_PI</a> ) a -= <a class="code" href="lsd_8c.html#a6">M_2__PI</a>;
00948   <span class="keywordflow">return</span> a;
00949 }
00950 
00951 
00952 <span class="comment">/*----------------------------------------------------------------------------*/</span>
00953 <span class="comment">/*----------------------------- NFA computation ------------------------------*/</span>
00954 <span class="comment">/*----------------------------------------------------------------------------*/</span>
00955 
00956 <span class="comment">/*----------------------------------------------------------------------------*/</span><span class="comment"></span>
00957 <span class="comment">/** Computes the natural logarithm of the absolute value of</span>
00958 <span class="comment">    the gamma function of x using the Lanczos approximation.</span>
00959 <span class="comment">    See http://www.rskey.org/gamma.htm</span>
00960 <span class="comment"></span>
00961 <span class="comment">    The formula used is</span>
00962 <span class="comment">    @f[</span>
00963 <span class="comment">      \Gamma(x) = \frac{ \sum_{n=0}^{N} q_n x^n }{ \Pi_{n=0}^{N} (x+n) }</span>
00964 <span class="comment">                  (x+5.5)^{x+0.5} e^{-(x+5.5)}</span>
00965 <span class="comment">    @f]</span>
00966 <span class="comment">    so</span>
00967 <span class="comment">    @f[</span>
00968 <span class="comment">      \log\Gamma(x) = \log\left( \sum_{n=0}^{N} q_n x^n \right)</span>
00969 <span class="comment">                      + (x+0.5) \log(x+5.5) - (x+5.5) - \sum_{n=0}^{N} \log(x+n)</span>
00970 <span class="comment">    @f]</span>
00971 <span class="comment">    and</span>
00972 <span class="comment">      q0 = 75122.6331530,</span>
00973 <span class="comment">      q1 = 80916.6278952,</span>
00974 <span class="comment">      q2 = 36308.2951477,</span>
00975 <span class="comment">      q3 = 8687.24529705,</span>
00976 <span class="comment">      q4 = 1168.92649479,</span>
00977 <span class="comment">      q5 = 83.8676043424,</span>
00978 <span class="comment">      q6 = 2.50662827511.</span>
00979 <span class="comment"> */</span>
<a name="l00980"></a><a class="code" href="lsd_8c.html#a37">00980</a> <span class="keyword">static</span> <span class="keywordtype">double</span> <a class="code" href="lsd_8c.html#a37">log_gamma_lanczos</a>(<span class="keywordtype">double</span> x)
00981 {
00982   <span class="keyword">static</span> <span class="keywordtype">double</span> q[7] = { 75122.6331530, 80916.6278952, 36308.2951477,
00983                          8687.24529705, 1168.92649479, 83.8676043424,
00984                          2.50662827511 };
00985   <span class="keywordtype">double</span> a = (x+0.5) * log(x+5.5) - (x+5.5);
00986   <span class="keywordtype">double</span> b = 0.0;
00987   <span class="keywordtype">int</span> n;
00988 
00989   <span class="keywordflow">for</span>(n=0;n&lt;7;n++)
00990     {
00991       a -= log( x + (<span class="keywordtype">double</span>) n );
00992       b += q[n] * pow( x, (<span class="keywordtype">double</span>) n );
00993     }
00994   <span class="keywordflow">return</span> a + log(b);
00995 }
00996 
00997 <span class="comment">/*----------------------------------------------------------------------------*/</span><span class="comment"></span>
00998 <span class="comment">/** Computes the natural logarithm of the absolute value of</span>
00999 <span class="comment">    the gamma function of x using Windschitl method.</span>
01000 <span class="comment">    See http://www.rskey.org/gamma.htm</span>
01001 <span class="comment"></span>
01002 <span class="comment">    The formula used is</span>
01003 <span class="comment">    @f[</span>
01004 <span class="comment">        \Gamma(x) = \sqrt{\frac{2\pi}{x}} \left( \frac{x}{e}</span>
01005 <span class="comment">                    \sqrt{ x\sinh(1/x) + \frac{1}{810x^6} } \right)^x</span>
01006 <span class="comment">    @f]</span>
01007 <span class="comment">    so</span>
01008 <span class="comment">    @f[</span>
01009 <span class="comment">        \log\Gamma(x) = 0.5\log(2\pi) + (x-0.5)\log(x) - x</span>
01010 <span class="comment">                      + 0.5x\log\left( x\sinh(1/x) + \frac{1}{810x^6} \right).</span>
01011 <span class="comment">    @f]</span>
01012 <span class="comment">    This formula is a good approximation when x &gt; 15.</span>
01013 <span class="comment"> */</span>
<a name="l01014"></a><a class="code" href="lsd_8c.html#a38">01014</a> <span class="keyword">static</span> <span class="keywordtype">double</span> <a class="code" href="lsd_8c.html#a38">log_gamma_windschitl</a>(<span class="keywordtype">double</span> x)
01015 {
01016   <span class="keywordflow">return</span> 0.918938533204673 + (x-0.5)*log(x) - x
01017          + 0.5*x*log( x*sinh(1/x) + 1/(810.0*pow(x,6.0)) );
01018 }
01019 
01020 <span class="comment">/*----------------------------------------------------------------------------*/</span><span class="comment"></span>
01021 <span class="comment">/** Computes the natural logarithm of the absolute value of</span>
01022 <span class="comment">    the gamma function of x. When x&gt;15 use log_gamma_windschitl(),</span>
01023 <span class="comment">    otherwise use log_gamma_lanczos().</span>
01024 <span class="comment"> */</span>
<a name="l01025"></a><a class="code" href="lsd_8c.html#a10">01025</a> <span class="preprocessor">#define log_gamma(x) ((x)&gt;15.0?log_gamma_windschitl(x):log_gamma_lanczos(x))</span>
01026 <span class="preprocessor"></span>
01027 <span class="comment">/*----------------------------------------------------------------------------*/</span><span class="comment"></span>
01028 <span class="comment">/** Size of the table to store already computed inverse values.</span>
01029 <span class="comment"> */</span>
<a name="l01030"></a><a class="code" href="lsd_8c.html#a11">01030</a> <span class="preprocessor">#define TABSIZE 100000</span>
01031 <span class="preprocessor"></span>
01032 <span class="comment">/*----------------------------------------------------------------------------*/</span><span class="comment"></span>
01033 <span class="comment">/** Computes -log10(NFA).</span>
01034 <span class="comment"></span>
01035 <span class="comment">    NFA stands for Number of False Alarms:</span>
01036 <span class="comment">    @f[</span>
01037 <span class="comment">        \mathrm{NFA} = NT \cdot B(n,k,p)</span>
01038 <span class="comment">    @f]</span>
01039 <span class="comment"></span>
01040 <span class="comment">    - NT       - number of tests</span>
01041 <span class="comment">    - B(n,k,p) - tail of binomial distribution with parameters n,k and p:</span>
01042 <span class="comment">    @f[</span>
01043 <span class="comment">        B(n,k,p) = \sum_{j=k}^n</span>
01044 <span class="comment">                   \left(\begin{array}{c}n\\j\end{array}\right)</span>
01045 <span class="comment">                   p^{j} (1-p)^{n-j}</span>
01046 <span class="comment">    @f]</span>
01047 <span class="comment"></span>
01048 <span class="comment">    The value -log10(NFA) is equivalent but more intuitive than NFA:</span>
01049 <span class="comment">    - -1 corresponds to 10 mean false alarms</span>
01050 <span class="comment">    -  0 corresponds to 1 mean false alarm</span>
01051 <span class="comment">    -  1 corresponds to 0.1 mean false alarms</span>
01052 <span class="comment">    -  2 corresponds to 0.01 mean false alarms</span>
01053 <span class="comment">    -  ...</span>
01054 <span class="comment"></span>
01055 <span class="comment">    Used this way, the bigger the value, better the detection,</span>
01056 <span class="comment">    and a logarithmic scale is used.</span>
01057 <span class="comment"></span>
01058 <span class="comment">    @param n,k,p binomial parameters.</span>
01059 <span class="comment">    @param logNT logarithm of Number of Tests</span>
01060 <span class="comment"></span>
01061 <span class="comment">    The computation is based in the gamma function by the following</span>
01062 <span class="comment">    relation:</span>
01063 <span class="comment">    @f[</span>
01064 <span class="comment">        \left(\begin{array}{c}n\\k\end{array}\right)</span>
01065 <span class="comment">        = \frac{ \Gamma(n+1) }{ \Gamma(k+1) \cdot \Gamma(n-k+1) }.</span>
01066 <span class="comment">    @f]</span>
01067 <span class="comment">    We use efficient algorithms to compute the logarithm of</span>
01068 <span class="comment">    the gamma function.</span>
01069 <span class="comment"></span>
01070 <span class="comment">    To make the computation faster, not all the sum is computed, part</span>
01071 <span class="comment">    of the terms are neglected based on a bound to the error obtained</span>
01072 <span class="comment">    (an error of 10% in the result is accepted).</span>
01073 <span class="comment"> */</span>
<a name="l01074"></a><a class="code" href="lsd_8c.html#a39">01074</a> <span class="keyword">static</span> <span class="keywordtype">double</span> <a class="code" href="lsd_8c.html#a39">nfa</a>(<span class="keywordtype">int</span> n, <span class="keywordtype">int</span> k, <span class="keywordtype">double</span> p, <span class="keywordtype">double</span> logNT)
01075 {
01076   <span class="keyword">static</span> <span class="keywordtype">double</span> inv[<a class="code" href="lsd_8c.html#a11">TABSIZE</a>];   <span class="comment">/* table to keep computed inverse values */</span>
01077   <span class="keywordtype">double</span> tolerance = 0.1;       <span class="comment">/* an error of 10% in the result is accepted */</span>
01078   <span class="keywordtype">double</span> log1term,term,bin_term,mult_term,bin_tail,err,p_term;
01079   <span class="keywordtype">int</span> i;
01080 
01081   <span class="comment">/* check parameters */</span>
01082   <span class="keywordflow">if</span>( n&lt;0 || k&lt;0 || k&gt;n || p&lt;=0.0 || p&gt;=1.0 )
01083     <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"nfa: wrong n, k or p values."</span>);
01084 
01085   <span class="comment">/* trivial cases */</span>
01086   <span class="keywordflow">if</span>( n==0 || k==0 ) <span class="keywordflow">return</span> -logNT;
01087   <span class="keywordflow">if</span>( n==k ) <span class="keywordflow">return</span> -logNT - (<span class="keywordtype">double</span>) n * log10(p);
01088 
01089   <span class="comment">/* probability term */</span>
01090   p_term = p / (1.0-p);
01091 
01092   <span class="comment">/* compute the first term of the series */</span>
01093   <span class="comment">/*</span>
01094 <span class="comment">     binomial_tail(n,k,p) = sum_{i=k}^n bincoef(n,i) * p^i * (1-p)^{n-i}</span>
01095 <span class="comment">     where bincoef(n,i) are the binomial coefficients.</span>
01096 <span class="comment">     But</span>
01097 <span class="comment">       bincoef(n,k) = gamma(n+1) / ( gamma(k+1) * gamma(n-k+1) ).</span>
01098 <span class="comment">     We use this to compute the first term. Actually the log of it.</span>
01099 <span class="comment">   */</span>
01100   log1term = <a class="code" href="lsd_8c.html#a10">log_gamma</a>( (<span class="keywordtype">double</span>) n + 1.0 ) - <a class="code" href="lsd_8c.html#a10">log_gamma</a>( (<span class="keywordtype">double</span>) k + 1.0 )
01101            - <a class="code" href="lsd_8c.html#a10">log_gamma</a>( (<span class="keywordtype">double</span>) (n-k) + 1.0 )
01102            + (<span class="keywordtype">double</span>) k * log(p) + (<span class="keywordtype">double</span>) (n-k) * log(1.0-p);
01103   term = exp(log1term);
01104 
01105   <span class="comment">/* in some cases no more computations are needed */</span>
01106   <span class="keywordflow">if</span>( <a class="code" href="lsd_8c.html#a17">double_equal</a>(term,0.0) )              <span class="comment">/* the first term is almost zero */</span>
01107     {
01108       <span class="keywordflow">if</span>( (<span class="keywordtype">double</span>) k &gt; (<span class="keywordtype">double</span>) n * p )     <span class="comment">/* at begin or end of the tail?  */</span>
01109         <span class="keywordflow">return</span> -log1term / <a class="code" href="lsd_8c.html#a0">M_LN10</a> - logNT;  <span class="comment">/* end: use just the first term  */</span>
01110       <span class="keywordflow">else</span>
01111         <span class="keywordflow">return</span> -logNT;                      <span class="comment">/* begin: the tail is roughly 1  */</span>
01112     }
01113 
01114   <span class="comment">/* compute more terms if needed */</span>
01115   bin_tail = term;
01116   <span class="keywordflow">for</span>(i=k+1;i&lt;=n;i++)
01117     {
01118       <span class="comment">/*</span>
01119 <span class="comment">         As</span>
01120 <span class="comment">           term_i = bincoef(n,i) * p^i * (1-p)^(n-i)</span>
01121 <span class="comment">         and</span>
01122 <span class="comment">           bincoef(n,i)/bincoef(n,i-1) = n-1+1 / i,</span>
01123 <span class="comment">         then,</span>
01124 <span class="comment">           term_i / term_i-1 = (n-i+1)/i * p/(1-p)</span>
01125 <span class="comment">         and</span>
01126 <span class="comment">           term_i = term_i-1 * (n-i+1)/i * p/(1-p).</span>
01127 <span class="comment">         1/i is stored in a table as they are computed,</span>
01128 <span class="comment">         because divisions are expensive.</span>
01129 <span class="comment">         p/(1-p) is computed only once and stored in 'p_term'.</span>
01130 <span class="comment">       */</span>
01131       bin_term = (<span class="keywordtype">double</span>) (n-i+1) * ( i&lt;<a class="code" href="lsd_8c.html#a11">TABSIZE</a> ?
01132                    ( inv[i]!=0.0 ? inv[i] : ( inv[i] = 1.0 / (<span class="keywordtype">double</span>) i ) ) :
01133                    1.0 / (<span class="keywordtype">double</span>) i );
01134 
01135       mult_term = bin_term * p_term;
01136       term *= mult_term;
01137       bin_tail += term;
01138       <span class="keywordflow">if</span>(bin_term&lt;1.0)
01139         {
01140           <span class="comment">/* When bin_term&lt;1 then mult_term_j&lt;mult_term_i for j&gt;i.</span>
01141 <span class="comment">             Then, the error on the binomial tail when truncated at</span>
01142 <span class="comment">             the i term can be bounded by a geometric series of form</span>
01143 <span class="comment">             term_i * sum mult_term_i^j.                            */</span>
01144           err = term * ( ( 1.0 - pow( mult_term, (<span class="keywordtype">double</span>) (n-i+1) ) ) /
01145                          (1.0-mult_term) - 1.0 );
01146 
01147           <span class="comment">/* One wants an error at most of tolerance*final_result, or:</span>
01148 <span class="comment">             tolerance * abs(-log10(bin_tail)-logNT).</span>
01149 <span class="comment">             Now, the error that can be accepted on bin_tail is</span>
01150 <span class="comment">             given by tolerance*final_result divided by the derivative</span>
01151 <span class="comment">             of -log10(x) when x=bin_tail. that is:</span>
01152 <span class="comment">             tolerance * abs(-log10(bin_tail)-logNT) / (1/bin_tail)</span>
01153 <span class="comment">             Finally, we truncate the tail if the error is less than:</span>
01154 <span class="comment">             tolerance * abs(-log10(bin_tail)-logNT) * bin_tail        */</span>
01155           <span class="keywordflow">if</span>( err &lt; tolerance * fabs(-log10(bin_tail)-logNT) * bin_tail ) <span class="keywordflow">break</span>;
01156         }
01157     }
01158   <span class="keywordflow">return</span> -log10(bin_tail) - logNT;
01159 }
01160 
01161 
01162 <span class="comment">/*----------------------------------------------------------------------------*/</span>
01163 <span class="comment">/*--------------------------- Rectangle structure ----------------------------*/</span>
01164 <span class="comment">/*----------------------------------------------------------------------------*/</span>
01165 
01166 <span class="comment">/*----------------------------------------------------------------------------*/</span><span class="comment"></span>
01167 <span class="comment">/** Rectangle structure: line segment with width.</span>
01168 <span class="comment"> */</span>
<a name="l01169"></a><a class="code" href="structrect.html">01169</a> <span class="keyword">struct </span><a class="code" href="structrect.html">rect</a>
01170 {
<a name="l01171"></a><a class="code" href="structrect.html#o3">01171</a>   <span class="keywordtype">double</span> <a class="code" href="structrect.html#o0">x1</a>,<a class="code" href="structrect.html#o1">y1</a>,<a class="code" href="structrect.html#o2">x2</a>,<a class="code" href="structrect.html#o3">y2</a>;  <span class="comment">/* first and second point of the line segment */</span>
<a name="l01172"></a><a class="code" href="structrect.html#o4">01172</a>   <span class="keywordtype">double</span> <a class="code" href="structrect.html#o4">width</a>;        <span class="comment">/* rectangle width */</span>
<a name="l01173"></a><a class="code" href="structrect.html#o6">01173</a>   <span class="keywordtype">double</span> <a class="code" href="structrect.html#o5">x</a>,<a class="code" href="structrect.html#o6">y</a>;          <span class="comment">/* center of the rectangle */</span>
<a name="l01174"></a><a class="code" href="structrect.html#o7">01174</a>   <span class="keywordtype">double</span> <a class="code" href="structrect.html#o7">theta</a>;        <span class="comment">/* angle */</span>
<a name="l01175"></a><a class="code" href="structrect.html#o9">01175</a>   <span class="keywordtype">double</span> <a class="code" href="structrect.html#o8">dx</a>,<a class="code" href="structrect.html#o9">dy</a>;        <span class="comment">/* (dx,dy) is vector oriented as the line segment */</span>
<a name="l01176"></a><a class="code" href="structrect.html#o10">01176</a>   <span class="keywordtype">double</span> <a class="code" href="structrect.html#o10">prec</a>;         <span class="comment">/* tolerance angle */</span>
<a name="l01177"></a><a class="code" href="structrect.html#o11">01177</a>   <span class="keywordtype">double</span> <a class="code" href="structrect.html#o11">p</a>;            <span class="comment">/* probability of a point with angle within 'prec' */</span>
01178 };
01179 
01180 <span class="comment">/*----------------------------------------------------------------------------*/</span><span class="comment"></span>
01181 <span class="comment">/** Copy one rectangle structure to another.</span>
01182 <span class="comment"> */</span>
<a name="l01183"></a><a class="code" href="lsd_8c.html#a40">01183</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="lsd_8c.html#a40">rect_copy</a>(<span class="keyword">struct</span> <a class="code" href="structrect.html">rect</a> * in, <span class="keyword">struct</span> <a class="code" href="structrect.html">rect</a> * out)
01184 {
01185   <span class="comment">/* check parameters */</span>
01186   <span class="keywordflow">if</span>( in == NULL || out == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"rect_copy: invalid 'in' or 'out'."</span>);
01187 
01188   <span class="comment">/* copy values */</span>
01189   out-&gt;<a class="code" href="structrect.html#o0">x1</a> = in-&gt;<a class="code" href="structrect.html#o0">x1</a>;
01190   out-&gt;<a class="code" href="structrect.html#o1">y1</a> = in-&gt;<a class="code" href="structrect.html#o1">y1</a>;
01191   out-&gt;<a class="code" href="structrect.html#o2">x2</a> = in-&gt;<a class="code" href="structrect.html#o2">x2</a>;
01192   out-&gt;<a class="code" href="structrect.html#o3">y2</a> = in-&gt;<a class="code" href="structrect.html#o3">y2</a>;
01193   out-&gt;<a class="code" href="structrect.html#o4">width</a> = in-&gt;<a class="code" href="structrect.html#o4">width</a>;
01194   out-&gt;<a class="code" href="structrect.html#o5">x</a> = in-&gt;<a class="code" href="structrect.html#o5">x</a>;
01195   out-&gt;<a class="code" href="structrect.html#o6">y</a> = in-&gt;<a class="code" href="structrect.html#o6">y</a>;
01196   out-&gt;<a class="code" href="structrect.html#o7">theta</a> = in-&gt;<a class="code" href="structrect.html#o7">theta</a>;
01197   out-&gt;<a class="code" href="structrect.html#o8">dx</a> = in-&gt;<a class="code" href="structrect.html#o8">dx</a>;
01198   out-&gt;<a class="code" href="structrect.html#o9">dy</a> = in-&gt;<a class="code" href="structrect.html#o9">dy</a>;
01199   out-&gt;<a class="code" href="structrect.html#o10">prec</a> = in-&gt;<a class="code" href="structrect.html#o10">prec</a>;
01200   out-&gt;<a class="code" href="structrect.html#o11">p</a> = in-&gt;<a class="code" href="structrect.html#o11">p</a>;
01201 }
01202 
01203 <span class="comment">/*----------------------------------------------------------------------------*/</span><span class="comment"></span>
01204 <span class="comment">/** Rectangle points iterator.</span>
01205 <span class="comment"></span>
01206 <span class="comment">    The integer coordinates of pixels inside a rectangle are</span>
01207 <span class="comment">    iteratively explored. This structure keep track of the process and</span>
01208 <span class="comment">    functions ri_ini(), ri_inc(), ri_end(), and ri_del() are used in</span>
01209 <span class="comment">    the process. An example of how to use the iterator is as follows:</span>
01210 <span class="comment">    \code</span>
01211 <span class="comment"></span>
01212 <span class="comment">      struct rect * rec = XXX; // some rectangle</span>
01213 <span class="comment">      rect_iter * i;</span>
01214 <span class="comment">      for( i=ri_ini(rec); !ri_end(i); ri_inc(i) )</span>
01215 <span class="comment">        {</span>
01216 <span class="comment">          // your code, using 'i-&gt;x' and 'i-&gt;y' as coordinates</span>
01217 <span class="comment">        }</span>
01218 <span class="comment">      ri_del(i); // delete iterator</span>
01219 <span class="comment"></span>
01220 <span class="comment">    \endcode</span>
01221 <span class="comment">    The pixels are explored 'column' by 'column', where we call</span>
01222 <span class="comment">    'column' a set of pixels with the same x value that are inside the</span>
01223 <span class="comment">    rectangle. The following is an schematic representation of a</span>
01224 <span class="comment">    rectangle, the 'column' being explored is marked by colons, and</span>
01225 <span class="comment">    the current pixel being explored is 'x,y'.</span>
01226 <span class="comment">    \verbatim</span>
01227 <span class="comment"></span>
01228 <span class="comment">              vx[1],vy[1]</span>
01229 <span class="comment">                 *   *</span>
01230 <span class="comment">                *       *</span>
01231 <span class="comment">               *           *</span>
01232 <span class="comment">              *               ye</span>
01233 <span class="comment">             *                :  *</span>
01234 <span class="comment">        vx[0],vy[0]           :     *</span>
01235 <span class="comment">               *              :        *</span>
01236 <span class="comment">                  *          x,y          *</span>
01237 <span class="comment">                     *        :              *</span>
01238 <span class="comment">                        *     :            vx[2],vy[2]</span>
01239 <span class="comment">                           *  :                *</span>
01240 <span class="comment">        y                     ys              *</span>
01241 <span class="comment">        ^                        *           *</span>
01242 <span class="comment">        |                           *       *</span>
01243 <span class="comment">        |                              *   *</span>
01244 <span class="comment">        +---&gt; x                      vx[3],vy[3]</span>
01245 <span class="comment"></span>
01246 <span class="comment">    \endverbatim</span>
01247 <span class="comment">    The first 'column' to be explored is the one with the smaller x</span>
01248 <span class="comment">    value. Each 'column' is explored starting from the pixel of the</span>
01249 <span class="comment">    'column' (inside the rectangle) with the smallest y value.</span>
01250 <span class="comment"></span>
01251 <span class="comment">    The four corners of the rectangle are stored in order that rotates</span>
01252 <span class="comment">    around the corners at the arrays 'vx[]' and 'vy[]'. The first</span>
01253 <span class="comment">    point is always the one with smaller x value.</span>
01254 <span class="comment"></span>
01255 <span class="comment">    'x' and 'y' are the coordinates of the pixel being explored. 'ys'</span>
01256 <span class="comment">    and 'ye' are the start and end values of the current column being</span>
01257 <span class="comment">    explored. So, 'ys' &lt; 'ye'.</span>
01258 <span class="comment"> */</span>
<a name="l01259"></a><a class="code" href="structrect__iter.html">01259</a> <span class="keyword">typedef</span> <span class="keyword">struct</span>
01260 <span class="keyword"></span>{
<a name="l01261"></a><a class="code" href="structrect__iter.html#o0">01261</a>   <span class="keywordtype">double</span> vx[4];  <span class="comment">/* rectangle's corner X coordinates in circular order */</span>
<a name="l01262"></a><a class="code" href="structrect__iter.html#o1">01262</a>   <span class="keywordtype">double</span> vy[4];  <span class="comment">/* rectangle's corner Y coordinates in circular order */</span>
<a name="l01263"></a><a class="code" href="structrect__iter.html#o2">01263</a>   <span class="keywordtype">double</span> ys,ye;  <span class="comment">/* start and end Y values of current 'column' */</span>
<a name="l01264"></a><a class="code" href="structrect__iter.html#o5">01264</a>   <span class="keywordtype">int</span> x,y;       <span class="comment">/* coordinates of currently explored pixel */</span>
01265 } <a class="code" href="structrect__iter.html">rect_iter</a>;
01266 
01267 <span class="comment">/*----------------------------------------------------------------------------*/</span><span class="comment"></span>
01268 <span class="comment">/** Interpolate y value corresponding to 'x' value given, in</span>
01269 <span class="comment">    the line 'x1,y1' to 'x2,y2'; if 'x1=x2' return the smaller</span>
01270 <span class="comment">    of 'y1' and 'y2'.</span>
01271 <span class="comment"></span>
01272 <span class="comment">    The following restrictions are required:</span>
01273 <span class="comment">    - x1 &lt;= x2</span>
01274 <span class="comment">    - x1 &lt;= x</span>
01275 <span class="comment">    - x  &lt;= x2</span>
01276 <span class="comment"> */</span>
<a name="l01277"></a><a class="code" href="lsd_8c.html#a41">01277</a> <span class="keyword">static</span> <span class="keywordtype">double</span> <a class="code" href="lsd_8c.html#a41">inter_low</a>(<span class="keywordtype">double</span> x, <span class="keywordtype">double</span> x1, <span class="keywordtype">double</span> y1, <span class="keywordtype">double</span> x2, <span class="keywordtype">double</span> y2)
01278 {
01279   <span class="comment">/* check parameters */</span>
01280   <span class="keywordflow">if</span>( x1 &gt; x2 || x &lt; x1 || x &gt; x2 )
01281     <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"inter_low: unsuitable input, 'x1&gt;x2' or 'x&lt;x1' or 'x&gt;x2'."</span>);
01282 
01283   <span class="comment">/* interpolation */</span>
01284   <span class="keywordflow">if</span>( <a class="code" href="lsd_8c.html#a17">double_equal</a>(x1,x2) &amp;&amp; y1&lt;y2 ) <span class="keywordflow">return</span> y1;
01285   <span class="keywordflow">if</span>( <a class="code" href="lsd_8c.html#a17">double_equal</a>(x1,x2) &amp;&amp; y1&gt;y2 ) <span class="keywordflow">return</span> y2;
01286   <span class="keywordflow">return</span> y1 + (x-x1) * (y2-y1) / (x2-x1);
01287 }
01288 
01289 <span class="comment">/*----------------------------------------------------------------------------*/</span><span class="comment"></span>
01290 <span class="comment">/** Interpolate y value corresponding to 'x' value given, in</span>
01291 <span class="comment">    the line 'x1,y1' to 'x2,y2'; if 'x1=x2' return the larger</span>
01292 <span class="comment">    of 'y1' and 'y2'.</span>
01293 <span class="comment"></span>
01294 <span class="comment">    The following restrictions are required:</span>
01295 <span class="comment">    - x1 &lt;= x2</span>
01296 <span class="comment">    - x1 &lt;= x</span>
01297 <span class="comment">    - x  &lt;= x2</span>
01298 <span class="comment"> */</span>
<a name="l01299"></a><a class="code" href="lsd_8c.html#a42">01299</a> <span class="keyword">static</span> <span class="keywordtype">double</span> <a class="code" href="lsd_8c.html#a42">inter_hi</a>(<span class="keywordtype">double</span> x, <span class="keywordtype">double</span> x1, <span class="keywordtype">double</span> y1, <span class="keywordtype">double</span> x2, <span class="keywordtype">double</span> y2)
01300 {
01301   <span class="comment">/* check parameters */</span>
01302   <span class="keywordflow">if</span>( x1 &gt; x2 || x &lt; x1 || x &gt; x2 )
01303     <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"inter_hi: unsuitable input, 'x1&gt;x2' or 'x&lt;x1' or 'x&gt;x2'."</span>);
01304 
01305   <span class="comment">/* interpolation */</span>
01306   <span class="keywordflow">if</span>( <a class="code" href="lsd_8c.html#a17">double_equal</a>(x1,x2) &amp;&amp; y1&lt;y2 ) <span class="keywordflow">return</span> y2;
01307   <span class="keywordflow">if</span>( <a class="code" href="lsd_8c.html#a17">double_equal</a>(x1,x2) &amp;&amp; y1&gt;y2 ) <span class="keywordflow">return</span> y1;
01308   <span class="keywordflow">return</span> y1 + (x-x1) * (y2-y1) / (x2-x1);
01309 }
01310 
01311 <span class="comment">/*----------------------------------------------------------------------------*/</span><span class="comment"></span>
01312 <span class="comment">/** Free memory used by a rectangle iterator.</span>
01313 <span class="comment"> */</span>
<a name="l01314"></a><a class="code" href="lsd_8c.html#a43">01314</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="lsd_8c.html#a43">ri_del</a>(<a class="code" href="structrect__iter.html">rect_iter</a> * iter)
01315 {
01316   <span class="keywordflow">if</span>( iter == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"ri_del: NULL iterator."</span>);
01317   free( (<span class="keywordtype">void</span> *) iter );
01318 }
01319 
01320 <span class="comment">/*----------------------------------------------------------------------------*/</span><span class="comment"></span>
01321 <span class="comment">/** Check if the iterator finished the full iteration.</span>
01322 <span class="comment"></span>
01323 <span class="comment">    See details in \ref rect_iter</span>
01324 <span class="comment"> */</span>
<a name="l01325"></a><a class="code" href="lsd_8c.html#a44">01325</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="lsd_8c.html#a44">ri_end</a>(<a class="code" href="structrect__iter.html">rect_iter</a> * i)
01326 {
01327   <span class="comment">/* check input */</span>
01328   <span class="keywordflow">if</span>( i == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"ri_end: NULL iterator."</span>);
01329 
01330   <span class="comment">/* if the current x value is larger than the largest</span>
01331 <span class="comment">     x value in the rectangle (vx[2]), we know the full</span>
01332 <span class="comment">     exploration of the rectangle is finished. */</span>
01333   <span class="keywordflow">return</span> (<span class="keywordtype">double</span>)(i-&gt;<a class="code" href="structrect__iter.html#o4">x</a>) &gt; i-&gt;<a class="code" href="structrect__iter.html#o0">vx</a>[2];
01334 }
01335 
01336 <span class="comment">/*----------------------------------------------------------------------------*/</span><span class="comment"></span>
01337 <span class="comment">/** Increment a rectangle iterator.</span>
01338 <span class="comment"></span>
01339 <span class="comment">    See details in \ref rect_iter</span>
01340 <span class="comment"> */</span>
<a name="l01341"></a><a class="code" href="lsd_8c.html#a45">01341</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="lsd_8c.html#a45">ri_inc</a>(<a class="code" href="structrect__iter.html">rect_iter</a> * i)
01342 {
01343   <span class="comment">/* check input */</span>
01344   <span class="keywordflow">if</span>( i == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"ri_inc: NULL iterator."</span>);
01345 
01346   <span class="comment">/* if not at end of exploration,</span>
01347 <span class="comment">     increase y value for next pixel in the 'column' */</span>
01348   <span class="keywordflow">if</span>( !<a class="code" href="lsd_8c.html#a44">ri_end</a>(i) ) i-&gt;<a class="code" href="structrect__iter.html#o5">y</a>++;
01349 
01350   <span class="comment">/* if the end of the current 'column' is reached,</span>
01351 <span class="comment">     and it is not the end of exploration,</span>
01352 <span class="comment">     advance to the next 'column' */</span>
01353   <span class="keywordflow">while</span>( (<span class="keywordtype">double</span>) (i-&gt;<a class="code" href="structrect__iter.html#o5">y</a>) &gt; i-&gt;<a class="code" href="structrect__iter.html#o3">ye</a> &amp;&amp; !<a class="code" href="lsd_8c.html#a44">ri_end</a>(i) )
01354     {
01355       <span class="comment">/* increase x, next 'column' */</span>
01356       i-&gt;<a class="code" href="structrect__iter.html#o4">x</a>++;
01357 
01358       <span class="comment">/* if end of exploration, return */</span>
01359       <span class="keywordflow">if</span>( <a class="code" href="lsd_8c.html#a44">ri_end</a>(i) ) <span class="keywordflow">return</span>;
01360 
01361       <span class="comment">/* update lower y limit (start) for the new 'column'.</span>
01362 <span class="comment"></span>
01363 <span class="comment">         We need to interpolate the y value that corresponds to the</span>
01364 <span class="comment">         lower side of the rectangle. The first thing is to decide if</span>
01365 <span class="comment">         the corresponding side is</span>
01366 <span class="comment"></span>
01367 <span class="comment">           vx[0],vy[0] to vx[3],vy[3] or</span>
01368 <span class="comment">           vx[3],vy[3] to vx[2],vy[2]</span>
01369 <span class="comment"></span>
01370 <span class="comment">         Then, the side is interpolated for the x value of the</span>
01371 <span class="comment">         'column'. But, if the side is vertical (as it could happen if</span>
01372 <span class="comment">         the rectangle is vertical and we are dealing with the first</span>
01373 <span class="comment">         or last 'columns') then we pick the lower value of the side</span>
01374 <span class="comment">         by using 'inter_low'.</span>
01375 <span class="comment">       */</span>
01376       <span class="keywordflow">if</span>( (<span class="keywordtype">double</span>) i-&gt;<a class="code" href="structrect__iter.html#o4">x</a> &lt; i-&gt;<a class="code" href="structrect__iter.html#o0">vx</a>[3] )
01377         i-&gt;<a class="code" href="structrect__iter.html#o2">ys</a> = <a class="code" href="lsd_8c.html#a41">inter_low</a>((<span class="keywordtype">double</span>)i-&gt;<a class="code" href="structrect__iter.html#o4">x</a>,i-&gt;<a class="code" href="structrect__iter.html#o0">vx</a>[0],i-&gt;<a class="code" href="structrect__iter.html#o1">vy</a>[0],i-&gt;<a class="code" href="structrect__iter.html#o0">vx</a>[3],i-&gt;<a class="code" href="structrect__iter.html#o1">vy</a>[3]);
01378       <span class="keywordflow">else</span>
01379         i-&gt;<a class="code" href="structrect__iter.html#o2">ys</a> = <a class="code" href="lsd_8c.html#a41">inter_low</a>((<span class="keywordtype">double</span>)i-&gt;<a class="code" href="structrect__iter.html#o4">x</a>,i-&gt;<a class="code" href="structrect__iter.html#o0">vx</a>[3],i-&gt;<a class="code" href="structrect__iter.html#o1">vy</a>[3],i-&gt;<a class="code" href="structrect__iter.html#o0">vx</a>[2],i-&gt;<a class="code" href="structrect__iter.html#o1">vy</a>[2]);
01380 
01381       <span class="comment">/* update upper y limit (end) for the new 'column'.</span>
01382 <span class="comment"></span>
01383 <span class="comment">         We need to interpolate the y value that corresponds to the</span>
01384 <span class="comment">         upper side of the rectangle. The first thing is to decide if</span>
01385 <span class="comment">         the corresponding side is</span>
01386 <span class="comment"></span>
01387 <span class="comment">           vx[0],vy[0] to vx[1],vy[1] or</span>
01388 <span class="comment">           vx[1],vy[1] to vx[2],vy[2]</span>
01389 <span class="comment"></span>
01390 <span class="comment">         Then, the side is interpolated for the x value of the</span>
01391 <span class="comment">         'column'. But, if the side is vertical (as it could happen if</span>
01392 <span class="comment">         the rectangle is vertical and we are dealing with the first</span>
01393 <span class="comment">         or last 'columns') then we pick the lower value of the side</span>
01394 <span class="comment">         by using 'inter_low'.</span>
01395 <span class="comment">       */</span>
01396       <span class="keywordflow">if</span>( (<span class="keywordtype">double</span>)i-&gt;<a class="code" href="structrect__iter.html#o4">x</a> &lt; i-&gt;<a class="code" href="structrect__iter.html#o0">vx</a>[1] )
01397         i-&gt;<a class="code" href="structrect__iter.html#o3">ye</a> = <a class="code" href="lsd_8c.html#a42">inter_hi</a>((<span class="keywordtype">double</span>)i-&gt;<a class="code" href="structrect__iter.html#o4">x</a>,i-&gt;<a class="code" href="structrect__iter.html#o0">vx</a>[0],i-&gt;<a class="code" href="structrect__iter.html#o1">vy</a>[0],i-&gt;<a class="code" href="structrect__iter.html#o0">vx</a>[1],i-&gt;<a class="code" href="structrect__iter.html#o1">vy</a>[1]);
01398       <span class="keywordflow">else</span>
01399         i-&gt;<a class="code" href="structrect__iter.html#o3">ye</a> = <a class="code" href="lsd_8c.html#a42">inter_hi</a>((<span class="keywordtype">double</span>)i-&gt;<a class="code" href="structrect__iter.html#o4">x</a>,i-&gt;<a class="code" href="structrect__iter.html#o0">vx</a>[1],i-&gt;<a class="code" href="structrect__iter.html#o1">vy</a>[1],i-&gt;<a class="code" href="structrect__iter.html#o0">vx</a>[2],i-&gt;<a class="code" href="structrect__iter.html#o1">vy</a>[2]);
01400 
01401       <span class="comment">/* new y */</span>
01402       i-&gt;<a class="code" href="structrect__iter.html#o5">y</a> = (<span class="keywordtype">int</span>) ceil(i-&gt;<a class="code" href="structrect__iter.html#o2">ys</a>);
01403     }
01404 }
01405 
01406 <span class="comment">/*----------------------------------------------------------------------------*/</span><span class="comment"></span>
01407 <span class="comment">/** Create and initialize a rectangle iterator.</span>
01408 <span class="comment"></span>
01409 <span class="comment">    See details in \ref rect_iter</span>
01410 <span class="comment"> */</span>
<a name="l01411"></a><a class="code" href="lsd_8c.html#a46">01411</a> <span class="keyword">static</span> <a class="code" href="structrect__iter.html">rect_iter</a> * <a class="code" href="lsd_8c.html#a46">ri_ini</a>(<span class="keyword">struct</span> <a class="code" href="structrect.html">rect</a> * r)
01412 {
01413   <span class="keywordtype">double</span> vx[4],vy[4];
01414   <span class="keywordtype">int</span> n,offset;
01415   <a class="code" href="structrect__iter.html">rect_iter</a> * i;
01416 
01417   <span class="comment">/* check parameters */</span>
01418   <span class="keywordflow">if</span>( r == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"ri_ini: invalid rectangle."</span>);
01419 
01420   <span class="comment">/* get memory */</span>
01421   i = (<a class="code" href="structrect__iter.html">rect_iter</a> *) malloc(<span class="keyword">sizeof</span>(<a class="code" href="structrect__iter.html">rect_iter</a>));
01422   <span class="keywordflow">if</span>( i == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"ri_ini: Not enough memory."</span>);
01423 
01424   <span class="comment">/* build list of rectangle corners ordered</span>
01425 <span class="comment">     in a circular way around the rectangle */</span>
01426   vx[0] = r-&gt;<a class="code" href="structrect.html#o0">x1</a> - r-&gt;<a class="code" href="structrect.html#o9">dy</a> * r-&gt;<a class="code" href="structrect.html#o4">width</a> / 2.0;
01427   vy[0] = r-&gt;<a class="code" href="structrect.html#o1">y1</a> + r-&gt;<a class="code" href="structrect.html#o8">dx</a> * r-&gt;<a class="code" href="structrect.html#o4">width</a> / 2.0;
01428   vx[1] = r-&gt;<a class="code" href="structrect.html#o2">x2</a> - r-&gt;<a class="code" href="structrect.html#o9">dy</a> * r-&gt;<a class="code" href="structrect.html#o4">width</a> / 2.0;
01429   vy[1] = r-&gt;<a class="code" href="structrect.html#o3">y2</a> + r-&gt;<a class="code" href="structrect.html#o8">dx</a> * r-&gt;<a class="code" href="structrect.html#o4">width</a> / 2.0;
01430   vx[2] = r-&gt;<a class="code" href="structrect.html#o2">x2</a> + r-&gt;<a class="code" href="structrect.html#o9">dy</a> * r-&gt;<a class="code" href="structrect.html#o4">width</a> / 2.0;
01431   vy[2] = r-&gt;<a class="code" href="structrect.html#o3">y2</a> - r-&gt;<a class="code" href="structrect.html#o8">dx</a> * r-&gt;<a class="code" href="structrect.html#o4">width</a> / 2.0;
01432   vx[3] = r-&gt;<a class="code" href="structrect.html#o0">x1</a> + r-&gt;<a class="code" href="structrect.html#o9">dy</a> * r-&gt;<a class="code" href="structrect.html#o4">width</a> / 2.0;
01433   vy[3] = r-&gt;<a class="code" href="structrect.html#o1">y1</a> - r-&gt;<a class="code" href="structrect.html#o8">dx</a> * r-&gt;<a class="code" href="structrect.html#o4">width</a> / 2.0;
01434 
01435   <span class="comment">/* compute rotation of index of corners needed so that the first</span>
01436 <span class="comment">     point has the smaller x.</span>
01437 <span class="comment"></span>
01438 <span class="comment">     if one side is vertical, thus two corners have the same smaller x</span>
01439 <span class="comment">     value, the one with the largest y value is selected as the first.</span>
01440 <span class="comment">   */</span>
01441   <span class="keywordflow">if</span>( r-&gt;<a class="code" href="structrect.html#o0">x1</a> &lt; r-&gt;<a class="code" href="structrect.html#o2">x2</a> &amp;&amp; r-&gt;<a class="code" href="structrect.html#o1">y1</a> &lt;= r-&gt;<a class="code" href="structrect.html#o3">y2</a> ) offset = 0;
01442   <span class="keywordflow">else</span> <span class="keywordflow">if</span>( r-&gt;<a class="code" href="structrect.html#o0">x1</a> &gt;= r-&gt;<a class="code" href="structrect.html#o2">x2</a> &amp;&amp; r-&gt;<a class="code" href="structrect.html#o1">y1</a> &lt; r-&gt;<a class="code" href="structrect.html#o3">y2</a> ) offset = 1;
01443   <span class="keywordflow">else</span> <span class="keywordflow">if</span>( r-&gt;<a class="code" href="structrect.html#o0">x1</a> &gt; r-&gt;<a class="code" href="structrect.html#o2">x2</a> &amp;&amp; r-&gt;<a class="code" href="structrect.html#o1">y1</a> &gt;= r-&gt;<a class="code" href="structrect.html#o3">y2</a> ) offset = 2;
01444   <span class="keywordflow">else</span> offset = 3;
01445 
01446   <span class="comment">/* apply rotation of index. */</span>
01447   <span class="keywordflow">for</span>(n=0; n&lt;4; n++)
01448     {
01449       i-&gt;<a class="code" href="structrect__iter.html#o0">vx</a>[n] = vx[(offset+n)%4];
01450       i-&gt;<a class="code" href="structrect__iter.html#o1">vy</a>[n] = vy[(offset+n)%4];
01451     }
01452 
01453   <span class="comment">/* Set an initial condition.</span>
01454 <span class="comment"></span>
01455 <span class="comment">     The values are set to values that will cause 'ri_inc' (that will</span>
01456 <span class="comment">     be called immediately) to initialize correctly the first 'column'</span>
01457 <span class="comment">     and compute the limits 'ys' and 'ye'.</span>
01458 <span class="comment"></span>
01459 <span class="comment">     'y' is set to the integer value of vy[0], the starting corner.</span>
01460 <span class="comment"></span>
01461 <span class="comment">     'ys' and 'ye' are set to very small values, so 'ri_inc' will</span>
01462 <span class="comment">     notice that it needs to start a new 'column'.</span>
01463 <span class="comment"></span>
01464 <span class="comment">     The smallest integer coordinate inside of the rectangle is</span>
01465 <span class="comment">     'ceil(vx[0])'. The current 'x' value is set to that value minus</span>
01466 <span class="comment">     one, so 'ri_inc' (that will increase x by one) will advance to</span>
01467 <span class="comment">     the first 'column'.</span>
01468 <span class="comment">   */</span>
01469   i-&gt;<a class="code" href="structrect__iter.html#o4">x</a> = (<span class="keywordtype">int</span>) ceil(i-&gt;<a class="code" href="structrect__iter.html#o0">vx</a>[0]) - 1;
01470   i-&gt;<a class="code" href="structrect__iter.html#o5">y</a> = (<span class="keywordtype">int</span>) ceil(i-&gt;<a class="code" href="structrect__iter.html#o1">vy</a>[0]);
01471   i-&gt;<a class="code" href="structrect__iter.html#o2">ys</a> = i-&gt;<a class="code" href="structrect__iter.html#o3">ye</a> = -DBL_MAX;
01472 
01473   <span class="comment">/* advance to the first pixel */</span>
01474   <a class="code" href="lsd_8c.html#a45">ri_inc</a>(i);
01475 
01476   <span class="keywordflow">return</span> i;
01477 }
01478 
01479 <span class="comment">/*----------------------------------------------------------------------------*/</span><span class="comment"></span>
01480 <span class="comment">/** Compute a rectangle's NFA value.</span>
01481 <span class="comment"> */</span>
<a name="l01482"></a><a class="code" href="lsd_8c.html#a47">01482</a> <span class="keyword">static</span> <span class="keywordtype">double</span> <a class="code" href="lsd_8c.html#a47">rect_nfa</a>(<span class="keyword">struct</span> <a class="code" href="structrect.html">rect</a> * rec, <a class="code" href="structimage__double__s.html">image_double</a> angles, <span class="keywordtype">double</span> logNT)
01483 {
01484   <a class="code" href="structrect__iter.html">rect_iter</a> * i;
01485   <span class="keywordtype">int</span> pts = 0;
01486   <span class="keywordtype">int</span> alg = 0;
01487 
01488   <span class="comment">/* check parameters */</span>
01489   <span class="keywordflow">if</span>( rec == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"rect_nfa: invalid rectangle."</span>);
01490   <span class="keywordflow">if</span>( angles == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"rect_nfa: invalid 'angles'."</span>);
01491 
01492   <span class="comment">/* compute the total number of pixels and of aligned points in 'rec' */</span>
01493   <span class="keywordflow">for</span>(i=<a class="code" href="lsd_8c.html#a46">ri_ini</a>(rec); !<a class="code" href="lsd_8c.html#a44">ri_end</a>(i); <a class="code" href="lsd_8c.html#a45">ri_inc</a>(i)) <span class="comment">/* rectangle iterator */</span>
01494     <span class="keywordflow">if</span>( i-&gt;<a class="code" href="structrect__iter.html#o4">x</a> &gt;= 0 &amp;&amp; i-&gt;<a class="code" href="structrect__iter.html#o5">y</a> &gt;= 0 &amp;&amp;
01495         i-&gt;<a class="code" href="structrect__iter.html#o4">x</a> &lt; (<span class="keywordtype">int</span>) angles-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a> &amp;&amp; i-&gt;<a class="code" href="structrect__iter.html#o5">y</a> &lt; (<span class="keywordtype">int</span>) angles-&gt;<a class="code" href="structimage__double__s.html#o2">ysize</a> )
01496       {
01497         ++pts; <span class="comment">/* total number of pixels counter */</span>
01498         <span class="keywordflow">if</span>( <a class="code" href="lsd_8c.html#a34">isaligned</a>(i-&gt;<a class="code" href="structrect__iter.html#o4">x</a>, i-&gt;<a class="code" href="structrect__iter.html#o5">y</a>, angles, rec-&gt;<a class="code" href="structrect.html#o7">theta</a>, rec-&gt;<a class="code" href="structrect.html#o10">prec</a>) )
01499           ++alg; <span class="comment">/* aligned points counter */</span>
01500       }
01501   <a class="code" href="lsd_8c.html#a43">ri_del</a>(i); <span class="comment">/* delete iterator */</span>
01502 
01503   <span class="keywordflow">return</span> <a class="code" href="lsd_8c.html#a39">nfa</a>(pts,alg,rec-&gt;<a class="code" href="structrect.html#o11">p</a>,logNT); <span class="comment">/* compute NFA value */</span>
01504 }
01505 
01506 
01507 <span class="comment">/*----------------------------------------------------------------------------*/</span>
01508 <span class="comment">/*---------------------------------- Regions ---------------------------------*/</span>
01509 <span class="comment">/*----------------------------------------------------------------------------*/</span>
01510 
01511 <span class="comment">/*----------------------------------------------------------------------------*/</span><span class="comment"></span>
01512 <span class="comment">/** Compute region's angle as the principal inertia axis of the region.</span>
01513 <span class="comment"></span>
01514 <span class="comment">    The following is the region inertia matrix A:</span>
01515 <span class="comment">    @f[</span>
01516 <span class="comment"></span>
01517 <span class="comment">        A = \left(\begin{array}{cc}</span>
01518 <span class="comment">                                    Ixx &amp; Ixy \\</span>
01519 <span class="comment">                                    Ixy &amp; Iyy \\</span>
01520 <span class="comment">             \end{array}\right)</span>
01521 <span class="comment"></span>
01522 <span class="comment">    @f]</span>
01523 <span class="comment">    where</span>
01524 <span class="comment"></span>
01525 <span class="comment">      Ixx =   sum_i G(i).(y_i - cx)^2</span>
01526 <span class="comment"></span>
01527 <span class="comment">      Iyy =   sum_i G(i).(x_i - cy)^2</span>
01528 <span class="comment"></span>
01529 <span class="comment">      Ixy = - sum_i G(i).(x_i - cx).(y_i - cy)</span>
01530 <span class="comment"></span>
01531 <span class="comment">    and</span>
01532 <span class="comment">    - G(i) is the gradient norm at pixel i, used as pixel's weight.</span>
01533 <span class="comment">    - x_i and y_i are the coordinates of pixel i.</span>
01534 <span class="comment">    - cx and cy are the coordinates of the center of th region.</span>
01535 <span class="comment"></span>
01536 <span class="comment">    lambda1 and lambda2 are the eigenvalues of matrix A,</span>
01537 <span class="comment">    with lambda1 &gt;= lambda2. They are found by solving the</span>
01538 <span class="comment">    characteristic polynomial:</span>
01539 <span class="comment"></span>
01540 <span class="comment">      det( lambda I - A) = 0</span>
01541 <span class="comment"></span>
01542 <span class="comment">    that gives:</span>
01543 <span class="comment"></span>
01544 <span class="comment">      lambda1 = ( Ixx + Iyy + sqrt( (Ixx-Iyy)^2 + 4.0*Ixy*Ixy) ) / 2</span>
01545 <span class="comment"></span>
01546 <span class="comment">      lambda2 = ( Ixx + Iyy - sqrt( (Ixx-Iyy)^2 + 4.0*Ixy*Ixy) ) / 2</span>
01547 <span class="comment"></span>
01548 <span class="comment">    To get the line segment direction we want to get the angle the</span>
01549 <span class="comment">    eigenvector associated to the smallest eigenvalue. We have</span>
01550 <span class="comment">    to solve for a,b in:</span>
01551 <span class="comment"></span>
01552 <span class="comment">      a.Ixx + b.Ixy = a.lambda2</span>
01553 <span class="comment"></span>
01554 <span class="comment">      a.Ixy + b.Iyy = b.lambda2</span>
01555 <span class="comment"></span>
01556 <span class="comment">    We want the angle theta = atan(b/a). It can be computed with</span>
01557 <span class="comment">    any of the two equations:</span>
01558 <span class="comment"></span>
01559 <span class="comment">      theta = atan( (lambda2-Ixx) / Ixy )</span>
01560 <span class="comment"></span>
01561 <span class="comment">    or</span>
01562 <span class="comment"></span>
01563 <span class="comment">      theta = atan( Ixy / (lambda2-Iyy) )</span>
01564 <span class="comment"></span>
01565 <span class="comment">    When |Ixx| &gt; |Iyy| we use the first, otherwise the second (just to</span>
01566 <span class="comment">    get better numeric precision).</span>
01567 <span class="comment"> */</span>
<a name="l01568"></a><a class="code" href="lsd_8c.html#a48">01568</a> <span class="keyword">static</span> <span class="keywordtype">double</span> <a class="code" href="lsd_8c.html#a48">get_theta</a>( <span class="keyword">struct</span> <a class="code" href="structpoint.html">point</a> * reg, <span class="keywordtype">int</span> reg_size, <span class="keywordtype">double</span> x, <span class="keywordtype">double</span> y,
01569                          <a class="code" href="structimage__double__s.html">image_double</a> modgrad, <span class="keywordtype">double</span> reg_angle, <span class="keywordtype">double</span> prec )
01570 {
01571   <span class="keywordtype">double</span> lambda,theta,weight;
01572   <span class="keywordtype">double</span> Ixx = 0.0;
01573   <span class="keywordtype">double</span> Iyy = 0.0;
01574   <span class="keywordtype">double</span> Ixy = 0.0;
01575   <span class="keywordtype">int</span> i;
01576 
01577   <span class="comment">/* check parameters */</span>
01578   <span class="keywordflow">if</span>( reg == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"get_theta: invalid region."</span>);
01579   <span class="keywordflow">if</span>( reg_size &lt;= 1 ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"get_theta: region size &lt;= 1."</span>);
01580   <span class="keywordflow">if</span>( modgrad == NULL || modgrad-&gt;<a class="code" href="structimage__double__s.html#o0">data</a> == NULL )
01581     <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"get_theta: invalid 'modgrad'."</span>);
01582   <span class="keywordflow">if</span>( prec &lt; 0.0 ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"get_theta: 'prec' must be positive."</span>);
01583 
01584   <span class="comment">/* compute inertia matrix */</span>
01585   <span class="keywordflow">for</span>(i=0; i&lt;reg_size; i++)
01586     {
01587       weight = modgrad-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>[ reg[i].<a class="code" href="structpoint.html#o0">x</a> + reg[i].<a class="code" href="structpoint.html#o1">y</a> * modgrad-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a> ];
01588       Ixx += ( (<span class="keywordtype">double</span>) reg[i].<a class="code" href="structpoint.html#o1">y</a> - y ) * ( (<span class="keywordtype">double</span>) reg[i].<a class="code" href="structpoint.html#o1">y</a> - y ) * weight;
01589       Iyy += ( (<span class="keywordtype">double</span>) reg[i].<a class="code" href="structpoint.html#o0">x</a> - x ) * ( (<span class="keywordtype">double</span>) reg[i].<a class="code" href="structpoint.html#o0">x</a> - x ) * weight;
01590       Ixy -= ( (<span class="keywordtype">double</span>) reg[i].<a class="code" href="structpoint.html#o0">x</a> - x ) * ( (<span class="keywordtype">double</span>) reg[i].<a class="code" href="structpoint.html#o1">y</a> - y ) * weight;
01591     }
01592   <span class="keywordflow">if</span>( <a class="code" href="lsd_8c.html#a17">double_equal</a>(Ixx,0.0) &amp;&amp; <a class="code" href="lsd_8c.html#a17">double_equal</a>(Iyy,0.0) &amp;&amp; <a class="code" href="lsd_8c.html#a17">double_equal</a>(Ixy,0.0) )
01593     <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"get_theta: null inertia matrix."</span>);
01594 
01595   <span class="comment">/* compute smallest eigenvalue */</span>
01596   lambda = 0.5 * ( Ixx + Iyy - sqrt( (Ixx-Iyy)*(Ixx-Iyy) + 4.0*Ixy*Ixy ) );
01597 
01598   <span class="comment">/* compute angle */</span>
01599   theta = fabs(Ixx)&gt;fabs(Iyy) ? atan2(lambda-Ixx,Ixy) : atan2(Ixy,lambda-Iyy);
01600 
01601   <span class="comment">/* The previous procedure doesn't cares about orientation,</span>
01602 <span class="comment">     so it could be wrong by 180 degrees. Here is corrected if necessary. */</span>
01603   <span class="keywordflow">if</span>( <a class="code" href="lsd_8c.html#a35">angle_diff</a>(theta,reg_angle) &gt; prec ) theta += <a class="code" href="lsd_8c.html#a1">M_PI</a>;
01604 
01605   <span class="keywordflow">return</span> theta;
01606 }
01607 
01608 <span class="comment">/*----------------------------------------------------------------------------*/</span><span class="comment"></span>
01609 <span class="comment">/** Computes a rectangle that covers a region of points.</span>
01610 <span class="comment"> */</span>
<a name="l01611"></a><a class="code" href="lsd_8c.html#a49">01611</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="lsd_8c.html#a49">region2rect</a>( <span class="keyword">struct</span> <a class="code" href="structpoint.html">point</a> * reg, <span class="keywordtype">int</span> reg_size,
01612                          <a class="code" href="structimage__double__s.html">image_double</a> modgrad, <span class="keywordtype">double</span> reg_angle,
01613                          <span class="keywordtype">double</span> prec, <span class="keywordtype">double</span> p, <span class="keyword">struct</span> <a class="code" href="structrect.html">rect</a> * rec )
01614 {
01615   <span class="keywordtype">double</span> x,y,dx,dy,l,w,theta,weight,sum,l_min,l_max,w_min,w_max;
01616   <span class="keywordtype">int</span> i;
01617 
01618   <span class="comment">/* check parameters */</span>
01619   <span class="keywordflow">if</span>( reg == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"region2rect: invalid region."</span>);
01620   <span class="keywordflow">if</span>( reg_size &lt;= 1 ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"region2rect: region size &lt;= 1."</span>);
01621   <span class="keywordflow">if</span>( modgrad == NULL || modgrad-&gt;<a class="code" href="structimage__double__s.html#o0">data</a> == NULL )
01622     <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"region2rect: invalid image 'modgrad'."</span>);
01623   <span class="keywordflow">if</span>( rec == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"region2rect: invalid 'rec'."</span>);
01624 
01625   <span class="comment">/* center of the region:</span>
01626 <span class="comment"></span>
01627 <span class="comment">     It is computed as the weighted sum of the coordinates</span>
01628 <span class="comment">     of all the pixels in the region. The norm of the gradient</span>
01629 <span class="comment">     is used as the weight of a pixel. The sum is as follows:</span>
01630 <span class="comment">       cx = \sum_i G(i).x_i</span>
01631 <span class="comment">       cy = \sum_i G(i).y_i</span>
01632 <span class="comment">     where G(i) is the norm of the gradient of pixel i</span>
01633 <span class="comment">     and x_i,y_i are its coordinates.</span>
01634 <span class="comment">   */</span>
01635   x = y = sum = 0.0;
01636   <span class="keywordflow">for</span>(i=0; i&lt;reg_size; i++)
01637     {
01638       weight = modgrad-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>[ reg[i].<a class="code" href="structpoint.html#o0">x</a> + reg[i].<a class="code" href="structpoint.html#o1">y</a> * modgrad-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a> ];
01639       x += (<span class="keywordtype">double</span>) reg[i].<a class="code" href="structpoint.html#o0">x</a> * weight;
01640       y += (<span class="keywordtype">double</span>) reg[i].<a class="code" href="structpoint.html#o1">y</a> * weight;
01641       sum += weight;
01642     }
01643   <span class="keywordflow">if</span>( sum &lt;= 0.0 ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"region2rect: weights sum equal to zero."</span>);
01644   x /= sum;
01645   y /= sum;
01646 
01647   <span class="comment">/* theta */</span>
01648   theta = <a class="code" href="lsd_8c.html#a48">get_theta</a>(reg,reg_size,x,y,modgrad,reg_angle,prec);
01649 
01650   <span class="comment">/* length and width:</span>
01651 <span class="comment"></span>
01652 <span class="comment">     'l' and 'w' are computed as the distance from the center of the</span>
01653 <span class="comment">     region to pixel i, projected along the rectangle axis (dx,dy) and</span>
01654 <span class="comment">     to the orthogonal axis (-dy,dx), respectively.</span>
01655 <span class="comment"></span>
01656 <span class="comment">     The length of the rectangle goes from l_min to l_max, where l_min</span>
01657 <span class="comment">     and l_max are the minimum and maximum values of l in the region.</span>
01658 <span class="comment">     Analogously, the width is selected from w_min to w_max, where</span>
01659 <span class="comment">     w_min and w_max are the minimum and maximum of w for the pixels</span>
01660 <span class="comment">     in the region.</span>
01661 <span class="comment">   */</span>
01662   dx = cos(theta);
01663   dy = sin(theta);
01664   l_min = l_max = w_min = w_max = 0.0;
01665   <span class="keywordflow">for</span>(i=0; i&lt;reg_size; i++)
01666     {
01667       l =  ( (<span class="keywordtype">double</span>) reg[i].<a class="code" href="structpoint.html#o0">x</a> - x) * dx + ( (<span class="keywordtype">double</span>) reg[i].<a class="code" href="structpoint.html#o1">y</a> - y) * dy;
01668       w = -( (<span class="keywordtype">double</span>) reg[i].<a class="code" href="structpoint.html#o0">x</a> - x) * dy + ( (<span class="keywordtype">double</span>) reg[i].<a class="code" href="structpoint.html#o1">y</a> - y) * dx;
01669 
01670       <span class="keywordflow">if</span>( l &gt; l_max ) l_max = l;
01671       <span class="keywordflow">if</span>( l &lt; l_min ) l_min = l;
01672       <span class="keywordflow">if</span>( w &gt; w_max ) w_max = w;
01673       <span class="keywordflow">if</span>( w &lt; w_min ) w_min = w;
01674     }
01675 
01676   <span class="comment">/* store values */</span>
01677   rec-&gt;<a class="code" href="structrect.html#o0">x1</a> = x + l_min * dx;
01678   rec-&gt;<a class="code" href="structrect.html#o1">y1</a> = y + l_min * dy;
01679   rec-&gt;<a class="code" href="structrect.html#o2">x2</a> = x + l_max * dx;
01680   rec-&gt;<a class="code" href="structrect.html#o3">y2</a> = y + l_max * dy;
01681   rec-&gt;<a class="code" href="structrect.html#o4">width</a> = w_max - w_min;
01682   rec-&gt;<a class="code" href="structrect.html#o5">x</a> = x;
01683   rec-&gt;<a class="code" href="structrect.html#o6">y</a> = y;
01684   rec-&gt;<a class="code" href="structrect.html#o7">theta</a> = theta;
01685   rec-&gt;<a class="code" href="structrect.html#o8">dx</a> = dx;
01686   rec-&gt;<a class="code" href="structrect.html#o9">dy</a> = dy;
01687   rec-&gt;<a class="code" href="structrect.html#o10">prec</a> = prec;
01688   rec-&gt;<a class="code" href="structrect.html#o11">p</a> = p;
01689 
01690   <span class="comment">/* we impose a minimal width of one pixel</span>
01691 <span class="comment"></span>
01692 <span class="comment">     A sharp horizontal or vertical step would produce a perfectly</span>
01693 <span class="comment">     horizontal or vertical region. The width computed would be</span>
01694 <span class="comment">     zero. But that corresponds to a one pixels width transition in</span>
01695 <span class="comment">     the image.</span>
01696 <span class="comment">   */</span>
01697   <span class="keywordflow">if</span>( rec-&gt;<a class="code" href="structrect.html#o4">width</a> &lt; 1.0 ) rec-&gt;<a class="code" href="structrect.html#o4">width</a> = 1.0;
01698 }
01699 
01700 <span class="comment">/*----------------------------------------------------------------------------*/</span><span class="comment"></span>
01701 <span class="comment">/** Build a region of pixels that share the same angle, up to a</span>
01702 <span class="comment">    tolerance 'prec', starting at point (x,y).</span>
01703 <span class="comment"> */</span>
<a name="l01704"></a><a class="code" href="lsd_8c.html#a50">01704</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="lsd_8c.html#a50">region_grow</a>( <span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y, <a class="code" href="structimage__double__s.html">image_double</a> angles, <span class="keyword">struct</span> <a class="code" href="structpoint.html">point</a> * reg,
01705                          <span class="keywordtype">int</span> * reg_size, <span class="keywordtype">double</span> * reg_angle, <a class="code" href="structimage__char__s.html">image_char</a> used,
01706                          <span class="keywordtype">double</span> prec )
01707 {
01708   <span class="keywordtype">double</span> sumdx,sumdy;
01709   <span class="keywordtype">int</span> xx,yy,i;
01710 
01711   <span class="comment">/* check parameters */</span>
01712   <span class="keywordflow">if</span>( x &lt; 0 || y &lt; 0 || x &gt;= (<span class="keywordtype">int</span>) angles-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a> || y &gt;= (<span class="keywordtype">int</span>) angles-&gt;<a class="code" href="structimage__double__s.html#o2">ysize</a> )
01713     <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"region_grow: (x,y) out of the image."</span>);
01714   <span class="keywordflow">if</span>( angles == NULL || angles-&gt;<a class="code" href="structimage__double__s.html#o0">data</a> == NULL )
01715     <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"region_grow: invalid image 'angles'."</span>);
01716   <span class="keywordflow">if</span>( reg == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"region_grow: invalid 'reg'."</span>);
01717   <span class="keywordflow">if</span>( reg_size == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"region_grow: invalid pointer 'reg_size'."</span>);
01718   <span class="keywordflow">if</span>( reg_angle == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"region_grow: invalid pointer 'reg_angle'."</span>);
01719   <span class="keywordflow">if</span>( used == NULL || used-&gt;<a class="code" href="structimage__char__s.html#o0">data</a> == NULL )
01720     <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"region_grow: invalid image 'used'."</span>);
01721 
01722   <span class="comment">/* first point of the region */</span>
01723   *reg_size = 1;
01724   reg[0].<a class="code" href="structpoint.html#o0">x</a> = x;
01725   reg[0].<a class="code" href="structpoint.html#o1">y</a> = y;
01726   *reg_angle = angles-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>[x+y*angles-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a>];  <span class="comment">/* region's angle */</span>
01727   sumdx = cos(*reg_angle);
01728   sumdy = sin(*reg_angle);
01729   used-&gt;<a class="code" href="structimage__char__s.html#o0">data</a>[x+y*used-&gt;<a class="code" href="structimage__char__s.html#o1">xsize</a>] = <a class="code" href="lsd_8c.html#a8">USED</a>;
01730 
01731   <span class="comment">/* try neighbors as new region points */</span>
01732   <span class="keywordflow">for</span>(i=0; i&lt;*reg_size; i++)
01733     <span class="keywordflow">for</span>(xx=reg[i].<a class="code" href="structpoint.html#o0">x</a>-1; xx&lt;=reg[i].x+1; xx++)
01734       <span class="keywordflow">for</span>(yy=reg[i].y-1; yy&lt;=reg[i].y+1; yy++)
01735         <span class="keywordflow">if</span>( xx&gt;=0 &amp;&amp; yy&gt;=0 &amp;&amp; xx&lt;(<span class="keywordtype">int</span>)used-&gt;<a class="code" href="structimage__char__s.html#o1">xsize</a> &amp;&amp; yy&lt;(<span class="keywordtype">int</span>)used-&gt;<a class="code" href="structimage__char__s.html#o2">ysize</a> &amp;&amp;
01736             used-&gt;<a class="code" href="structimage__char__s.html#o0">data</a>[xx+yy*used-&gt;<a class="code" href="structimage__char__s.html#o1">xsize</a>] != <a class="code" href="lsd_8c.html#a8">USED</a> &amp;&amp;
01737             <a class="code" href="lsd_8c.html#a34">isaligned</a>(xx,yy,angles,*reg_angle,prec) )
01738           {
01739             <span class="comment">/* add point */</span>
01740             used-&gt;<a class="code" href="structimage__char__s.html#o0">data</a>[xx+yy*used-&gt;<a class="code" href="structimage__char__s.html#o1">xsize</a>] = <a class="code" href="lsd_8c.html#a8">USED</a>;
01741             reg[*reg_size].x = xx;
01742             reg[*reg_size].y = yy;
01743             ++(*reg_size);
01744 
01745             <span class="comment">/* update region's angle */</span>
01746             sumdx += cos( angles-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>[xx+yy*angles-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a>] );
01747             sumdy += sin( angles-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>[xx+yy*angles-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a>] );
01748             *reg_angle = atan2(sumdy,sumdx);
01749           }
01750 }
01751 
01752 <span class="comment">/*----------------------------------------------------------------------------*/</span><span class="comment"></span>
01753 <span class="comment">/** Try some rectangles variations to improve NFA value. Only if the</span>
01754 <span class="comment">    rectangle is not meaningful (i.e., log_nfa &lt;= log_eps).</span>
01755 <span class="comment"> */</span>
<a name="l01756"></a><a class="code" href="lsd_8c.html#a51">01756</a> <span class="keyword">static</span> <span class="keywordtype">double</span> <a class="code" href="lsd_8c.html#a51">rect_improve</a>( <span class="keyword">struct</span> <a class="code" href="structrect.html">rect</a> * rec, <a class="code" href="structimage__double__s.html">image_double</a> angles,
01757                             <span class="keywordtype">double</span> logNT, <span class="keywordtype">double</span> log_eps )
01758 {
01759   <span class="keyword">struct </span><a class="code" href="structrect.html">rect</a> r;
01760   <span class="keywordtype">double</span> log_nfa,log_nfa_new;
01761   <span class="keywordtype">double</span> delta = 0.5;
01762   <span class="keywordtype">double</span> delta_2 = delta / 2.0;
01763   <span class="keywordtype">int</span> n;
01764 
01765   log_nfa = <a class="code" href="lsd_8c.html#a47">rect_nfa</a>(rec,angles,logNT);
01766 
01767   <span class="keywordflow">if</span>( log_nfa &gt; log_eps ) <span class="keywordflow">return</span> log_nfa;
01768 
01769   <span class="comment">/* try finer precisions */</span>
01770   <a class="code" href="lsd_8c.html#a40">rect_copy</a>(rec,&amp;r);
01771   <span class="keywordflow">for</span>(n=0; n&lt;5; n++)
01772     {
01773       r.<a class="code" href="structrect.html#o11">p</a> /= 2.0;
01774       r.<a class="code" href="structrect.html#o10">prec</a> = r.<a class="code" href="structrect.html#o11">p</a> * <a class="code" href="lsd_8c.html#a1">M_PI</a>;
01775       log_nfa_new = <a class="code" href="lsd_8c.html#a47">rect_nfa</a>(&amp;r,angles,logNT);
01776       <span class="keywordflow">if</span>( log_nfa_new &gt; log_nfa )
01777         {
01778           log_nfa = log_nfa_new;
01779           <a class="code" href="lsd_8c.html#a40">rect_copy</a>(&amp;r,rec);
01780         }
01781     }
01782 
01783   <span class="keywordflow">if</span>( log_nfa &gt; log_eps ) <span class="keywordflow">return</span> log_nfa;
01784 
01785   <span class="comment">/* try to reduce width */</span>
01786   <a class="code" href="lsd_8c.html#a40">rect_copy</a>(rec,&amp;r);
01787   <span class="keywordflow">for</span>(n=0; n&lt;5; n++)
01788     {
01789       <span class="keywordflow">if</span>( (r.<a class="code" href="structrect.html#o4">width</a> - delta) &gt;= 0.5 )
01790         {
01791           r.<a class="code" href="structrect.html#o4">width</a> -= delta;
01792           log_nfa_new = <a class="code" href="lsd_8c.html#a47">rect_nfa</a>(&amp;r,angles,logNT);
01793           <span class="keywordflow">if</span>( log_nfa_new &gt; log_nfa )
01794             {
01795               <a class="code" href="lsd_8c.html#a40">rect_copy</a>(&amp;r,rec);
01796               log_nfa = log_nfa_new;
01797             }
01798         }
01799     }
01800 
01801   <span class="keywordflow">if</span>( log_nfa &gt; log_eps ) <span class="keywordflow">return</span> log_nfa;
01802 
01803   <span class="comment">/* try to reduce one side of the rectangle */</span>
01804   <a class="code" href="lsd_8c.html#a40">rect_copy</a>(rec,&amp;r);
01805   <span class="keywordflow">for</span>(n=0; n&lt;5; n++)
01806     {
01807       <span class="keywordflow">if</span>( (r.<a class="code" href="structrect.html#o4">width</a> - delta) &gt;= 0.5 )
01808         {
01809           r.<a class="code" href="structrect.html#o0">x1</a> += -r.<a class="code" href="structrect.html#o9">dy</a> * delta_2;
01810           r.<a class="code" href="structrect.html#o1">y1</a> +=  r.<a class="code" href="structrect.html#o8">dx</a> * delta_2;
01811           r.<a class="code" href="structrect.html#o2">x2</a> += -r.<a class="code" href="structrect.html#o9">dy</a> * delta_2;
01812           r.<a class="code" href="structrect.html#o3">y2</a> +=  r.<a class="code" href="structrect.html#o8">dx</a> * delta_2;
01813           r.<a class="code" href="structrect.html#o4">width</a> -= delta;
01814           log_nfa_new = <a class="code" href="lsd_8c.html#a47">rect_nfa</a>(&amp;r,angles,logNT);
01815           <span class="keywordflow">if</span>( log_nfa_new &gt; log_nfa )
01816             {
01817               <a class="code" href="lsd_8c.html#a40">rect_copy</a>(&amp;r,rec);
01818               log_nfa = log_nfa_new;
01819             }
01820         }
01821     }
01822 
01823   <span class="keywordflow">if</span>( log_nfa &gt; log_eps ) <span class="keywordflow">return</span> log_nfa;
01824 
01825   <span class="comment">/* try to reduce the other side of the rectangle */</span>
01826   <a class="code" href="lsd_8c.html#a40">rect_copy</a>(rec,&amp;r);
01827   <span class="keywordflow">for</span>(n=0; n&lt;5; n++)
01828     {
01829       <span class="keywordflow">if</span>( (r.<a class="code" href="structrect.html#o4">width</a> - delta) &gt;= 0.5 )
01830         {
01831           r.<a class="code" href="structrect.html#o0">x1</a> -= -r.<a class="code" href="structrect.html#o9">dy</a> * delta_2;
01832           r.<a class="code" href="structrect.html#o1">y1</a> -=  r.<a class="code" href="structrect.html#o8">dx</a> * delta_2;
01833           r.<a class="code" href="structrect.html#o2">x2</a> -= -r.<a class="code" href="structrect.html#o9">dy</a> * delta_2;
01834           r.<a class="code" href="structrect.html#o3">y2</a> -=  r.<a class="code" href="structrect.html#o8">dx</a> * delta_2;
01835           r.<a class="code" href="structrect.html#o4">width</a> -= delta;
01836           log_nfa_new = <a class="code" href="lsd_8c.html#a47">rect_nfa</a>(&amp;r,angles,logNT);
01837           <span class="keywordflow">if</span>( log_nfa_new &gt; log_nfa )
01838             {
01839               <a class="code" href="lsd_8c.html#a40">rect_copy</a>(&amp;r,rec);
01840               log_nfa = log_nfa_new;
01841             }
01842         }
01843     }
01844 
01845   <span class="keywordflow">if</span>( log_nfa &gt; log_eps ) <span class="keywordflow">return</span> log_nfa;
01846 
01847   <span class="comment">/* try even finer precisions */</span>
01848   <a class="code" href="lsd_8c.html#a40">rect_copy</a>(rec,&amp;r);
01849   <span class="keywordflow">for</span>(n=0; n&lt;5; n++)
01850     {
01851       r.<a class="code" href="structrect.html#o11">p</a> /= 2.0;
01852       r.<a class="code" href="structrect.html#o10">prec</a> = r.<a class="code" href="structrect.html#o11">p</a> * <a class="code" href="lsd_8c.html#a1">M_PI</a>;
01853       log_nfa_new = <a class="code" href="lsd_8c.html#a47">rect_nfa</a>(&amp;r,angles,logNT);
01854       <span class="keywordflow">if</span>( log_nfa_new &gt; log_nfa )
01855         {
01856           log_nfa = log_nfa_new;
01857           <a class="code" href="lsd_8c.html#a40">rect_copy</a>(&amp;r,rec);
01858         }
01859     }
01860 
01861   <span class="keywordflow">return</span> log_nfa;
01862 }
01863 
01864 <span class="comment">/*----------------------------------------------------------------------------*/</span><span class="comment"></span>
01865 <span class="comment">/** Reduce the region size, by elimination the points far from the</span>
01866 <span class="comment">    starting point, until that leads to rectangle with the right</span>
01867 <span class="comment">    density of region points or to discard the region if too small.</span>
01868 <span class="comment"> */</span>
<a name="l01869"></a><a class="code" href="lsd_8c.html#a52">01869</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="lsd_8c.html#a52">reduce_region_radius</a>( <span class="keyword">struct</span> <a class="code" href="structpoint.html">point</a> * reg, <span class="keywordtype">int</span> * reg_size,
01870                                  <a class="code" href="structimage__double__s.html">image_double</a> modgrad, <span class="keywordtype">double</span> reg_angle,
01871                                  <span class="keywordtype">double</span> prec, <span class="keywordtype">double</span> p, <span class="keyword">struct</span> <a class="code" href="structrect.html">rect</a> * rec,
01872                                  <a class="code" href="structimage__char__s.html">image_char</a> used, <a class="code" href="structimage__double__s.html">image_double</a> angles,
01873                                  <span class="keywordtype">double</span> density_th )
01874 {
01875   <span class="keywordtype">double</span> density,rad1,rad2,rad,xc,yc;
01876   <span class="keywordtype">int</span> i;
01877 
01878   <span class="comment">/* check parameters */</span>
01879   <span class="keywordflow">if</span>( reg == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"reduce_region_radius: invalid pointer 'reg'."</span>);
01880   <span class="keywordflow">if</span>( reg_size == NULL )
01881     <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"reduce_region_radius: invalid pointer 'reg_size'."</span>);
01882   <span class="keywordflow">if</span>( prec &lt; 0.0 ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"reduce_region_radius: 'prec' must be positive."</span>);
01883   <span class="keywordflow">if</span>( rec == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"reduce_region_radius: invalid pointer 'rec'."</span>);
01884   <span class="keywordflow">if</span>( used == NULL || used-&gt;<a class="code" href="structimage__char__s.html#o0">data</a> == NULL )
01885     <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"reduce_region_radius: invalid image 'used'."</span>);
01886   <span class="keywordflow">if</span>( angles == NULL || angles-&gt;<a class="code" href="structimage__double__s.html#o0">data</a> == NULL )
01887     <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"reduce_region_radius: invalid image 'angles'."</span>);
01888 
01889   <span class="comment">/* compute region points density */</span>
01890   density = (<span class="keywordtype">double</span>) *reg_size /
01891                          ( <a class="code" href="lsd_8c.html#a18">dist</a>(rec-&gt;<a class="code" href="structrect.html#o0">x1</a>,rec-&gt;<a class="code" href="structrect.html#o1">y1</a>,rec-&gt;<a class="code" href="structrect.html#o2">x2</a>,rec-&gt;<a class="code" href="structrect.html#o3">y2</a>) * rec-&gt;<a class="code" href="structrect.html#o4">width</a> );
01892 
01893   <span class="comment">/* if the density criterion is satisfied there is nothing to do */</span>
01894   <span class="keywordflow">if</span>( density &gt;= density_th ) <span class="keywordflow">return</span> <a class="code" href="lsd_8c.html#a3">TRUE</a>;
01895 
01896   <span class="comment">/* compute region's radius */</span>
01897   xc = (<span class="keywordtype">double</span>) reg[0].<a class="code" href="structpoint.html#o0">x</a>;
01898   yc = (<span class="keywordtype">double</span>) reg[0].<a class="code" href="structpoint.html#o1">y</a>;
01899   rad1 = <a class="code" href="lsd_8c.html#a18">dist</a>( xc, yc, rec-&gt;<a class="code" href="structrect.html#o0">x1</a>, rec-&gt;<a class="code" href="structrect.html#o1">y1</a> );
01900   rad2 = <a class="code" href="lsd_8c.html#a18">dist</a>( xc, yc, rec-&gt;<a class="code" href="structrect.html#o2">x2</a>, rec-&gt;<a class="code" href="structrect.html#o3">y2</a> );
01901   rad = rad1 &gt; rad2 ? rad1 : rad2;
01902 
01903   <span class="comment">/* while the density criterion is not satisfied, remove farther pixels */</span>
01904   <span class="keywordflow">while</span>( density &lt; density_th )
01905     {
01906       rad *= 0.75; <span class="comment">/* reduce region's radius to 75% of its value */</span>
01907 
01908       <span class="comment">/* remove points from the region and update 'used' map */</span>
01909       <span class="keywordflow">for</span>(i=0; i&lt;*reg_size; i++)
01910         <span class="keywordflow">if</span>( <a class="code" href="lsd_8c.html#a18">dist</a>( xc, yc, (<span class="keywordtype">double</span>) reg[i].x, (<span class="keywordtype">double</span>) reg[i].y ) &gt; rad )
01911           {
01912             <span class="comment">/* point not kept, mark it as NOTUSED */</span>
01913             used-&gt;<a class="code" href="structimage__char__s.html#o0">data</a>[ reg[i].<a class="code" href="structpoint.html#o0">x</a> + reg[i].<a class="code" href="structpoint.html#o1">y</a> * used-&gt;<a class="code" href="structimage__char__s.html#o1">xsize</a> ] = <a class="code" href="lsd_8c.html#a7">NOTUSED</a>;
01914             <span class="comment">/* remove point from the region */</span>
01915             reg[i].<a class="code" href="structpoint.html#o0">x</a> = reg[*reg_size-1].<a class="code" href="structpoint.html#o0">x</a>; <span class="comment">/* if i==*reg_size-1 copy itself */</span>
01916             reg[i].<a class="code" href="structpoint.html#o1">y</a> = reg[*reg_size-1].<a class="code" href="structpoint.html#o1">y</a>;
01917             --(*reg_size);
01918             --i; <span class="comment">/* to avoid skipping one point */</span>
01919           }
01920 
01921       <span class="comment">/* reject if the region is too small.</span>
01922 <span class="comment">         2 is the minimal region size for 'region2rect' to work. */</span>
01923       <span class="keywordflow">if</span>( *reg_size &lt; 2 ) <span class="keywordflow">return</span> <a class="code" href="lsd_8c.html#a2">FALSE</a>;
01924 
01925       <span class="comment">/* re-compute rectangle */</span>
01926       <a class="code" href="lsd_8c.html#a49">region2rect</a>(reg,*reg_size,modgrad,reg_angle,prec,p,rec);
01927 
01928       <span class="comment">/* re-compute region points density */</span>
01929       density = (<span class="keywordtype">double</span>) *reg_size /
01930                          ( <a class="code" href="lsd_8c.html#a18">dist</a>(rec-&gt;<a class="code" href="structrect.html#o0">x1</a>,rec-&gt;<a class="code" href="structrect.html#o1">y1</a>,rec-&gt;<a class="code" href="structrect.html#o2">x2</a>,rec-&gt;<a class="code" href="structrect.html#o3">y2</a>) * rec-&gt;<a class="code" href="structrect.html#o4">width</a> );
01931     }
01932 
01933   <span class="comment">/* if this point is reached, the density criterion is satisfied */</span>
01934   <span class="keywordflow">return</span> <a class="code" href="lsd_8c.html#a3">TRUE</a>;
01935 }
01936 
01937 <span class="comment">/*----------------------------------------------------------------------------*/</span><span class="comment"></span>
01938 <span class="comment">/** Refine a rectangle.</span>
01939 <span class="comment"></span>
01940 <span class="comment">    For that, an estimation of the angle tolerance is performed by the</span>
01941 <span class="comment">    standard deviation of the angle at points near the region's</span>
01942 <span class="comment">    starting point. Then, a new region is grown starting from the same</span>
01943 <span class="comment">    point, but using the estimated angle tolerance. If this fails to</span>
01944 <span class="comment">    produce a rectangle with the right density of region points,</span>
01945 <span class="comment">    'reduce_region_radius' is called to try to satisfy this condition.</span>
01946 <span class="comment"> */</span>
<a name="l01947"></a><a class="code" href="lsd_8c.html#a53">01947</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="lsd_8c.html#a53">refine</a>( <span class="keyword">struct</span> <a class="code" href="structpoint.html">point</a> * reg, <span class="keywordtype">int</span> * reg_size, <a class="code" href="structimage__double__s.html">image_double</a> modgrad,
01948                    <span class="keywordtype">double</span> reg_angle, <span class="keywordtype">double</span> prec, <span class="keywordtype">double</span> p, <span class="keyword">struct</span> <a class="code" href="structrect.html">rect</a> * rec,
01949                    <a class="code" href="structimage__char__s.html">image_char</a> used, <a class="code" href="structimage__double__s.html">image_double</a> angles, <span class="keywordtype">double</span> density_th )
01950 {
01951   <span class="keywordtype">double</span> angle,ang_d,mean_angle,tau,density,xc,yc,ang_c,sum,s_sum;
01952   <span class="keywordtype">int</span> i,n;
01953 
01954   <span class="comment">/* check parameters */</span>
01955   <span class="keywordflow">if</span>( reg == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"refine: invalid pointer 'reg'."</span>);
01956   <span class="keywordflow">if</span>( reg_size == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"refine: invalid pointer 'reg_size'."</span>);
01957   <span class="keywordflow">if</span>( prec &lt; 0.0 ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"refine: 'prec' must be positive."</span>);
01958   <span class="keywordflow">if</span>( rec == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"refine: invalid pointer 'rec'."</span>);
01959   <span class="keywordflow">if</span>( used == NULL || used-&gt;<a class="code" href="structimage__char__s.html#o0">data</a> == NULL )
01960     <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"refine: invalid image 'used'."</span>);
01961   <span class="keywordflow">if</span>( angles == NULL || angles-&gt;<a class="code" href="structimage__double__s.html#o0">data</a> == NULL )
01962     <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"refine: invalid image 'angles'."</span>);
01963 
01964   <span class="comment">/* compute region points density */</span>
01965   density = (<span class="keywordtype">double</span>) *reg_size /
01966                          ( <a class="code" href="lsd_8c.html#a18">dist</a>(rec-&gt;<a class="code" href="structrect.html#o0">x1</a>,rec-&gt;<a class="code" href="structrect.html#o1">y1</a>,rec-&gt;<a class="code" href="structrect.html#o2">x2</a>,rec-&gt;<a class="code" href="structrect.html#o3">y2</a>) * rec-&gt;<a class="code" href="structrect.html#o4">width</a> );
01967 
01968   <span class="comment">/* if the density criterion is satisfied there is nothing to do */</span>
01969   <span class="keywordflow">if</span>( density &gt;= density_th ) <span class="keywordflow">return</span> <a class="code" href="lsd_8c.html#a3">TRUE</a>;
01970 
01971   <span class="comment">/*------ First try: reduce angle tolerance ------*/</span>
01972 
01973   <span class="comment">/* compute the new mean angle and tolerance */</span>
01974   xc = (<span class="keywordtype">double</span>) reg[0].<a class="code" href="structpoint.html#o0">x</a>;
01975   yc = (<span class="keywordtype">double</span>) reg[0].<a class="code" href="structpoint.html#o1">y</a>;
01976   ang_c = angles-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>[ reg[0].<a class="code" href="structpoint.html#o0">x</a> + reg[0].<a class="code" href="structpoint.html#o1">y</a> * angles-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a> ];
01977   sum = s_sum = 0.0;
01978   n = 0;
01979   <span class="keywordflow">for</span>(i=0; i&lt;*reg_size; i++)
01980     {
01981       used-&gt;<a class="code" href="structimage__char__s.html#o0">data</a>[ reg[i].<a class="code" href="structpoint.html#o0">x</a> + reg[i].<a class="code" href="structpoint.html#o1">y</a> * used-&gt;<a class="code" href="structimage__char__s.html#o1">xsize</a> ] = <a class="code" href="lsd_8c.html#a7">NOTUSED</a>;
01982       <span class="keywordflow">if</span>( <a class="code" href="lsd_8c.html#a18">dist</a>( xc, yc, (<span class="keywordtype">double</span>) reg[i].x, (<span class="keywordtype">double</span>) reg[i].y ) &lt; rec-&gt;<a class="code" href="structrect.html#o4">width</a> )
01983         {
01984           angle = angles-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>[ reg[i].<a class="code" href="structpoint.html#o0">x</a> + reg[i].<a class="code" href="structpoint.html#o1">y</a> * angles-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a> ];
01985           ang_d = <a class="code" href="lsd_8c.html#a36">angle_diff_signed</a>(angle,ang_c);
01986           sum += ang_d;
01987           s_sum += ang_d * ang_d;
01988           ++n;
01989         }
01990     }
01991   mean_angle = sum / (<span class="keywordtype">double</span>) n;
01992   tau = 2.0 * sqrt( (s_sum - 2.0 * mean_angle * sum) / (<span class="keywordtype">double</span>) n
01993                          + mean_angle*mean_angle ); <span class="comment">/* 2 * standard deviation */</span>
01994 
01995   <span class="comment">/* find a new region from the same starting point and new angle tolerance */</span>
01996   <a class="code" href="lsd_8c.html#a50">region_grow</a>(reg[0].x,reg[0].y,angles,reg,reg_size,&amp;reg_angle,used,tau);
01997 
01998   <span class="comment">/* if the region is too small, reject */</span>
01999   <span class="keywordflow">if</span>( *reg_size &lt; 2 ) <span class="keywordflow">return</span> <a class="code" href="lsd_8c.html#a2">FALSE</a>;
02000 
02001   <span class="comment">/* re-compute rectangle */</span>
02002   <a class="code" href="lsd_8c.html#a49">region2rect</a>(reg,*reg_size,modgrad,reg_angle,prec,p,rec);
02003 
02004   <span class="comment">/* re-compute region points density */</span>
02005   density = (<span class="keywordtype">double</span>) *reg_size /
02006                       ( <a class="code" href="lsd_8c.html#a18">dist</a>(rec-&gt;<a class="code" href="structrect.html#o0">x1</a>,rec-&gt;<a class="code" href="structrect.html#o1">y1</a>,rec-&gt;<a class="code" href="structrect.html#o2">x2</a>,rec-&gt;<a class="code" href="structrect.html#o3">y2</a>) * rec-&gt;<a class="code" href="structrect.html#o4">width</a> );
02007 
02008   <span class="comment">/*------ Second try: reduce region radius ------*/</span>
02009   <span class="keywordflow">if</span>( density &lt; density_th )
02010     <span class="keywordflow">return</span> <a class="code" href="lsd_8c.html#a52">reduce_region_radius</a>( reg, reg_size, modgrad, reg_angle, prec, p,
02011                                  rec, used, angles, density_th );
02012 
02013   <span class="comment">/* if this point is reached, the density criterion is satisfied */</span>
02014   <span class="keywordflow">return</span> <a class="code" href="lsd_8c.html#a3">TRUE</a>;
02015 }
02016 
02017 
02018 <span class="comment">/*----------------------------------------------------------------------------*/</span>
02019 <span class="comment">/*-------------------------- Line Segment Detector ---------------------------*/</span>
02020 <span class="comment">/*----------------------------------------------------------------------------*/</span>
02021 
02022 <span class="comment">/*----------------------------------------------------------------------------*/</span><span class="comment"></span>
02023 <span class="comment">/** LSD full interface.</span>
02024 <span class="comment"> */</span>
<a name="l02025"></a><a class="code" href="lsd_8c.html#a54">02025</a> <span class="keywordtype">double</span> * <a class="code" href="lsd_8c.html#a54">LineSegmentDetection</a>( <span class="keywordtype">int</span> * n_out,
02026                                <span class="keywordtype">double</span> * img, <span class="keywordtype">int</span> X, <span class="keywordtype">int</span> Y,
02027                                <span class="keywordtype">double</span> scale, <span class="keywordtype">double</span> sigma_scale, <span class="keywordtype">double</span> quant,
02028                                <span class="keywordtype">double</span> ang_th, <span class="keywordtype">double</span> log_eps, <span class="keywordtype">double</span> density_th,
02029                                <span class="keywordtype">int</span> n_bins,
02030                                <span class="keywordtype">int</span> ** reg_img, <span class="keywordtype">int</span> * reg_x, <span class="keywordtype">int</span> * reg_y )
02031 {
02032   <a class="code" href="structimage__double__s.html">image_double</a> image;
02033   <a class="code" href="structntuple__list__s.html">ntuple_list</a> out = <a class="code" href="lsd_8c.html#a20">new_ntuple_list</a>(7);
02034   <span class="keywordtype">double</span> * return_value;
02035   <a class="code" href="structimage__double__s.html">image_double</a> scaled_image,angles,modgrad;
02036   <a class="code" href="structimage__char__s.html">image_char</a> used;
02037   <a class="code" href="structimage__int__s.html">image_int</a> region = NULL;
02038   <span class="keyword">struct </span><a class="code" href="structcoorlist.html">coorlist</a> * list_p;
02039   <span class="keywordtype">void</span> * mem_p;
02040   <span class="keyword">struct </span><a class="code" href="structrect.html">rect</a> rec;
02041   <span class="keyword">struct </span><a class="code" href="structpoint.html">point</a> * reg;
02042   <span class="keywordtype">int</span> reg_size,min_reg_size,i;
02043   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> xsize,ysize;
02044   <span class="keywordtype">double</span> rho,reg_angle,prec,p,log_nfa,logNT;
02045   <span class="keywordtype">int</span> ls_count = 0;                   <span class="comment">/* line segments are numbered 1,2,3,... */</span>
02046 
02047 
02048   <span class="comment">/* check parameters */</span>
02049   <span class="keywordflow">if</span>( img == NULL || X &lt;= 0 || Y &lt;= 0 ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"invalid image input."</span>);
02050   <span class="keywordflow">if</span>( scale &lt;= 0.0 ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"'scale' value must be positive."</span>);
02051   <span class="keywordflow">if</span>( sigma_scale &lt;= 0.0 ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"'sigma_scale' value must be positive."</span>);
02052   <span class="keywordflow">if</span>( quant &lt; 0.0 ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"'quant' value must be positive."</span>);
02053   <span class="keywordflow">if</span>( ang_th &lt;= 0.0 || ang_th &gt;= 180.0 )
02054     <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"'ang_th' value must be in the range (0,180)."</span>);
02055   <span class="keywordflow">if</span>( density_th &lt; 0.0 || density_th &gt; 1.0 )
02056     <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"'density_th' value must be in the range [0,1]."</span>);
02057   <span class="keywordflow">if</span>( n_bins &lt;= 0 ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"'n_bins' value must be positive."</span>);
02058 
02059 
02060   <span class="comment">/* angle tolerance */</span>
02061   prec = <a class="code" href="lsd_8c.html#a1">M_PI</a> * ang_th / 180.0;
02062   p = ang_th / 180.0;
02063   rho = quant / sin(prec); <span class="comment">/* gradient magnitude threshold */</span>
02064 
02065 
02066   <span class="comment">/* load and scale image (if necessary) and compute angle at each pixel */</span>
02067   image = <a class="code" href="lsd_8c.html#a30">new_image_double_ptr</a>( (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>) X, (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>) Y, img );
02068   <span class="keywordflow">if</span>( scale != 1.0 )
02069     {
02070       scaled_image = <a class="code" href="lsd_8c.html#a32">gaussian_sampler</a>( image, scale, sigma_scale );
02071       angles = <a class="code" href="lsd_8c.html#a33">ll_angle</a>( scaled_image, rho, &amp;list_p, &amp;mem_p,
02072                          &amp;modgrad, (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>) n_bins );
02073       <a class="code" href="lsd_8c.html#a28">free_image_double</a>(scaled_image);
02074     }
02075   <span class="keywordflow">else</span>
02076     angles = <a class="code" href="lsd_8c.html#a33">ll_angle</a>( image, rho, &amp;list_p, &amp;mem_p, &amp;modgrad,
02077                        (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>) n_bins );
02078   xsize = angles-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a>;
02079   ysize = angles-&gt;<a class="code" href="structimage__double__s.html#o2">ysize</a>;
02080 
02081   <span class="comment">/* Number of Tests - NT</span>
02082 <span class="comment"></span>
02083 <span class="comment">     The theoretical number of tests is Np.(XY)^(5/2)</span>
02084 <span class="comment">     where X and Y are number of columns and rows of the image.</span>
02085 <span class="comment">     Np corresponds to the number of angle precisions considered.</span>
02086 <span class="comment">     As the procedure 'rect_improve' tests 5 times to halve the</span>
02087 <span class="comment">     angle precision, and 5 more times after improving other factors,</span>
02088 <span class="comment">     11 different precision values are potentially tested. Thus,</span>
02089 <span class="comment">     the number of tests is</span>
02090 <span class="comment">       11 * (X*Y)^(5/2)</span>
02091 <span class="comment">     whose logarithm value is</span>
02092 <span class="comment">       log10(11) + 5/2 * (log10(X) + log10(Y)).</span>
02093 <span class="comment">  */</span>
02094   logNT = 5.0 * ( log10( (<span class="keywordtype">double</span>) xsize ) + log10( (<span class="keywordtype">double</span>) ysize ) ) / 2.0
02095           + log10(11.0);
02096   min_reg_size = (<span class="keywordtype">int</span>) (-logNT/log10(p)); <span class="comment">/* minimal number of points in region</span>
02097 <span class="comment">                                             that can give a meaningful event */</span>
02098 
02099 
02100   <span class="comment">/* initialize some structures */</span>
02101   <span class="keywordflow">if</span>( reg_img != NULL &amp;&amp; reg_x != NULL &amp;&amp; reg_y != NULL ) <span class="comment">/* save region data */</span>
02102     region = <a class="code" href="lsd_8c.html#a27">new_image_int_ini</a>(angles-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a>,angles-&gt;<a class="code" href="structimage__double__s.html#o2">ysize</a>,0);
02103   used = <a class="code" href="lsd_8c.html#a25">new_image_char_ini</a>(xsize,ysize,<a class="code" href="lsd_8c.html#a7">NOTUSED</a>);
02104   reg = (<span class="keyword">struct </span><a class="code" href="structpoint.html">point</a> *) calloc( (size_t) (xsize*ysize), <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structpoint.html">point</a>) );
02105   <span class="keywordflow">if</span>( reg == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"not enough memory!"</span>);
02106 
02107 
02108   <span class="comment">/* search for line segments */</span>
02109   <span class="keywordflow">for</span>(; list_p != NULL; list_p = list_p-&gt;next )
02110     <span class="keywordflow">if</span>( used-&gt;<a class="code" href="structimage__char__s.html#o0">data</a>[ list_p-&gt;x + list_p-&gt;y * used-&gt;<a class="code" href="structimage__char__s.html#o1">xsize</a> ] == <a class="code" href="lsd_8c.html#a7">NOTUSED</a> &amp;&amp;
02111         angles-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>[ list_p-&gt;x + list_p-&gt;y * angles-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a> ] != <a class="code" href="lsd_8c.html#a4">NOTDEF</a> )
02112        <span class="comment">/* there is no risk of double comparison problems here</span>
02113 <span class="comment">          because we are only interested in the exact NOTDEF value */</span>
02114       {
02115         <span class="comment">/* find the region of connected point and ~equal angle */</span>
02116         <a class="code" href="lsd_8c.html#a50">region_grow</a>( list_p-&gt;x, list_p-&gt;y, angles, reg, &amp;reg_size,
02117                      &amp;reg_angle, used, prec );
02118 
02119         <span class="comment">/* reject small regions */</span>
02120         <span class="keywordflow">if</span>( reg_size &lt; min_reg_size ) <span class="keywordflow">continue</span>;
02121 
02122         <span class="comment">/* construct rectangular approximation for the region */</span>
02123         <a class="code" href="lsd_8c.html#a49">region2rect</a>(reg,reg_size,modgrad,reg_angle,prec,p,&amp;rec);
02124 
02125         <span class="comment">/* Check if the rectangle exceeds the minimal density of</span>
02126 <span class="comment">           region points. If not, try to improve the region.</span>
02127 <span class="comment">           The rectangle will be rejected if the final one does</span>
02128 <span class="comment">           not fulfill the minimal density condition.</span>
02129 <span class="comment">           This is an addition to the original LSD algorithm published in</span>
02130 <span class="comment">           "LSD: A Fast Line Segment Detector with a False Detection Control"</span>
02131 <span class="comment">           by R. Grompone von Gioi, J. Jakubowicz, J.M. Morel, and G. Randall.</span>
02132 <span class="comment">           The original algorithm is obtained with density_th = 0.0.</span>
02133 <span class="comment">         */</span>
02134         <span class="keywordflow">if</span>( !<a class="code" href="lsd_8c.html#a53">refine</a>( reg, &amp;reg_size, modgrad, reg_angle,
02135                      prec, p, &amp;rec, used, angles, density_th ) ) <span class="keywordflow">continue</span>;
02136 
02137         <span class="comment">/* compute NFA value */</span>
02138         log_nfa = <a class="code" href="lsd_8c.html#a51">rect_improve</a>(&amp;rec,angles,logNT,log_eps);
02139         <span class="keywordflow">if</span>( log_nfa &lt;= log_eps ) <span class="keywordflow">continue</span>;
02140 
02141         <span class="comment">/* A New Line Segment was found! */</span>
02142         ++ls_count;  <span class="comment">/* increase line segment counter */</span>
02143 
02144         <span class="comment">/*</span>
02145 <span class="comment">           The gradient was computed with a 2x2 mask, its value corresponds to</span>
02146 <span class="comment">           points with an offset of (0.5,0.5), that should be added to output.</span>
02147 <span class="comment">           The coordinates origin is at the center of pixel (0,0).</span>
02148 <span class="comment">         */</span>
02149         rec.<a class="code" href="structrect.html#o0">x1</a> += 0.5; rec.<a class="code" href="structrect.html#o1">y1</a> += 0.5;
02150         rec.<a class="code" href="structrect.html#o2">x2</a> += 0.5; rec.<a class="code" href="structrect.html#o3">y2</a> += 0.5;
02151 
02152         <span class="comment">/* scale the result values if a subsampling was performed */</span>
02153         <span class="keywordflow">if</span>( scale != 1.0 )
02154           {
02155             rec.<a class="code" href="structrect.html#o0">x1</a> /= scale; rec.<a class="code" href="structrect.html#o1">y1</a> /= scale;
02156             rec.<a class="code" href="structrect.html#o2">x2</a> /= scale; rec.<a class="code" href="structrect.html#o3">y2</a> /= scale;
02157             rec.<a class="code" href="structrect.html#o4">width</a> /= scale;
02158           }
02159 
02160         <span class="comment">/* add line segment found to output */</span>
02161         <a class="code" href="lsd_8c.html#a22">add_7tuple</a>( out, rec.<a class="code" href="structrect.html#o0">x1</a>, rec.<a class="code" href="structrect.html#o1">y1</a>, rec.<a class="code" href="structrect.html#o2">x2</a>, rec.<a class="code" href="structrect.html#o3">y2</a>,
02162                          rec.<a class="code" href="structrect.html#o4">width</a>, rec.<a class="code" href="structrect.html#o11">p</a>, log_nfa );
02163 
02164         <span class="comment">/* add region number to 'region' image if needed */</span>
02165         <span class="keywordflow">if</span>( region != NULL )
02166           <span class="keywordflow">for</span>(i=0; i&lt;reg_size; i++)
02167             region-&gt;<a class="code" href="structimage__int__s.html#o0">data</a>[ reg[i].x + reg[i].y * region-&gt;<a class="code" href="structimage__int__s.html#o1">xsize</a> ] = ls_count;
02168       }
02169 
02170 
02171   <span class="comment">/* free memory */</span>
02172   free( (<span class="keywordtype">void</span> *) image );   <span class="comment">/* only the double_image structure should be freed,</span>
02173 <span class="comment">                               the data pointer was provided to this functions</span>
02174 <span class="comment">                               and should not be destroyed.                 */</span>
02175   <a class="code" href="lsd_8c.html#a28">free_image_double</a>(angles);
02176   <a class="code" href="lsd_8c.html#a28">free_image_double</a>(modgrad);
02177   <a class="code" href="lsd_8c.html#a23">free_image_char</a>(used);
02178   free( (<span class="keywordtype">void</span> *) reg );
02179   free( (<span class="keywordtype">void</span> *) mem_p );
02180 
02181   <span class="comment">/* return the result */</span>
02182   <span class="keywordflow">if</span>( reg_img != NULL &amp;&amp; reg_x != NULL &amp;&amp; reg_y != NULL )
02183     {
02184       <span class="keywordflow">if</span>( region == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"'region' should be a valid image."</span>);
02185       *reg_img = region-&gt;<a class="code" href="structimage__int__s.html#o0">data</a>;
02186       <span class="keywordflow">if</span>( region-&gt;<a class="code" href="structimage__int__s.html#o1">xsize</a> &gt; (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>) INT_MAX ||
02187           region-&gt;<a class="code" href="structimage__int__s.html#o1">xsize</a> &gt; (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>) INT_MAX )
02188         <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"region image to big to fit in INT sizes."</span>);
02189       *reg_x = (<span class="keywordtype">int</span>) (region-&gt;<a class="code" href="structimage__int__s.html#o1">xsize</a>);
02190       *reg_y = (<span class="keywordtype">int</span>) (region-&gt;<a class="code" href="structimage__int__s.html#o2">ysize</a>);
02191 
02192       <span class="comment">/* free the 'region' structure.</span>
02193 <span class="comment">         we cannot use the function 'free_image_int' because we need to keep</span>
02194 <span class="comment">         the memory with the image data to be returned by this function. */</span>
02195       free( (<span class="keywordtype">void</span> *) region );
02196     }
02197   <span class="keywordflow">if</span>( out-&gt;<a class="code" href="structntuple__list__s.html#o0">size</a> &gt; (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>) INT_MAX )
02198     <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"too many detections to fit in an INT."</span>);
02199   *n_out = (<span class="keywordtype">int</span>) (out-&gt;<a class="code" href="structntuple__list__s.html#o0">size</a>);
02200 
02201   return_value = out-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a>;
02202   free( (<span class="keywordtype">void</span> *) out );  <span class="comment">/* only the 'ntuple_list' structure must be freed,</span>
02203 <span class="comment">                            but the 'values' pointer must be keep to return</span>
02204 <span class="comment">                            as a result. */</span>
02205 
02206   <span class="keywordflow">return</span> return_value;
02207 }
02208 
02209 <span class="comment">/*----------------------------------------------------------------------------*/</span><span class="comment"></span>
02210 <span class="comment">/** LSD Simple Interface with Scale and Region output.</span>
02211 <span class="comment"> */</span>
<a name="l02212"></a><a class="code" href="lsd_8c.html#a55">02212</a> <span class="keywordtype">double</span> * <a class="code" href="lsd_8c.html#a55">lsd_scale_region</a>( <span class="keywordtype">int</span> * n_out,
02213                            <span class="keywordtype">double</span> * img, <span class="keywordtype">int</span> X, <span class="keywordtype">int</span> Y, <span class="keywordtype">double</span> scale,
02214                            <span class="keywordtype">int</span> ** reg_img, <span class="keywordtype">int</span> * reg_x, <span class="keywordtype">int</span> * reg_y )
02215 {
02216   <span class="comment">/* LSD parameters */</span>
02217   <span class="keywordtype">double</span> sigma_scale = 0.6; <span class="comment">/* Sigma for Gaussian filter is computed as</span>
02218 <span class="comment">                                sigma = sigma_scale/scale.                    */</span>
02219   <span class="keywordtype">double</span> quant = 2.0;       <span class="comment">/* Bound to the quantization error on the</span>
02220 <span class="comment">                                gradient norm.                                */</span>
02221   <span class="keywordtype">double</span> ang_th = 22.5;     <span class="comment">/* Gradient angle tolerance in degrees.           */</span>
02222   <span class="keywordtype">double</span> log_eps = 0.0;     <span class="comment">/* Detection threshold: -log10(NFA) &gt; log_eps     */</span>
02223   <span class="keywordtype">double</span> density_th = 0.7;  <span class="comment">/* Minimal density of region points in rectangle. */</span>
02224   <span class="keywordtype">int</span> n_bins = 1024;        <span class="comment">/* Number of bins in pseudo-ordering of gradient</span>
02225 <span class="comment">                               modulus.                                       */</span>
02226 
02227   <span class="keywordflow">return</span> <a class="code" href="lsd_8c.html#a54">LineSegmentDetection</a>( n_out, img, X, Y, scale, sigma_scale, quant,
02228                                ang_th, log_eps, density_th, n_bins,
02229                                reg_img, reg_x, reg_y );
02230 }
02231 
02232 <span class="comment">/*----------------------------------------------------------------------------*/</span><span class="comment"></span>
02233 <span class="comment">/** LSD Simple Interface with Scale.</span>
02234 <span class="comment"> */</span>
<a name="l02235"></a><a class="code" href="lsd_8c.html#a56">02235</a> <span class="keywordtype">double</span> * <a class="code" href="lsd_8c.html#a56">lsd_scale</a>(<span class="keywordtype">int</span> * n_out, <span class="keywordtype">double</span> * img, <span class="keywordtype">int</span> X, <span class="keywordtype">int</span> Y, <span class="keywordtype">double</span> scale)
02236 {
02237   <span class="keywordflow">return</span> <a class="code" href="lsd_8c.html#a55">lsd_scale_region</a>(n_out,img,X,Y,scale,NULL,NULL,NULL);
02238 }
02239 
02240 <span class="comment">/*----------------------------------------------------------------------------*/</span><span class="comment"></span>
02241 <span class="comment">/** LSD Simple Interface.</span>
02242 <span class="comment"> */</span>
<a name="l02243"></a><a class="code" href="lsd_8c.html#a57">02243</a> <span class="keywordtype">double</span> * <a class="code" href="lsd_8c.html#a57">lsd</a>(<span class="keywordtype">int</span> * n_out, <span class="keywordtype">double</span> * img, <span class="keywordtype">int</span> X, <span class="keywordtype">int</span> Y)
02244 {
02245   <span class="comment">/* LSD parameters */</span>
02246   <span class="keywordtype">double</span> scale = 0.8;       <span class="comment">/* Scale the image by Gaussian filter to 'scale'. */</span>
02247 
02248   <span class="keywordflow">return</span> <a class="code" href="lsd_8c.html#a56">lsd_scale</a>(n_out,img,X,Y,scale);
02249 }
02250 <span class="comment">/*----------------------------------------------------------------------------*/</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Fri Nov 11 11:11:11 2011 for LSD by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.4 </small></address>
</body>
</html>
