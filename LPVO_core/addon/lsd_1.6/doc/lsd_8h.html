<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>LSD: lsd.h File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a></div>
<h1>lsd.h File Reference</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
LSD module header. 
<p>
<dl compact><dt><b>Author:</b></dt><dd>rafael grompone von gioi &lt;<a href="mailto:grompone@gmail.com">grompone@gmail.com</a>&gt;</dd></dl>

<p>
Definition in file <a class="el" href="lsd_8h-source.html">lsd.h</a>.
<p>

<p>
This graph shows which files directly or indirectly include this file:<p><center><img src="lsd_8h__dep__incl.png" border="0" usemap="#lsd.hdep_map" alt="Included by dependency graph"></center>
<map name="lsd.hdep_map">
<area href="lsd_8c.html" shape="rect" coords="9,7,57,34" alt="">
</map>

<p>
<a href="lsd_8h-source.html">Go to the source code of this file.</a><table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>double *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8h.html#a0">LineSegmentDetection</a> (int *n_out, double *img, int X, int Y, double scale, double sigma_scale, double quant, double ang_th, double log_eps, double density_th, int n_bins, int **reg_img, int *reg_x, int *reg_y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">LSD Full Interface. </em> <a href="#a0"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>double *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8h.html#a1">lsd_scale_region</a> (int *n_out, double *img, int X, int Y, double scale, int **reg_img, int *reg_x, int *reg_y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">LSD Simple Interface with Scale and Region output. </em> <a href="#a1"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>double *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8h.html#a2">lsd_scale</a> (int *n_out, double *img, int X, int Y, double scale)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">LSD Simple Interface with Scale. </em> <a href="#a2"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>double *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8h.html#a3">lsd</a> (int *n_out, double *img, int X, int Y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">LSD Simple Interface. </em> <a href="#a3"></a><em><br><br></td></tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="a0" doxytag="lsd.h::LineSegmentDetection" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> double* LineSegmentDetection </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int *&nbsp;</td>
          <td class="mdname" nowrap> <em>n_out</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap> <em>img</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>X</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>Y</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>scale</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>sigma_scale</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>quant</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>ang_th</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>log_eps</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>density_th</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>n_bins</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int **&nbsp;</td>
          <td class="mdname" nowrap> <em>reg_img</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>reg_x</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>reg_y</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
LSD Full Interface. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>n_out</em>&nbsp;</td><td>Pointer to an int where LSD will store the number of line segments detected.</td></tr>
    <tr><td valign=top><em>img</em>&nbsp;</td><td>Pointer to input image data. It must be an array of doubles of size X x Y, and the pixel at coordinates (x,y) is obtained by img[x+y*X].</td></tr>
    <tr><td valign=top><em>X</em>&nbsp;</td><td>X size of the image: the number of columns.</td></tr>
    <tr><td valign=top><em>Y</em>&nbsp;</td><td>Y size of the image: the number of rows.</td></tr>
    <tr><td valign=top><em>scale</em>&nbsp;</td><td>When different from 1.0, LSD will scale the input image by 'scale' factor by Gaussian filtering, before detecting line segments. Example: if scale=0.8, the input image will be subsampled to 80% of its size, before the line segment detector is applied. Suggested value: 0.8</td></tr>
    <tr><td valign=top><em>sigma_scale</em>&nbsp;</td><td>When scale!=1.0, the sigma of the Gaussian filter is: sigma = sigma_scale / scale, if scale &lt; 1.0 sigma = sigma_scale, if scale &gt;= 1.0 Suggested value: 0.6</td></tr>
    <tr><td valign=top><em>quant</em>&nbsp;</td><td>Bound to the quantization error on the gradient norm. Example: if gray levels are quantized to integer steps, the gradient (computed by finite differences) error due to quantization will be bounded by 2.0, as the worst case is when the error are 1 and -1, that gives an error of 2.0. Suggested value: 2.0</td></tr>
    <tr><td valign=top><em>ang_th</em>&nbsp;</td><td>Gradient angle tolerance in the region growing algorithm, in degrees. Suggested value: 22.5</td></tr>
    <tr><td valign=top><em>log_eps</em>&nbsp;</td><td>Detection threshold, accept if -log10(NFA) &gt; log_eps. The larger the value, the more strict the detector is, and will result in less detections. (Note that the 'minus sign' makes that this behavior is opposite to the one of NFA.) The value -log10(NFA) is equivalent but more intuitive than NFA:<ul>
<li>-1.0 gives an average of 10 false detections on noise</li><li>0.0 gives an average of 1 false detections on noise</li><li>1.0 gives an average of 0.1 false detections on nose</li><li>2.0 gives an average of 0.01 false detections on noise</li></ul>
Suggested value: 0.0</td></tr>
    <tr><td valign=top><em>density_th</em>&nbsp;</td><td>Minimal proportion of 'supporting' points in a rectangle. Suggested value: 0.7</td></tr>
    <tr><td valign=top><em>n_bins</em>&nbsp;</td><td>Number of bins used in the pseudo-ordering of gradient modulus. Suggested value: 1024</td></tr>
    <tr><td valign=top><em>reg_img</em>&nbsp;</td><td>Optional output: if desired, LSD will return an int image where each pixel indicates the line segment to which it belongs. Unused pixels have the value '0', while the used ones have the number of the line segment, numbered 1,2,3,..., in the same order as in the output list. If desired, a non NULL int** pointer must be assigned, and LSD will make that the pointer point to an int array of size reg_x x reg_y, where the pixel value at (x,y) is obtained with (*reg_img)[x+y*reg_x]. Note that the resulting image has the size of the image used for the processing, that is, the size of the input image scaled by the given factor 'scale'. If scale!=1 this size differs from XxY and that is the reason why its value is given by reg_x and reg_y. Suggested value: NULL</td></tr>
    <tr><td valign=top><em>reg_x</em>&nbsp;</td><td>Pointer to an int where LSD will put the X size 'reg_img' image, when asked for. Suggested value: NULL</td></tr>
    <tr><td valign=top><em>reg_y</em>&nbsp;</td><td>Pointer to an int where LSD will put the Y size 'reg_img' image, when asked for. Suggested value: NULL</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A double array of size 7 x n_out, containing the list of line segments detected. The array contains first 7 values of line segment number 1, then the 7 values of line segment number 2, and so on, and it finish by the 7 values of line segment number n_out. The seven values are:<ul>
<li>x1,y1,x2,y2,width,p,-log10(NFA)</li></ul>
for a line segment from coordinates (x1,y1) to (x2,y2), a width 'width', an angle precision of p in (0,1) given by angle_tolerance/180 degree, and NFA value 'NFA'. If 'out' is the returned pointer, the 7 values of line segment number 'n+1' are obtained with 'out[7*n+0]' to 'out[7*n+6]'. </dd></dl>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l02025">2025</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8c-source.html#l00305">add_7tuple()</a>, <a class="el" href="lsd_8c-source.html#l00345">image_char_s::data</a>, <a class="el" href="lsd_8c-source.html#l00471">image_double_s::data</a>, <a class="el" href="lsd_8c-source.html#l00416">image_int_s::data</a>, <a class="el" href="lsd_8c-source.html#l00159">error()</a>, <a class="el" href="lsd_8c-source.html#l00352">free_image_char()</a>, <a class="el" href="lsd_8c-source.html#l00478">free_image_double()</a>, <a class="el" href="lsd_8c-source.html#l00611">gaussian_sampler()</a>, <a class="el" href="lsd_8c.html#a13">image_char</a>, <a class="el" href="lsd_8c.html#a15">image_double</a>, <a class="el" href="lsd_8c.html#a14">image_int</a>, <a class="el" href="lsd_8c-source.html#l00752">ll_angle()</a>, <a class="el" href="lsd_8c-source.html#l00111">M_PI</a>, <a class="el" href="lsd_8c-source.html#l00388">new_image_char_ini()</a>, <a class="el" href="lsd_8c-source.html#l00513">new_image_double_ptr()</a>, <a class="el" href="lsd_8c-source.html#l00447">new_image_int_ini()</a>, <a class="el" href="lsd_8c-source.html#l00261">new_ntuple_list()</a>, <a class="el" href="lsd_8c-source.html#l00123">NOTDEF</a>, <a class="el" href="lsd_8c-source.html#l00132">NOTUSED</a>, <a class="el" href="lsd_8c.html#a12">ntuple_list</a>, <a class="el" href="lsd_8c-source.html#l01177">rect::p</a>, <a class="el" href="lsd_8c-source.html#l01756">rect_improve()</a>, <a class="el" href="lsd_8c-source.html#l01947">refine()</a>, <a class="el" href="lsd_8c-source.html#l01611">region2rect()</a>, <a class="el" href="lsd_8c-source.html#l01704">region_grow()</a>, <a class="el" href="lsd_8c-source.html#l00240">ntuple_list_s::size</a>, <a class="el" href="lsd_8c-source.html#l00243">ntuple_list_s::values</a>, <a class="el" href="lsd_8c-source.html#l01172">rect::width</a>, <a class="el" href="lsd_8c-source.html#l01171">rect::x1</a>, <a class="el" href="lsd_8c-source.html#l01171">rect::x2</a>, <a class="el" href="lsd_8c-source.html#l00472">image_double_s::xsize</a>, <a class="el" href="lsd_8c-source.html#l00346">image_char_s::xsize</a>, <a class="el" href="lsd_8c-source.html#l00417">image_int_s::xsize</a>, <a class="el" href="lsd_8c-source.html#l01171">rect::y1</a>, <a class="el" href="lsd_8c-source.html#l01171">rect::y2</a>, <a class="el" href="lsd_8c-source.html#l00472">image_double_s::ysize</a>, and <a class="el" href="lsd_8c-source.html#l00417">image_int_s::ysize</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l02212">lsd_scale_region()</a>.
<p>
<div class="fragment"><pre>02031 {
02032   <a class="code" href="structimage__double__s.html">image_double</a> image;
02033   <a class="code" href="structntuple__list__s.html">ntuple_list</a> out = <a class="code" href="lsd_8c.html#a20">new_ntuple_list</a>(7);
02034   <span class="keywordtype">double</span> * return_value;
02035   <a class="code" href="structimage__double__s.html">image_double</a> scaled_image,angles,modgrad;
02036   <a class="code" href="structimage__char__s.html">image_char</a> used;
02037   <a class="code" href="structimage__int__s.html">image_int</a> region = NULL;
02038   <span class="keyword">struct </span><a class="code" href="structcoorlist.html">coorlist</a> * list_p;
02039   <span class="keywordtype">void</span> * mem_p;
02040   <span class="keyword">struct </span><a class="code" href="structrect.html">rect</a> rec;
02041   <span class="keyword">struct </span><a class="code" href="structpoint.html">point</a> * reg;
02042   <span class="keywordtype">int</span> reg_size,min_reg_size,i;
02043   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> xsize,ysize;
02044   <span class="keywordtype">double</span> rho,reg_angle,prec,p,log_nfa,logNT;
02045   <span class="keywordtype">int</span> ls_count = 0;                   <span class="comment">/* line segments are numbered 1,2,3,... */</span>
02046 
02047 
02048   <span class="comment">/* check parameters */</span>
02049   <span class="keywordflow">if</span>( img == NULL || X &lt;= 0 || Y &lt;= 0 ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"invalid image input."</span>);
02050   <span class="keywordflow">if</span>( scale &lt;= 0.0 ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"'scale' value must be positive."</span>);
02051   <span class="keywordflow">if</span>( sigma_scale &lt;= 0.0 ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"'sigma_scale' value must be positive."</span>);
02052   <span class="keywordflow">if</span>( quant &lt; 0.0 ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"'quant' value must be positive."</span>);
02053   <span class="keywordflow">if</span>( ang_th &lt;= 0.0 || ang_th &gt;= 180.0 )
02054     <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"'ang_th' value must be in the range (0,180)."</span>);
02055   <span class="keywordflow">if</span>( density_th &lt; 0.0 || density_th &gt; 1.0 )
02056     <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"'density_th' value must be in the range [0,1]."</span>);
02057   <span class="keywordflow">if</span>( n_bins &lt;= 0 ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"'n_bins' value must be positive."</span>);
02058 
02059 
02060   <span class="comment">/* angle tolerance */</span>
02061   prec = <a class="code" href="lsd_8c.html#a1">M_PI</a> * ang_th / 180.0;
02062   p = ang_th / 180.0;
02063   rho = quant / sin(prec); <span class="comment">/* gradient magnitude threshold */</span>
02064 
02065 
02066   <span class="comment">/* load and scale image (if necessary) and compute angle at each pixel */</span>
02067   image = <a class="code" href="lsd_8c.html#a30">new_image_double_ptr</a>( (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>) X, (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>) Y, img );
02068   <span class="keywordflow">if</span>( scale != 1.0 )
02069     {
02070       scaled_image = <a class="code" href="lsd_8c.html#a32">gaussian_sampler</a>( image, scale, sigma_scale );
02071       angles = <a class="code" href="lsd_8c.html#a33">ll_angle</a>( scaled_image, rho, &amp;list_p, &amp;mem_p,
02072                          &amp;modgrad, (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>) n_bins );
02073       <a class="code" href="lsd_8c.html#a28">free_image_double</a>(scaled_image);
02074     }
02075   <span class="keywordflow">else</span>
02076     angles = <a class="code" href="lsd_8c.html#a33">ll_angle</a>( image, rho, &amp;list_p, &amp;mem_p, &amp;modgrad,
02077                        (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>) n_bins );
02078   xsize = angles-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a>;
02079   ysize = angles-&gt;<a class="code" href="structimage__double__s.html#o2">ysize</a>;
02080 
02081   <span class="comment">/* Number of Tests - NT</span>
02082 <span class="comment"></span>
02083 <span class="comment">     The theoretical number of tests is Np.(XY)^(5/2)</span>
02084 <span class="comment">     where X and Y are number of columns and rows of the image.</span>
02085 <span class="comment">     Np corresponds to the number of angle precisions considered.</span>
02086 <span class="comment">     As the procedure 'rect_improve' tests 5 times to halve the</span>
02087 <span class="comment">     angle precision, and 5 more times after improving other factors,</span>
02088 <span class="comment">     11 different precision values are potentially tested. Thus,</span>
02089 <span class="comment">     the number of tests is</span>
02090 <span class="comment">       11 * (X*Y)^(5/2)</span>
02091 <span class="comment">     whose logarithm value is</span>
02092 <span class="comment">       log10(11) + 5/2 * (log10(X) + log10(Y)).</span>
02093 <span class="comment">  */</span>
02094   logNT = 5.0 * ( log10( (<span class="keywordtype">double</span>) xsize ) + log10( (<span class="keywordtype">double</span>) ysize ) ) / 2.0
02095           + log10(11.0);
02096   min_reg_size = (<span class="keywordtype">int</span>) (-logNT/log10(p)); <span class="comment">/* minimal number of points in region</span>
02097 <span class="comment">                                             that can give a meaningful event */</span>
02098 
02099 
02100   <span class="comment">/* initialize some structures */</span>
02101   <span class="keywordflow">if</span>( reg_img != NULL &amp;&amp; reg_x != NULL &amp;&amp; reg_y != NULL ) <span class="comment">/* save region data */</span>
02102     region = <a class="code" href="lsd_8c.html#a27">new_image_int_ini</a>(angles-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a>,angles-&gt;<a class="code" href="structimage__double__s.html#o2">ysize</a>,0);
02103   used = <a class="code" href="lsd_8c.html#a25">new_image_char_ini</a>(xsize,ysize,NOTUSED);
02104   reg = (<span class="keyword">struct </span><a class="code" href="structpoint.html">point</a> *) calloc( (size_t) (xsize*ysize), <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structpoint.html">point</a>) );
02105   <span class="keywordflow">if</span>( reg == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"not enough memory!"</span>);
02106 
02107 
02108   <span class="comment">/* search for line segments */</span>
02109   <span class="keywordflow">for</span>(; list_p != NULL; list_p = list_p-&gt;next )
02110     <span class="keywordflow">if</span>( used-&gt;<a class="code" href="structimage__char__s.html#o0">data</a>[ list_p-&gt;x + list_p-&gt;y * used-&gt;<a class="code" href="structimage__char__s.html#o1">xsize</a> ] == <a class="code" href="lsd_8c.html#a7">NOTUSED</a> &amp;&amp;
02111         angles-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>[ list_p-&gt;x + list_p-&gt;y * angles-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a> ] != <a class="code" href="lsd_8c.html#a4">NOTDEF</a> )
02112        <span class="comment">/* there is no risk of double comparison problems here</span>
02113 <span class="comment">          because we are only interested in the exact NOTDEF value */</span>
02114       {
02115         <span class="comment">/* find the region of connected point and ~equal angle */</span>
02116         <a class="code" href="lsd_8c.html#a50">region_grow</a>( list_p-&gt;x, list_p-&gt;y, angles, reg, &amp;reg_size,
02117                      &amp;reg_angle, used, prec );
02118 
02119         <span class="comment">/* reject small regions */</span>
02120         <span class="keywordflow">if</span>( reg_size &lt; min_reg_size ) <span class="keywordflow">continue</span>;
02121 
02122         <span class="comment">/* construct rectangular approximation for the region */</span>
02123         <a class="code" href="lsd_8c.html#a49">region2rect</a>(reg,reg_size,modgrad,reg_angle,prec,p,&amp;rec);
02124 
02125         <span class="comment">/* Check if the rectangle exceeds the minimal density of</span>
02126 <span class="comment">           region points. If not, try to improve the region.</span>
02127 <span class="comment">           The rectangle will be rejected if the final one does</span>
02128 <span class="comment">           not fulfill the minimal density condition.</span>
02129 <span class="comment">           This is an addition to the original LSD algorithm published in</span>
02130 <span class="comment">           "LSD: A Fast Line Segment Detector with a False Detection Control"</span>
02131 <span class="comment">           by R. Grompone von Gioi, J. Jakubowicz, J.M. Morel, and G. Randall.</span>
02132 <span class="comment">           The original algorithm is obtained with density_th = 0.0.</span>
02133 <span class="comment">         */</span>
02134         <span class="keywordflow">if</span>( !<a class="code" href="lsd_8c.html#a53">refine</a>( reg, &amp;reg_size, modgrad, reg_angle,
02135                      prec, p, &amp;rec, used, angles, density_th ) ) <span class="keywordflow">continue</span>;
02136 
02137         <span class="comment">/* compute NFA value */</span>
02138         log_nfa = <a class="code" href="lsd_8c.html#a51">rect_improve</a>(&amp;rec,angles,logNT,log_eps);
02139         <span class="keywordflow">if</span>( log_nfa &lt;= log_eps ) <span class="keywordflow">continue</span>;
02140 
02141         <span class="comment">/* A New Line Segment was found! */</span>
02142         ++ls_count;  <span class="comment">/* increase line segment counter */</span>
02143 
02144         <span class="comment">/*</span>
02145 <span class="comment">           The gradient was computed with a 2x2 mask, its value corresponds to</span>
02146 <span class="comment">           points with an offset of (0.5,0.5), that should be added to output.</span>
02147 <span class="comment">           The coordinates origin is at the center of pixel (0,0).</span>
02148 <span class="comment">         */</span>
02149         rec.<a class="code" href="structrect.html#o0">x1</a> += 0.5; rec.<a class="code" href="structrect.html#o1">y1</a> += 0.5;
02150         rec.<a class="code" href="structrect.html#o2">x2</a> += 0.5; rec.<a class="code" href="structrect.html#o3">y2</a> += 0.5;
02151 
02152         <span class="comment">/* scale the result values if a subsampling was performed */</span>
02153         <span class="keywordflow">if</span>( scale != 1.0 )
02154           {
02155             rec.<a class="code" href="structrect.html#o0">x1</a> /= scale; rec.<a class="code" href="structrect.html#o1">y1</a> /= scale;
02156             rec.<a class="code" href="structrect.html#o2">x2</a> /= scale; rec.<a class="code" href="structrect.html#o3">y2</a> /= scale;
02157             rec.<a class="code" href="structrect.html#o4">width</a> /= scale;
02158           }
02159 
02160         <span class="comment">/* add line segment found to output */</span>
02161         <a class="code" href="lsd_8c.html#a22">add_7tuple</a>( out, rec.<a class="code" href="structrect.html#o0">x1</a>, rec.<a class="code" href="structrect.html#o1">y1</a>, rec.<a class="code" href="structrect.html#o2">x2</a>, rec.<a class="code" href="structrect.html#o3">y2</a>,
02162                          rec.<a class="code" href="structrect.html#o4">width</a>, rec.<a class="code" href="structrect.html#o11">p</a>, log_nfa );
02163 
02164         <span class="comment">/* add region number to 'region' image if needed */</span>
02165         <span class="keywordflow">if</span>( region != NULL )
02166           <span class="keywordflow">for</span>(i=0; i&lt;reg_size; i++)
02167             region-&gt;<a class="code" href="structimage__int__s.html#o0">data</a>[ reg[i].x + reg[i].y * region-&gt;<a class="code" href="structimage__int__s.html#o1">xsize</a> ] = ls_count;
02168       }
02169 
02170 
02171   <span class="comment">/* free memory */</span>
02172   free( (<span class="keywordtype">void</span> *) image );   <span class="comment">/* only the double_image structure should be freed,</span>
02173 <span class="comment">                               the data pointer was provided to this functions</span>
02174 <span class="comment">                               and should not be destroyed.                 */</span>
02175   <a class="code" href="lsd_8c.html#a28">free_image_double</a>(angles);
02176   <a class="code" href="lsd_8c.html#a28">free_image_double</a>(modgrad);
02177   <a class="code" href="lsd_8c.html#a23">free_image_char</a>(used);
02178   free( (<span class="keywordtype">void</span> *) reg );
02179   free( (<span class="keywordtype">void</span> *) mem_p );
02180 
02181   <span class="comment">/* return the result */</span>
02182   <span class="keywordflow">if</span>( reg_img != NULL &amp;&amp; reg_x != NULL &amp;&amp; reg_y != NULL )
02183     {
02184       <span class="keywordflow">if</span>( region == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"'region' should be a valid image."</span>);
02185       *reg_img = region-&gt;<a class="code" href="structimage__int__s.html#o0">data</a>;
02186       <span class="keywordflow">if</span>( region-&gt;<a class="code" href="structimage__int__s.html#o1">xsize</a> &gt; (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>) INT_MAX ||
02187           region-&gt;<a class="code" href="structimage__int__s.html#o1">xsize</a> &gt; (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>) INT_MAX )
02188         <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"region image to big to fit in INT sizes."</span>);
02189       *reg_x = (<span class="keywordtype">int</span>) (region-&gt;<a class="code" href="structimage__int__s.html#o1">xsize</a>);
02190       *reg_y = (<span class="keywordtype">int</span>) (region-&gt;<a class="code" href="structimage__int__s.html#o2">ysize</a>);
02191 
02192       <span class="comment">/* free the 'region' structure.</span>
02193 <span class="comment">         we cannot use the function 'free_image_int' because we need to keep</span>
02194 <span class="comment">         the memory with the image data to be returned by this function. */</span>
02195       free( (<span class="keywordtype">void</span> *) region );
02196     }
02197   <span class="keywordflow">if</span>( out-&gt;<a class="code" href="structntuple__list__s.html#o0">size</a> &gt; (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>) INT_MAX )
02198     <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"too many detections to fit in an INT."</span>);
02199   *n_out = (<span class="keywordtype">int</span>) (out-&gt;<a class="code" href="structntuple__list__s.html#o0">size</a>);
02200 
02201   return_value = out-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a>;
02202   free( (<span class="keywordtype">void</span> *) out );  <span class="comment">/* only the 'ntuple_list' structure must be freed,</span>
02203 <span class="comment">                            but the 'values' pointer must be keep to return</span>
02204 <span class="comment">                            as a result. */</span>
02205 
02206   <span class="keywordflow">return</span> return_value;
02207 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8h_a0_cgraph.png" border="0" usemap="#lsd_8h_a0_cgraph_map" alt=""></center>
<map name="lsd_8h_a0_cgraph_map">
<area href="lsd_8c.html#a22" shape="rect" coords="449,7,537,34" alt="">
<area href="lsd_8c.html#a16" shape="rect" coords="610,286,661,313" alt="">
<area href="lsd_8c.html#a23" shape="rect" coords="431,109,554,135" alt="">
<area href="lsd_8c.html#a28" shape="rect" coords="425,159,561,186" alt="">
<area href="lsd_8c.html#a32" shape="rect" coords="229,210,359,237" alt="">
<area href="lsd_8c.html#a20" shape="rect" coords="435,261,550,287" alt="">
<area href="lsd_8c.html#a33" shape="rect" coords="459,311,526,338" alt="">
<area href="lsd_8c.html#a25" shape="rect" coords="222,362,366,389" alt="">
<area href="lsd_8c.html#a30" shape="rect" coords="214,413,374,439" alt="">
<area href="lsd_8c.html#a27" shape="rect" coords="227,463,361,490" alt="">
<area href="lsd_8c.html#a51" shape="rect" coords="245,514,343,541" alt="">
<area href="lsd_8c.html#a53" shape="rect" coords="266,615,322,642" alt="">
<area href="lsd_8c.html#a49" shape="rect" coords="449,539,537,566" alt="">
<area href="lsd_8c.html#a50" shape="rect" coords="446,641,539,667" alt="">
</map>
<a class="anchor" name="a3" doxytag="lsd.h::lsd" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> double* lsd </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int *&nbsp;</td>
          <td class="mdname" nowrap> <em>n_out</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap> <em>img</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>X</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>Y</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
LSD Simple Interface. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>n_out</em>&nbsp;</td><td>Pointer to an int where LSD will store the number of line segments detected.</td></tr>
    <tr><td valign=top><em>img</em>&nbsp;</td><td>Pointer to input image data. It must be an array of doubles of size X x Y, and the pixel at coordinates (x,y) is obtained by img[x+y*X].</td></tr>
    <tr><td valign=top><em>X</em>&nbsp;</td><td>X size of the image: the number of columns.</td></tr>
    <tr><td valign=top><em>Y</em>&nbsp;</td><td>Y size of the image: the number of rows.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A double array of size 7 x n_out, containing the list of line segments detected. The array contains first 7 values of line segment number 1, then the 7 values of line segment number 2, and so on, and it finish by the 7 values of line segment number n_out. The seven values are:<ul>
<li>x1,y1,x2,y2,width,p,-log10(NFA)</li></ul>
for a line segment from coordinates (x1,y1) to (x2,y2), a width 'width', an angle precision of p in (0,1) given by angle_tolerance/180 degree, and NFA value 'NFA'. If 'out' is the returned pointer, the 7 values of line segment number 'n+1' are obtained with 'out[7*n+0]' to 'out[7*n+6]'. </dd></dl>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l02243">2243</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8c-source.html#l02235">lsd_scale()</a>.
<p>
<div class="fragment"><pre>02244 {
02245   <span class="comment">/* LSD parameters */</span>
02246   <span class="keywordtype">double</span> scale = 0.8;       <span class="comment">/* Scale the image by Gaussian filter to 'scale'. */</span>
02247 
02248   <span class="keywordflow">return</span> <a class="code" href="lsd_8c.html#a56">lsd_scale</a>(n_out,img,X,Y,scale);
02249 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8h_a3_cgraph.png" border="0" usemap="#lsd_8h_a3_cgraph_map" alt=""></center>
<map name="lsd_8h_a3_cgraph_map">
<area href="lsd_8c.html#a56" shape="rect" coords="95,8,173,34" alt="">
<area href="lsd_8c.html#a55" shape="rect" coords="221,8,343,34" alt="">
<area href="lsd_8c.html#a54" shape="rect" coords="391,8,549,34" alt="">
</map>
<a class="anchor" name="a2" doxytag="lsd.h::lsd_scale" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> double* lsd_scale </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int *&nbsp;</td>
          <td class="mdname" nowrap> <em>n_out</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap> <em>img</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>X</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>Y</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>scale</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
LSD Simple Interface with Scale. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>n_out</em>&nbsp;</td><td>Pointer to an int where LSD will store the number of line segments detected.</td></tr>
    <tr><td valign=top><em>img</em>&nbsp;</td><td>Pointer to input image data. It must be an array of doubles of size X x Y, and the pixel at coordinates (x,y) is obtained by img[x+y*X].</td></tr>
    <tr><td valign=top><em>X</em>&nbsp;</td><td>X size of the image: the number of columns.</td></tr>
    <tr><td valign=top><em>Y</em>&nbsp;</td><td>Y size of the image: the number of rows.</td></tr>
    <tr><td valign=top><em>scale</em>&nbsp;</td><td>When different from 1.0, LSD will scale the input image by 'scale' factor by Gaussian filtering, before detecting line segments. Example: if scale=0.8, the input image will be subsampled to 80% of its size, before the line segment detector is applied. Suggested value: 0.8</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A double array of size 7 x n_out, containing the list of line segments detected. The array contains first 7 values of line segment number 1, then the 7 values of line segment number 2, and so on, and it finish by the 7 values of line segment number n_out. The seven values are:<ul>
<li>x1,y1,x2,y2,width,p,-log10(NFA)</li></ul>
for a line segment from coordinates (x1,y1) to (x2,y2), a width 'width', an angle precision of p in (0,1) given by angle_tolerance/180 degree, and NFA value 'NFA'. If 'out' is the returned pointer, the 7 values of line segment number 'n+1' are obtained with 'out[7*n+0]' to 'out[7*n+6]'. </dd></dl>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l02235">2235</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8c-source.html#l02212">lsd_scale_region()</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l02243">lsd()</a>.
<p>
<div class="fragment"><pre>02236 {
02237   <span class="keywordflow">return</span> <a class="code" href="lsd_8c.html#a55">lsd_scale_region</a>(n_out,img,X,Y,scale,NULL,NULL,NULL);
02238 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8h_a2_cgraph.png" border="0" usemap="#lsd_8h_a2_cgraph_map" alt=""></center>
<map name="lsd_8h_a2_cgraph_map">
<area href="lsd_8c.html#a55" shape="rect" coords="133,337,255,363" alt="">
<area href="lsd_8c.html#a54" shape="rect" coords="303,337,461,363" alt="">
<area href="lsd_8c.html#a22" shape="rect" coords="745,7,833,34" alt="">
<area href="lsd_8c.html#a16" shape="rect" coords="906,286,957,313" alt="">
<area href="lsd_8c.html#a23" shape="rect" coords="727,109,850,135" alt="">
<area href="lsd_8c.html#a28" shape="rect" coords="721,159,857,186" alt="">
<area href="lsd_8c.html#a32" shape="rect" coords="525,210,655,237" alt="">
<area href="lsd_8c.html#a20" shape="rect" coords="731,261,846,287" alt="">
<area href="lsd_8c.html#a33" shape="rect" coords="755,311,822,338" alt="">
<area href="lsd_8c.html#a25" shape="rect" coords="518,362,662,389" alt="">
<area href="lsd_8c.html#a30" shape="rect" coords="510,413,670,439" alt="">
<area href="lsd_8c.html#a27" shape="rect" coords="523,463,657,490" alt="">
<area href="lsd_8c.html#a51" shape="rect" coords="541,514,639,541" alt="">
<area href="lsd_8c.html#a53" shape="rect" coords="562,615,618,642" alt="">
<area href="lsd_8c.html#a49" shape="rect" coords="745,539,833,566" alt="">
<area href="lsd_8c.html#a50" shape="rect" coords="742,641,835,667" alt="">
</map>
<a class="anchor" name="a1" doxytag="lsd.h::lsd_scale_region" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> double* lsd_scale_region </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int *&nbsp;</td>
          <td class="mdname" nowrap> <em>n_out</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap> <em>img</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>X</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>Y</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>scale</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int **&nbsp;</td>
          <td class="mdname" nowrap> <em>reg_img</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>reg_x</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>reg_y</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
LSD Simple Interface with Scale and Region output. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>n_out</em>&nbsp;</td><td>Pointer to an int where LSD will store the number of line segments detected.</td></tr>
    <tr><td valign=top><em>img</em>&nbsp;</td><td>Pointer to input image data. It must be an array of doubles of size X x Y, and the pixel at coordinates (x,y) is obtained by img[x+y*X].</td></tr>
    <tr><td valign=top><em>X</em>&nbsp;</td><td>X size of the image: the number of columns.</td></tr>
    <tr><td valign=top><em>Y</em>&nbsp;</td><td>Y size of the image: the number of rows.</td></tr>
    <tr><td valign=top><em>scale</em>&nbsp;</td><td>When different from 1.0, LSD will scale the input image by 'scale' factor by Gaussian filtering, before detecting line segments. Example: if scale=0.8, the input image will be subsampled to 80% of its size, before the line segment detector is applied. Suggested value: 0.8</td></tr>
    <tr><td valign=top><em>reg_img</em>&nbsp;</td><td>Optional output: if desired, LSD will return an int image where each pixel indicates the line segment to which it belongs. Unused pixels have the value '0', while the used ones have the number of the line segment, numbered 1,2,3,..., in the same order as in the output list. If desired, a non NULL int** pointer must be assigned, and LSD will make that the pointer point to an int array of size reg_x x reg_y, where the pixel value at (x,y) is obtained with (*reg_img)[x+y*reg_x]. Note that the resulting image has the size of the image used for the processing, that is, the size of the input image scaled by the given factor 'scale'. If scale!=1 this size differs from XxY and that is the reason why its value is given by reg_x and reg_y. Suggested value: NULL</td></tr>
    <tr><td valign=top><em>reg_x</em>&nbsp;</td><td>Pointer to an int where LSD will put the X size 'reg_img' image, when asked for. Suggested value: NULL</td></tr>
    <tr><td valign=top><em>reg_y</em>&nbsp;</td><td>Pointer to an int where LSD will put the Y size 'reg_img' image, when asked for. Suggested value: NULL</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A double array of size 7 x n_out, containing the list of line segments detected. The array contains first 7 values of line segment number 1, then the 7 values of line segment number 2, and so on, and it finish by the 7 values of line segment number n_out. The seven values are:<ul>
<li>x1,y1,x2,y2,width,p,-log10(NFA)</li></ul>
for a line segment from coordinates (x1,y1) to (x2,y2), a width 'width', an angle precision of p in (0,1) given by angle_tolerance/180 degree, and NFA value 'NFA'. If 'out' is the returned pointer, the 7 values of line segment number 'n+1' are obtained with 'out[7*n+0]' to 'out[7*n+6]'. </dd></dl>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l02212">2212</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8c-source.html#l02025">LineSegmentDetection()</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l02235">lsd_scale()</a>.
<p>
<div class="fragment"><pre>02215 {
02216   <span class="comment">/* LSD parameters */</span>
02217   <span class="keywordtype">double</span> sigma_scale = 0.6; <span class="comment">/* Sigma for Gaussian filter is computed as</span>
02218 <span class="comment">                                sigma = sigma_scale/scale.                    */</span>
02219   <span class="keywordtype">double</span> quant = 2.0;       <span class="comment">/* Bound to the quantization error on the</span>
02220 <span class="comment">                                gradient norm.                                */</span>
02221   <span class="keywordtype">double</span> ang_th = 22.5;     <span class="comment">/* Gradient angle tolerance in degrees.           */</span>
02222   <span class="keywordtype">double</span> log_eps = 0.0;     <span class="comment">/* Detection threshold: -log10(NFA) &gt; log_eps     */</span>
02223   <span class="keywordtype">double</span> density_th = 0.7;  <span class="comment">/* Minimal density of region points in rectangle. */</span>
02224   <span class="keywordtype">int</span> n_bins = 1024;        <span class="comment">/* Number of bins in pseudo-ordering of gradient</span>
02225 <span class="comment">                               modulus.                                       */</span>
02226 
02227   <span class="keywordflow">return</span> <a class="code" href="lsd_8c.html#a54">LineSegmentDetection</a>( n_out, img, X, Y, scale, sigma_scale, quant,
02228                                ang_th, log_eps, density_th, n_bins,
02229                                reg_img, reg_x, reg_y );
02230 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8h_a1_cgraph.png" border="0" usemap="#lsd_8h_a1_cgraph_map" alt=""></center>
<map name="lsd_8h_a1_cgraph_map">
<area href="lsd_8c.html#a54" shape="rect" coords="178,337,336,363" alt="">
<area href="lsd_8c.html#a22" shape="rect" coords="620,7,708,34" alt="">
<area href="lsd_8c.html#a16" shape="rect" coords="781,286,832,313" alt="">
<area href="lsd_8c.html#a23" shape="rect" coords="602,109,725,135" alt="">
<area href="lsd_8c.html#a28" shape="rect" coords="596,159,732,186" alt="">
<area href="lsd_8c.html#a32" shape="rect" coords="400,210,530,237" alt="">
<area href="lsd_8c.html#a20" shape="rect" coords="606,261,721,287" alt="">
<area href="lsd_8c.html#a33" shape="rect" coords="630,311,697,338" alt="">
<area href="lsd_8c.html#a25" shape="rect" coords="393,362,537,389" alt="">
<area href="lsd_8c.html#a30" shape="rect" coords="385,413,545,439" alt="">
<area href="lsd_8c.html#a27" shape="rect" coords="398,463,532,490" alt="">
<area href="lsd_8c.html#a51" shape="rect" coords="416,514,514,541" alt="">
<area href="lsd_8c.html#a53" shape="rect" coords="437,615,493,642" alt="">
<area href="lsd_8c.html#a49" shape="rect" coords="620,539,708,566" alt="">
<area href="lsd_8c.html#a50" shape="rect" coords="617,641,710,667" alt="">
</map>
<hr size="1"><address style="align: right;"><small>Generated on Fri Nov 11 11:11:11 2011 for LSD by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.4 </small></address>
</body>
</html>
