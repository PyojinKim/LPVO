<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>LSD: lsd.c File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a></div>
<h1>lsd.c File Reference</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
LSD module code. 
<p>
<dl compact><dt><b>Author:</b></dt><dd>rafael grompone von gioi &lt;<a href="mailto:grompone@gmail.com">grompone@gmail.com</a>&gt;</dd></dl>

<p>
Definition in file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
<code>#include &lt;stdio.h&gt;</code><br>
<code>#include &lt;stdlib.h&gt;</code><br>
<code>#include &lt;math.h&gt;</code><br>
<code>#include &lt;limits.h&gt;</code><br>
<code>#include &lt;float.h&gt;</code><br>
<code>#include "<a class="el" href="lsd_8h-source.html">lsd.h</a>"</code><br>

<p>
Include dependency graph for lsd.c:<p><center><img src="lsd_8c__incl.png" border="0" usemap="#lsd.c_map" alt="Include dependency graph"></center>
<map name="lsd.c_map">
<area href="lsd_8h.html" shape="rect" coords="440,7,490,34" alt="">
</map>

<p>
<a href="lsd_8c-source.html">Go to the source code of this file.</a><table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structcoorlist.html">coorlist</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Chained list of coordinates. </em> <a href="structcoorlist.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structimage__char__s.html">image_char_s</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">char image data type </em> <a href="structimage__char__s.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structimage__double__s.html">image_double_s</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">double image data type </em> <a href="structimage__double__s.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structimage__int__s.html">image_int_s</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">int image data type </em> <a href="structimage__int__s.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structntuple__list__s.html">ntuple_list_s</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">'list of n-tuple' data type </em> <a href="structntuple__list__s.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structpoint.html">point</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A point (or pixel). </em> <a href="structpoint.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structrect.html">rect</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rectangle structure: line segment with width. </em> <a href="structrect.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structrect__iter.html">rect_iter</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rectangle points iterator. </em> <a href="structrect__iter.html#_details">More...</a><em><br><br></td></tr>
<tr><td colspan=2><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a0">M_LN10</a>&nbsp;&nbsp;&nbsp;2.30258509299404568402</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">ln(10) </em> <a href="#a0"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a1">M_PI</a>&nbsp;&nbsp;&nbsp;3.14159265358979323846</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">PI. </em> <a href="#a1"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a2">FALSE</a>&nbsp;&nbsp;&nbsp;0</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a3">TRUE</a>&nbsp;&nbsp;&nbsp;1</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a4">NOTDEF</a>&nbsp;&nbsp;&nbsp;-1024.0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Label for pixels with undefined gradient. </em> <a href="#a4"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a5">M_3_2_PI</a>&nbsp;&nbsp;&nbsp;4.71238898038</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">3/2 pi </em> <a href="#a5"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a6">M_2__PI</a>&nbsp;&nbsp;&nbsp;6.28318530718</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">2 pi </em> <a href="#a6"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a7">NOTUSED</a>&nbsp;&nbsp;&nbsp;0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Label for pixels not used in yet. </em> <a href="#a7"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a8">USED</a>&nbsp;&nbsp;&nbsp;1</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Label for pixels already used in detection. </em> <a href="#a8"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a9">RELATIVE_ERROR_FACTOR</a>&nbsp;&nbsp;&nbsp;100.0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Doubles relative error factor. </em> <a href="#a9"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a10">log_gamma</a>(x)&nbsp;&nbsp;&nbsp;((x)&gt;15.0?log_gamma_windschitl(x):log_gamma_lanczos(x))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the natural logarithm of the absolute value of the gamma function of x. </em> <a href="#a10"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a11">TABSIZE</a>&nbsp;&nbsp;&nbsp;100000</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Size of the table to store already computed inverse values. </em> <a href="#a11"></a><em><br><br></td></tr>
<tr><td colspan=2><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>typedef <a class="el" href="structntuple__list__s.html">ntuple_list_s</a> *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a12">ntuple_list</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">'list of n-tuple' data type </em> <a href="#a12"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>typedef <a class="el" href="structimage__char__s.html">image_char_s</a> *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a13">image_char</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">char image data type </em> <a href="#a13"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>typedef <a class="el" href="structimage__int__s.html">image_int_s</a> *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a14">image_int</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">int image data type </em> <a href="#a14"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>typedef <a class="el" href="structimage__double__s.html">image_double_s</a> *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a15">image_double</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">double image data type </em> <a href="#a15"></a><em><br><br></td></tr>
<tr><td colspan=2><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a16">error</a> (char *msg)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fatal error, print a message to standard-error output and exit. </em> <a href="#a16"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a17">double_equal</a> (double a, double b)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compare doubles by relative error. </em> <a href="#a17"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>double&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a18">dist</a> (double x1, double y1, double x2, double y2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes Euclidean distance between point (x1,y1) and point (x2,y2). </em> <a href="#a18"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a19">free_ntuple_list</a> (<a class="el" href="structntuple__list__s.html">ntuple_list</a> in)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free memory used in n-tuple 'in'. </em> <a href="#a19"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="structntuple__list__s.html">ntuple_list</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a20">new_ntuple_list</a> (unsigned int dim)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an n-tuple list and allocate memory for one element. </em> <a href="#a20"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a21">enlarge_ntuple_list</a> (<a class="el" href="structntuple__list__s.html">ntuple_list</a> n_tuple)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enlarge the allocated memory of an n-tuple list. </em> <a href="#a21"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a22">add_7tuple</a> (<a class="el" href="structntuple__list__s.html">ntuple_list</a> out, double v1, double v2, double v3, double v4, double v5, double v6, double v7)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a 7-tuple to an n-tuple list. </em> <a href="#a22"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a23">free_image_char</a> (<a class="el" href="structimage__char__s.html">image_char</a> i)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free memory used in image_char 'i'. </em> <a href="#a23"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="structimage__char__s.html">image_char</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a24">new_image_char</a> (unsigned int xsize, unsigned int ysize)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new image_char of size 'xsize' times 'ysize'. </em> <a href="#a24"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="structimage__char__s.html">image_char</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a25">new_image_char_ini</a> (unsigned int xsize, unsigned int ysize, unsigned char fill_value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new image_char of size 'xsize' times 'ysize', initialized to the value 'fill_value'. </em> <a href="#a25"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="structimage__int__s.html">image_int</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a26">new_image_int</a> (unsigned int xsize, unsigned int ysize)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new image_int of size 'xsize' times 'ysize'. </em> <a href="#a26"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="structimage__int__s.html">image_int</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a27">new_image_int_ini</a> (unsigned int xsize, unsigned int ysize, int fill_value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new image_int of size 'xsize' times 'ysize', initialized to the value 'fill_value'. </em> <a href="#a27"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a28">free_image_double</a> (<a class="el" href="structimage__double__s.html">image_double</a> i)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free memory used in image_double 'i'. </em> <a href="#a28"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="structimage__double__s.html">image_double</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a29">new_image_double</a> (unsigned int xsize, unsigned int ysize)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new image_double of size 'xsize' times 'ysize'. </em> <a href="#a29"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="structimage__double__s.html">image_double</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a30">new_image_double_ptr</a> (unsigned int xsize, unsigned int ysize, double *data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new image_double of size 'xsize' times 'ysize' with the data pointed by 'data'. </em> <a href="#a30"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a31">gaussian_kernel</a> (<a class="el" href="structntuple__list__s.html">ntuple_list</a> kernel, double sigma, double mean)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute a Gaussian kernel of length 'kernel-&gt;dim', standard deviation 'sigma', and centered at value 'mean'. </em> <a href="#a31"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="structimage__double__s.html">image_double</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a32">gaussian_sampler</a> (<a class="el" href="structimage__double__s.html">image_double</a> in, double scale, double sigma_scale)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scale the input image 'in' by a factor 'scale' by Gaussian sub-sampling. </em> <a href="#a32"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="structimage__double__s.html">image_double</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a33">ll_angle</a> (<a class="el" href="structimage__double__s.html">image_double</a> in, double threshold, struct <a class="el" href="structcoorlist.html">coorlist</a> **list_p, void **mem_p, <a class="el" href="structimage__double__s.html">image_double</a> *modgrad, unsigned int n_bins)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the direction of the level line of 'in' at each point. </em> <a href="#a33"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a34">isaligned</a> (int x, int y, <a class="el" href="structimage__double__s.html">image_double</a> angles, double theta, double prec)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Is point (x,y) aligned to angle theta, up to precision 'prec'? </em> <a href="#a34"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>double&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a35">angle_diff</a> (double a, double b)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Absolute value angle difference. </em> <a href="#a35"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>double&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a36">angle_diff_signed</a> (double a, double b)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Signed angle difference. </em> <a href="#a36"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>double&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a37">log_gamma_lanczos</a> (double x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the natural logarithm of the absolute value of the gamma function of x using the Lanczos approximation. </em> <a href="#a37"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>double&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a38">log_gamma_windschitl</a> (double x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the natural logarithm of the absolute value of the gamma function of x using Windschitl method. </em> <a href="#a38"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>double&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a39">nfa</a> (int n, int k, double p, double logNT)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes -log10(NFA). </em> <a href="#a39"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a40">rect_copy</a> (struct <a class="el" href="structrect.html">rect</a> *in, struct <a class="el" href="structrect.html">rect</a> *out)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy one rectangle structure to another. </em> <a href="#a40"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>double&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a41">inter_low</a> (double x, double x1, double y1, double x2, double y2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Interpolate y value corresponding to 'x' value given, in the line 'x1,y1' to 'x2,y2'; if 'x1=x2' return the smaller of 'y1' and 'y2'. </em> <a href="#a41"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>double&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a42">inter_hi</a> (double x, double x1, double y1, double x2, double y2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Interpolate y value corresponding to 'x' value given, in the line 'x1,y1' to 'x2,y2'; if 'x1=x2' return the larger of 'y1' and 'y2'. </em> <a href="#a42"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a43">ri_del</a> (<a class="el" href="structrect__iter.html">rect_iter</a> *iter)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free memory used by a rectangle iterator. </em> <a href="#a43"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a44">ri_end</a> (<a class="el" href="structrect__iter.html">rect_iter</a> *i)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if the iterator finished the full iteration. </em> <a href="#a44"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a45">ri_inc</a> (<a class="el" href="structrect__iter.html">rect_iter</a> *i)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Increment a rectangle iterator. </em> <a href="#a45"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="structrect__iter.html">rect_iter</a> *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a46">ri_ini</a> (struct <a class="el" href="structrect.html">rect</a> *r)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create and initialize a rectangle iterator. </em> <a href="#a46"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>double&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a47">rect_nfa</a> (struct <a class="el" href="structrect.html">rect</a> *rec, <a class="el" href="structimage__double__s.html">image_double</a> angles, double logNT)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute a rectangle's NFA value. </em> <a href="#a47"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>double&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a48">get_theta</a> (struct <a class="el" href="structpoint.html">point</a> *reg, int reg_size, double x, double y, <a class="el" href="structimage__double__s.html">image_double</a> modgrad, double reg_angle, double prec)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute region's angle as the principal inertia axis of the region. </em> <a href="#a48"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a49">region2rect</a> (struct <a class="el" href="structpoint.html">point</a> *reg, int reg_size, <a class="el" href="structimage__double__s.html">image_double</a> modgrad, double reg_angle, double prec, double p, struct <a class="el" href="structrect.html">rect</a> *rec)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes a rectangle that covers a region of points. </em> <a href="#a49"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a50">region_grow</a> (int x, int y, <a class="el" href="structimage__double__s.html">image_double</a> angles, struct <a class="el" href="structpoint.html">point</a> *reg, int *reg_size, double *reg_angle, <a class="el" href="structimage__char__s.html">image_char</a> used, double prec)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Build a region of pixels that share the same angle, up to a tolerance 'prec', starting at point (x,y). </em> <a href="#a50"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>double&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a51">rect_improve</a> (struct <a class="el" href="structrect.html">rect</a> *rec, <a class="el" href="structimage__double__s.html">image_double</a> angles, double logNT, double log_eps)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Try some rectangles variations to improve NFA value. </em> <a href="#a51"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a52">reduce_region_radius</a> (struct <a class="el" href="structpoint.html">point</a> *reg, int *reg_size, <a class="el" href="structimage__double__s.html">image_double</a> modgrad, double reg_angle, double prec, double p, struct <a class="el" href="structrect.html">rect</a> *rec, <a class="el" href="structimage__char__s.html">image_char</a> used, <a class="el" href="structimage__double__s.html">image_double</a> angles, double density_th)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reduce the region size, by elimination the points far from the starting point, until that leads to rectangle with the right density of region points or to discard the region if too small. </em> <a href="#a52"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a53">refine</a> (struct <a class="el" href="structpoint.html">point</a> *reg, int *reg_size, <a class="el" href="structimage__double__s.html">image_double</a> modgrad, double reg_angle, double prec, double p, struct <a class="el" href="structrect.html">rect</a> *rec, <a class="el" href="structimage__char__s.html">image_char</a> used, <a class="el" href="structimage__double__s.html">image_double</a> angles, double density_th)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Refine a rectangle. </em> <a href="#a53"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>double *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a54">LineSegmentDetection</a> (int *n_out, double *img, int X, int Y, double scale, double sigma_scale, double quant, double ang_th, double log_eps, double density_th, int n_bins, int **reg_img, int *reg_x, int *reg_y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">LSD Full Interface. </em> <a href="#a54"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>double *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a55">lsd_scale_region</a> (int *n_out, double *img, int X, int Y, double scale, int **reg_img, int *reg_x, int *reg_y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">LSD Simple Interface with Scale and Region output. </em> <a href="#a55"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>double *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a56">lsd_scale</a> (int *n_out, double *img, int X, int Y, double scale)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">LSD Simple Interface with Scale. </em> <a href="#a56"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>double *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a57">lsd</a> (int *n_out, double *img, int X, int Y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">LSD Simple Interface. </em> <a href="#a57"></a><em><br><br></td></tr>
</table>
<hr><h2>Define Documentation</h2>
<a class="anchor" name="a2" doxytag="lsd.c::FALSE" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define FALSE&nbsp;&nbsp;&nbsp;0
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l00115">115</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l00893">isaligned()</a>, <a class="el" href="lsd_8c-source.html#l01869">reduce_region_radius()</a>, and <a class="el" href="lsd_8c-source.html#l01947">refine()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a10" doxytag="lsd.c::log_gamma" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define log_gamma</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">x&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>&nbsp;&nbsp;&nbsp;((x)&gt;15.0?log_gamma_windschitl(x):log_gamma_lanczos(x))
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Computes the natural logarithm of the absolute value of the gamma function of x. 
<p>
When x&gt;15 use <a class="el" href="lsd_8c.html#a38">log_gamma_windschitl()</a>, otherwise use <a class="el" href="lsd_8c.html#a37">log_gamma_lanczos()</a>. 
<p>
Definition at line <a class="el" href="lsd_8c-source.html#l01025">1025</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l01074">nfa()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a6" doxytag="lsd.c::M_2__PI" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define M_2__PI&nbsp;&nbsp;&nbsp;6.28318530718
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
2 pi 
<p>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l00129">129</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l00931">angle_diff()</a>, <a class="el" href="lsd_8c-source.html#l00943">angle_diff_signed()</a>, and <a class="el" href="lsd_8c-source.html#l00893">isaligned()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a5" doxytag="lsd.c::M_3_2_PI" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define M_3_2_PI&nbsp;&nbsp;&nbsp;4.71238898038
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
3/2 pi 
<p>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l00126">126</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l00893">isaligned()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a0" doxytag="lsd.c::M_LN10" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define M_LN10&nbsp;&nbsp;&nbsp;2.30258509299404568402
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
ln(10) 
<p>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l00106">106</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l01074">nfa()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a1" doxytag="lsd.c::M_PI" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define M_PI&nbsp;&nbsp;&nbsp;3.14159265358979323846
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
PI. 
<p>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l00111">111</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l00931">angle_diff()</a>, <a class="el" href="lsd_8c-source.html#l00943">angle_diff_signed()</a>, <a class="el" href="lsd_8c-source.html#l01568">get_theta()</a>, <a class="el" href="lsd_8c-source.html#l02025">LineSegmentDetection()</a>, and <a class="el" href="lsd_8c-source.html#l01756">rect_improve()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a4" doxytag="lsd.c::NOTDEF" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define NOTDEF&nbsp;&nbsp;&nbsp;-1024.0
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Label for pixels with undefined gradient. 
<p>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l00123">123</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l00893">isaligned()</a>, <a class="el" href="lsd_8c-source.html#l02025">LineSegmentDetection()</a>, and <a class="el" href="lsd_8c-source.html#l00752">ll_angle()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a7" doxytag="lsd.c::NOTUSED" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define NOTUSED&nbsp;&nbsp;&nbsp;0
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Label for pixels not used in yet. 
<p>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l00132">132</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l02025">LineSegmentDetection()</a>, <a class="el" href="lsd_8c-source.html#l01869">reduce_region_radius()</a>, and <a class="el" href="lsd_8c-source.html#l01947">refine()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a9" doxytag="lsd.c::RELATIVE_ERROR_FACTOR" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define RELATIVE_ERROR_FACTOR&nbsp;&nbsp;&nbsp;100.0
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Doubles relative error factor. 
<p>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l00168">168</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l00181">double_equal()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a11" doxytag="lsd.c::TABSIZE" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define TABSIZE&nbsp;&nbsp;&nbsp;100000
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Size of the table to store already computed inverse values. 
<p>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l01030">1030</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l01074">nfa()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a3" doxytag="lsd.c::TRUE" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define TRUE&nbsp;&nbsp;&nbsp;1
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l00119">119</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l00181">double_equal()</a>, <a class="el" href="lsd_8c-source.html#l01869">reduce_region_radius()</a>, and <a class="el" href="lsd_8c-source.html#l01947">refine()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a8" doxytag="lsd.c::USED" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define USED&nbsp;&nbsp;&nbsp;1
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Label for pixels already used in detection. 
<p>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l00135">135</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l01704">region_grow()</a>.    </td>
  </tr>
</table>
<hr><h2>Typedef Documentation</h2>
<a class="anchor" name="a13" doxytag="lsd.c::image_char" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> typedef struct <a class="el" href="structimage__char__s.html">image_char_s</a> *  <a class="el" href="structimage__char__s.html">image_char</a>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
char image data type 
<p>
The pixel value at (x,y) is accessed by:<p>
image-&gt;data[ x + y * image-&gt;xsize ]<p>
with x and y integer. 
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l00352">free_image_char()</a>, <a class="el" href="lsd_8c-source.html#l02025">LineSegmentDetection()</a>, <a class="el" href="lsd_8c-source.html#l00363">new_image_char()</a>, <a class="el" href="lsd_8c-source.html#l00388">new_image_char_ini()</a>, <a class="el" href="lsd_8c-source.html#l01869">reduce_region_radius()</a>, <a class="el" href="lsd_8c-source.html#l01947">refine()</a>, and <a class="el" href="lsd_8c-source.html#l01704">region_grow()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a15" doxytag="lsd.c::image_double" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> typedef struct <a class="el" href="structimage__double__s.html">image_double_s</a> *  <a class="el" href="structimage__double__s.html">image_double</a>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
double image data type 
<p>
The pixel value at (x,y) is accessed by:<p>
image-&gt;data[ x + y * image-&gt;xsize ]<p>
with x and y integer. 
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l00478">free_image_double()</a>, <a class="el" href="lsd_8c-source.html#l00611">gaussian_sampler()</a>, <a class="el" href="lsd_8c-source.html#l01568">get_theta()</a>, <a class="el" href="lsd_8c-source.html#l00893">isaligned()</a>, <a class="el" href="lsd_8c-source.html#l02025">LineSegmentDetection()</a>, <a class="el" href="lsd_8c-source.html#l00752">ll_angle()</a>, <a class="el" href="lsd_8c-source.html#l00489">new_image_double()</a>, <a class="el" href="lsd_8c-source.html#l00513">new_image_double_ptr()</a>, <a class="el" href="lsd_8c-source.html#l01756">rect_improve()</a>, <a class="el" href="lsd_8c-source.html#l01482">rect_nfa()</a>, <a class="el" href="lsd_8c-source.html#l01869">reduce_region_radius()</a>, <a class="el" href="lsd_8c-source.html#l01947">refine()</a>, <a class="el" href="lsd_8c-source.html#l01611">region2rect()</a>, and <a class="el" href="lsd_8c-source.html#l01704">region_grow()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a14" doxytag="lsd.c::image_int" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> typedef struct <a class="el" href="structimage__int__s.html">image_int_s</a> *  <a class="el" href="structimage__int__s.html">image_int</a>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
int image data type 
<p>
The pixel value at (x,y) is accessed by:<p>
image-&gt;data[ x + y * image-&gt;xsize ]<p>
with x and y integer. 
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l02025">LineSegmentDetection()</a>, <a class="el" href="lsd_8c-source.html#l00423">new_image_int()</a>, and <a class="el" href="lsd_8c-source.html#l00447">new_image_int_ini()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a12" doxytag="lsd.c::ntuple_list" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> typedef struct <a class="el" href="structntuple__list__s.html">ntuple_list_s</a> *  <a class="el" href="structntuple__list__s.html">ntuple_list</a>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
'list of n-tuple' data type 
<p>
The i-th component of the j-th n-tuple of an n-tuple list 'ntl' is accessed with:<p>
ntl-&gt;values[ i + j * ntl-&gt;dim ]<p>
The dimension of the n-tuple (n) is:<p>
ntl-&gt;dim<p>
The number of n-tuples in the list is:<p>
ntl-&gt;size<p>
The maximum number of n-tuples that can be stored in the list with the allocated memory at a given time is given by:<p>
ntl-&gt;max_size 
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l00305">add_7tuple()</a>, <a class="el" href="lsd_8c-source.html#l00287">enlarge_ntuple_list()</a>, <a class="el" href="lsd_8c-source.html#l00249">free_ntuple_list()</a>, <a class="el" href="lsd_8c-source.html#l00548">gaussian_kernel()</a>, <a class="el" href="lsd_8c-source.html#l00611">gaussian_sampler()</a>, <a class="el" href="lsd_8c-source.html#l02025">LineSegmentDetection()</a>, and <a class="el" href="lsd_8c-source.html#l00261">new_ntuple_list()</a>.    </td>
  </tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="a22" doxytag="lsd.c::add_7tuple" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void add_7tuple </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structntuple__list__s.html">ntuple_list</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>out</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>v1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>v2</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>v3</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>v4</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>v5</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>v6</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>v7</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Add a 7-tuple to an n-tuple list. 
<p>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l00305">305</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8c-source.html#l00242">ntuple_list_s::dim</a>, <a class="el" href="lsd_8c-source.html#l00287">enlarge_ntuple_list()</a>, <a class="el" href="lsd_8c-source.html#l00159">error()</a>, <a class="el" href="lsd_8c-source.html#l00241">ntuple_list_s::max_size</a>, <a class="el" href="lsd_8c.html#a12">ntuple_list</a>, <a class="el" href="lsd_8c-source.html#l00240">ntuple_list_s::size</a>, and <a class="el" href="lsd_8c-source.html#l00243">ntuple_list_s::values</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l02025">LineSegmentDetection()</a>.
<p>
<div class="fragment"><pre>00307 {
00308   <span class="comment">/* check parameters */</span>
00309   <span class="keywordflow">if</span>( out == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"add_7tuple: invalid n-tuple input."</span>);
00310   <span class="keywordflow">if</span>( out-&gt;<a class="code" href="structntuple__list__s.html#o2">dim</a> != 7 ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"add_7tuple: the n-tuple must be a 7-tuple."</span>);
00311 
00312   <span class="comment">/* if needed, alloc more tuples to 'out' */</span>
00313   <span class="keywordflow">if</span>( out-&gt;<a class="code" href="structntuple__list__s.html#o0">size</a> == out-&gt;<a class="code" href="structntuple__list__s.html#o1">max_size</a> ) <a class="code" href="lsd_8c.html#a21">enlarge_ntuple_list</a>(out);
00314   <span class="keywordflow">if</span>( out-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a> == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"add_7tuple: invalid n-tuple input."</span>);
00315 
00316   <span class="comment">/* add new 7-tuple */</span>
00317   out-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a>[ out-&gt;<a class="code" href="structntuple__list__s.html#o0">size</a> * out-&gt;<a class="code" href="structntuple__list__s.html#o2">dim</a> + 0 ] = v1;
00318   out-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a>[ out-&gt;<a class="code" href="structntuple__list__s.html#o0">size</a> * out-&gt;<a class="code" href="structntuple__list__s.html#o2">dim</a> + 1 ] = v2;
00319   out-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a>[ out-&gt;<a class="code" href="structntuple__list__s.html#o0">size</a> * out-&gt;<a class="code" href="structntuple__list__s.html#o2">dim</a> + 2 ] = v3;
00320   out-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a>[ out-&gt;<a class="code" href="structntuple__list__s.html#o0">size</a> * out-&gt;<a class="code" href="structntuple__list__s.html#o2">dim</a> + 3 ] = v4;
00321   out-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a>[ out-&gt;<a class="code" href="structntuple__list__s.html#o0">size</a> * out-&gt;<a class="code" href="structntuple__list__s.html#o2">dim</a> + 4 ] = v5;
00322   out-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a>[ out-&gt;<a class="code" href="structntuple__list__s.html#o0">size</a> * out-&gt;<a class="code" href="structntuple__list__s.html#o2">dim</a> + 5 ] = v6;
00323   out-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a>[ out-&gt;<a class="code" href="structntuple__list__s.html#o0">size</a> * out-&gt;<a class="code" href="structntuple__list__s.html#o2">dim</a> + 6 ] = v7;
00324 
00325   <span class="comment">/* update number of tuples counter */</span>
00326   out-&gt;<a class="code" href="structntuple__list__s.html#o0">size</a>++;
00327 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8c_a22_cgraph.png" border="0" usemap="#lsd_8c_a22_cgraph_map" alt=""></center>
<map name="lsd_8c_a22_cgraph_map">
<area href="lsd_8c.html#a21" shape="rect" coords="145,7,278,34" alt="">
<area href="lsd_8c.html#a16" shape="rect" coords="328,33,378,59" alt="">
</map>
<a class="anchor" name="a35" doxytag="lsd.c::angle_diff" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> double angle_diff </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">double&nbsp;</td>
          <td class="mdname" nowrap> <em>a</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>b</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Absolute value angle difference. 
<p>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l00931">931</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8c-source.html#l00129">M_2__PI</a>, and <a class="el" href="lsd_8c-source.html#l00111">M_PI</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l01568">get_theta()</a>.
<p>
<div class="fragment"><pre>00932 {
00933   a -= b;
00934   <span class="keywordflow">while</span>( a &lt;= -<a class="code" href="lsd_8c.html#a1">M_PI</a> ) a += <a class="code" href="lsd_8c.html#a6">M_2__PI</a>;
00935   <span class="keywordflow">while</span>( a &gt;   <a class="code" href="lsd_8c.html#a1">M_PI</a> ) a -= <a class="code" href="lsd_8c.html#a6">M_2__PI</a>;
00936   <span class="keywordflow">if</span>( a &lt; 0.0 ) a = -a;
00937   <span class="keywordflow">return</span> a;
00938 }
</pre></div>    </td>
  </tr>
</table>
<a class="anchor" name="a36" doxytag="lsd.c::angle_diff_signed" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> double angle_diff_signed </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">double&nbsp;</td>
          <td class="mdname" nowrap> <em>a</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>b</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Signed angle difference. 
<p>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l00943">943</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8c-source.html#l00129">M_2__PI</a>, and <a class="el" href="lsd_8c-source.html#l00111">M_PI</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l01947">refine()</a>.
<p>
<div class="fragment"><pre>00944 {
00945   a -= b;
00946   <span class="keywordflow">while</span>( a &lt;= -<a class="code" href="lsd_8c.html#a1">M_PI</a> ) a += <a class="code" href="lsd_8c.html#a6">M_2__PI</a>;
00947   <span class="keywordflow">while</span>( a &gt;   <a class="code" href="lsd_8c.html#a1">M_PI</a> ) a -= <a class="code" href="lsd_8c.html#a6">M_2__PI</a>;
00948   <span class="keywordflow">return</span> a;
00949 }
</pre></div>    </td>
  </tr>
</table>
<a class="anchor" name="a18" doxytag="lsd.c::dist" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> double dist </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">double&nbsp;</td>
          <td class="mdname" nowrap> <em>x1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>y1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>x2</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>y2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Computes Euclidean distance between point (x1,y1) and point (x2,y2). 
<p>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l00207">207</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l01869">reduce_region_radius()</a>, and <a class="el" href="lsd_8c-source.html#l01947">refine()</a>.
<p>
<div class="fragment"><pre>00208 {
00209   <span class="keywordflow">return</span> sqrt( (x2-x1)*(x2-x1) + (y2-y1)*(y2-y1) );
00210 }
</pre></div>    </td>
  </tr>
</table>
<a class="anchor" name="a17" doxytag="lsd.c::double_equal" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int double_equal </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">double&nbsp;</td>
          <td class="mdname" nowrap> <em>a</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>b</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Compare doubles by relative error. 
<p>
The resulting rounding error after floating point computations depend on the specific operations done. The same number computed by different algorithms could present different rounding errors. For a useful comparison, an estimation of the relative rounding error should be considered and compared to a factor times EPS. The factor should be related to the cumulated rounding error in the chain of computation. Here, as a simplification, a fixed factor is used. 
<p>
Definition at line <a class="el" href="lsd_8c-source.html#l00181">181</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8c-source.html#l00168">RELATIVE_ERROR_FACTOR</a>, and <a class="el" href="lsd_8c-source.html#l00119">TRUE</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l01568">get_theta()</a>, <a class="el" href="lsd_8c-source.html#l01299">inter_hi()</a>, <a class="el" href="lsd_8c-source.html#l01277">inter_low()</a>, and <a class="el" href="lsd_8c-source.html#l01074">nfa()</a>.
<p>
<div class="fragment"><pre>00182 {
00183   <span class="keywordtype">double</span> abs_diff,aa,bb,abs_max;
00184 
00185   <span class="comment">/* trivial case */</span>
00186   <span class="keywordflow">if</span>( a == b ) <span class="keywordflow">return</span> <a class="code" href="lsd_8c.html#a3">TRUE</a>;
00187 
00188   abs_diff = fabs(a-b);
00189   aa = fabs(a);
00190   bb = fabs(b);
00191   abs_max = aa &gt; bb ? aa : bb;
00192 
00193   <span class="comment">/* DBL_MIN is the smallest normalized number, thus, the smallest</span>
00194 <span class="comment">     number whose relative error is bounded by DBL_EPSILON. For</span>
00195 <span class="comment">     smaller numbers, the same quantization steps as for DBL_MIN</span>
00196 <span class="comment">     are used. Then, for smaller numbers, a meaningful "relative"</span>
00197 <span class="comment">     error should be computed by dividing the difference by DBL_MIN. */</span>
00198   <span class="keywordflow">if</span>( abs_max &lt; DBL_MIN ) abs_max = DBL_MIN;
00199 
00200   <span class="comment">/* equal if relative error &lt;= factor x eps */</span>
00201   <span class="keywordflow">return</span> (abs_diff / abs_max) &lt;= (<a class="code" href="lsd_8c.html#a9">RELATIVE_ERROR_FACTOR</a> * DBL_EPSILON);
00202 }
</pre></div>    </td>
  </tr>
</table>
<a class="anchor" name="a21" doxytag="lsd.c::enlarge_ntuple_list" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void enlarge_ntuple_list </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structntuple__list__s.html">ntuple_list</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>n_tuple</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Enlarge the allocated memory of an n-tuple list. 
<p>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l00287">287</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8c-source.html#l00242">ntuple_list_s::dim</a>, <a class="el" href="lsd_8c-source.html#l00159">error()</a>, <a class="el" href="lsd_8c-source.html#l00241">ntuple_list_s::max_size</a>, <a class="el" href="lsd_8c.html#a12">ntuple_list</a>, and <a class="el" href="lsd_8c-source.html#l00243">ntuple_list_s::values</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l00305">add_7tuple()</a>, and <a class="el" href="lsd_8c-source.html#l00548">gaussian_kernel()</a>.
<p>
<div class="fragment"><pre>00288 {
00289   <span class="comment">/* check parameters */</span>
00290   <span class="keywordflow">if</span>( n_tuple == NULL || n_tuple-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a> == NULL || n_tuple-&gt;<a class="code" href="structntuple__list__s.html#o1">max_size</a> == 0 )
00291     <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"enlarge_ntuple_list: invalid n-tuple."</span>);
00292 
00293   <span class="comment">/* duplicate number of tuples */</span>
00294   n_tuple-&gt;<a class="code" href="structntuple__list__s.html#o1">max_size</a> *= 2;
00295 
00296   <span class="comment">/* realloc memory */</span>
00297   n_tuple-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a> = (<span class="keywordtype">double</span> *) realloc( (<span class="keywordtype">void</span> *) n_tuple-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a>,
00298                       n_tuple-&gt;<a class="code" href="structntuple__list__s.html#o2">dim</a> * n_tuple-&gt;<a class="code" href="structntuple__list__s.html#o1">max_size</a> * <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>) );
00299   <span class="keywordflow">if</span>( n_tuple-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a> == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"not enough memory."</span>);
00300 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8c_a21_cgraph.png" border="0" usemap="#lsd_8c_a21_cgraph_map" alt=""></center>
<map name="lsd_8c_a21_cgraph_map">
<area href="lsd_8c.html#a16" shape="rect" coords="192,8,242,34" alt="">
</map>
<a class="anchor" name="a16" doxytag="lsd.c::error" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void error </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">char *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>msg</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Fatal error, print a message to standard-error output and exit. 
<p>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l00159">159</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l00305">add_7tuple()</a>, <a class="el" href="lsd_8c-source.html#l00287">enlarge_ntuple_list()</a>, <a class="el" href="lsd_8c-source.html#l00352">free_image_char()</a>, <a class="el" href="lsd_8c-source.html#l00478">free_image_double()</a>, <a class="el" href="lsd_8c-source.html#l00249">free_ntuple_list()</a>, <a class="el" href="lsd_8c-source.html#l00548">gaussian_kernel()</a>, <a class="el" href="lsd_8c-source.html#l00611">gaussian_sampler()</a>, <a class="el" href="lsd_8c-source.html#l01568">get_theta()</a>, <a class="el" href="lsd_8c-source.html#l01299">inter_hi()</a>, <a class="el" href="lsd_8c-source.html#l01277">inter_low()</a>, <a class="el" href="lsd_8c-source.html#l00893">isaligned()</a>, <a class="el" href="lsd_8c-source.html#l02025">LineSegmentDetection()</a>, <a class="el" href="lsd_8c-source.html#l00752">ll_angle()</a>, <a class="el" href="lsd_8c-source.html#l00363">new_image_char()</a>, <a class="el" href="lsd_8c-source.html#l00388">new_image_char_ini()</a>, <a class="el" href="lsd_8c-source.html#l00489">new_image_double()</a>, <a class="el" href="lsd_8c-source.html#l00513">new_image_double_ptr()</a>, <a class="el" href="lsd_8c-source.html#l00423">new_image_int()</a>, <a class="el" href="lsd_8c-source.html#l00261">new_ntuple_list()</a>, <a class="el" href="lsd_8c-source.html#l01074">nfa()</a>, <a class="el" href="lsd_8c-source.html#l01183">rect_copy()</a>, <a class="el" href="lsd_8c-source.html#l01482">rect_nfa()</a>, <a class="el" href="lsd_8c-source.html#l01869">reduce_region_radius()</a>, <a class="el" href="lsd_8c-source.html#l01947">refine()</a>, <a class="el" href="lsd_8c-source.html#l01611">region2rect()</a>, <a class="el" href="lsd_8c-source.html#l01704">region_grow()</a>, <a class="el" href="lsd_8c-source.html#l01314">ri_del()</a>, <a class="el" href="lsd_8c-source.html#l01325">ri_end()</a>, <a class="el" href="lsd_8c-source.html#l01341">ri_inc()</a>, and <a class="el" href="lsd_8c-source.html#l01411">ri_ini()</a>.
<p>
<div class="fragment"><pre>00160 {
00161   fprintf(stderr,<span class="stringliteral">"LSD Error: %s\n"</span>,msg);
00162   exit(EXIT_FAILURE);
00163 }
</pre></div>    </td>
  </tr>
</table>
<a class="anchor" name="a23" doxytag="lsd.c::free_image_char" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void free_image_char </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structimage__char__s.html">image_char</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>i</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Free memory used in image_char 'i'. 
<p>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l00352">352</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8c-source.html#l00345">image_char_s::data</a>, <a class="el" href="lsd_8c-source.html#l00159">error()</a>, and <a class="el" href="lsd_8c.html#a13">image_char</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l02025">LineSegmentDetection()</a>.
<p>
<div class="fragment"><pre>00353 {
00354   <span class="keywordflow">if</span>( i == NULL || i-&gt;<a class="code" href="structimage__char__s.html#o0">data</a> == NULL )
00355     <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"free_image_char: invalid input image."</span>);
00356   free( (<span class="keywordtype">void</span> *) i-&gt;<a class="code" href="structimage__char__s.html#o0">data</a> );
00357   free( (<span class="keywordtype">void</span> *) i );
00358 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8c_a23_cgraph.png" border="0" usemap="#lsd_8c_a23_cgraph_map" alt=""></center>
<map name="lsd_8c_a23_cgraph_map">
<area href="lsd_8c.html#a16" shape="rect" coords="178,8,229,34" alt="">
</map>
<a class="anchor" name="a28" doxytag="lsd.c::free_image_double" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void free_image_double </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structimage__double__s.html">image_double</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>i</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Free memory used in image_double 'i'. 
<p>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l00478">478</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8c-source.html#l00471">image_double_s::data</a>, <a class="el" href="lsd_8c-source.html#l00159">error()</a>, and <a class="el" href="lsd_8c.html#a15">image_double</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l00611">gaussian_sampler()</a>, and <a class="el" href="lsd_8c-source.html#l02025">LineSegmentDetection()</a>.
<p>
<div class="fragment"><pre>00479 {
00480   <span class="keywordflow">if</span>( i == NULL || i-&gt;<a class="code" href="structimage__double__s.html#o0">data</a> == NULL )
00481     <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"free_image_double: invalid input image."</span>);
00482   free( (<span class="keywordtype">void</span> *) i-&gt;<a class="code" href="structimage__double__s.html#o0">data</a> );
00483   free( (<span class="keywordtype">void</span> *) i );
00484 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8c_a28_cgraph.png" border="0" usemap="#lsd_8c_a28_cgraph_map" alt=""></center>
<map name="lsd_8c_a28_cgraph_map">
<area href="lsd_8c.html#a16" shape="rect" coords="194,8,245,34" alt="">
</map>
<a class="anchor" name="a19" doxytag="lsd.c::free_ntuple_list" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void free_ntuple_list </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structntuple__list__s.html">ntuple_list</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>in</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Free memory used in n-tuple 'in'. 
<p>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l00249">249</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8c-source.html#l00159">error()</a>, <a class="el" href="lsd_8c.html#a12">ntuple_list</a>, and <a class="el" href="lsd_8c-source.html#l00243">ntuple_list_s::values</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l00611">gaussian_sampler()</a>.
<p>
<div class="fragment"><pre>00250 {
00251   <span class="keywordflow">if</span>( in == NULL || in-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a> == NULL )
00252     <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"free_ntuple_list: invalid n-tuple input."</span>);
00253   free( (<span class="keywordtype">void</span> *) in-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a> );
00254   free( (<span class="keywordtype">void</span> *) in );
00255 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8c_a19_cgraph.png" border="0" usemap="#lsd_8c_a19_cgraph_map" alt=""></center>
<map name="lsd_8c_a19_cgraph_map">
<area href="lsd_8c.html#a16" shape="rect" coords="170,8,221,34" alt="">
</map>
<a class="anchor" name="a31" doxytag="lsd.c::gaussian_kernel" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void gaussian_kernel </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structntuple__list__s.html">ntuple_list</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>kernel</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>sigma</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>mean</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Compute a Gaussian kernel of length 'kernel-&gt;dim', standard deviation 'sigma', and centered at value 'mean'. 
<p>
For example, if mean=0.5, the Gaussian will be centered in the middle point between values 'kernel-&gt;values[0]' and 'kernel-&gt;values[1]'. 
<p>
Definition at line <a class="el" href="lsd_8c-source.html#l00548">548</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8c-source.html#l00242">ntuple_list_s::dim</a>, <a class="el" href="lsd_8c-source.html#l00287">enlarge_ntuple_list()</a>, <a class="el" href="lsd_8c-source.html#l00159">error()</a>, <a class="el" href="lsd_8c-source.html#l00241">ntuple_list_s::max_size</a>, <a class="el" href="lsd_8c.html#a12">ntuple_list</a>, <a class="el" href="lsd_8c-source.html#l00240">ntuple_list_s::size</a>, and <a class="el" href="lsd_8c-source.html#l00243">ntuple_list_s::values</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l00611">gaussian_sampler()</a>.
<p>
<div class="fragment"><pre>00549 {
00550   <span class="keywordtype">double</span> sum = 0.0;
00551   <span class="keywordtype">double</span> val;
00552   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i;
00553 
00554   <span class="comment">/* check parameters */</span>
00555   <span class="keywordflow">if</span>( kernel == NULL || kernel-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a> == NULL )
00556     <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"gaussian_kernel: invalid n-tuple 'kernel'."</span>);
00557   <span class="keywordflow">if</span>( sigma &lt;= 0.0 ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"gaussian_kernel: 'sigma' must be positive."</span>);
00558 
00559   <span class="comment">/* compute Gaussian kernel */</span>
00560   <span class="keywordflow">if</span>( kernel-&gt;<a class="code" href="structntuple__list__s.html#o1">max_size</a> &lt; 1 ) <a class="code" href="lsd_8c.html#a21">enlarge_ntuple_list</a>(kernel);
00561   kernel-&gt;<a class="code" href="structntuple__list__s.html#o0">size</a> = 1;
00562   <span class="keywordflow">for</span>(i=0;i&lt;kernel-&gt;<a class="code" href="structntuple__list__s.html#o2">dim</a>;i++)
00563     {
00564       val = ( (<span class="keywordtype">double</span>) i - mean ) / sigma;
00565       kernel-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a>[i] = exp( -0.5 * val * val );
00566       sum += kernel-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a>[i];
00567     }
00568 
00569   <span class="comment">/* normalization */</span>
00570   <span class="keywordflow">if</span>( sum &gt;= 0.0 ) <span class="keywordflow">for</span>(i=0;i&lt;kernel-&gt;<a class="code" href="structntuple__list__s.html#o2">dim</a>;i++) kernel-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a>[i] /= sum;
00571 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8c_a31_cgraph.png" border="0" usemap="#lsd_8c_a31_cgraph_map" alt=""></center>
<map name="lsd_8c_a31_cgraph_map">
<area href="lsd_8c.html#a21" shape="rect" coords="177,7,310,34" alt="">
<area href="lsd_8c.html#a16" shape="rect" coords="360,33,410,59" alt="">
</map>
<a class="anchor" name="a32" doxytag="lsd.c::gaussian_sampler" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="structimage__double__s.html">image_double</a> gaussian_sampler </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structimage__double__s.html">image_double</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>in</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>scale</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>sigma_scale</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Scale the input image 'in' by a factor 'scale' by Gaussian sub-sampling. 
<p>
For example, scale=0.8 will give a result at 80% of the original size.<p>
The image is convolved with a Gaussian kernel <p class=formulaDsp>
<img class=formulaDsp alt="\[ G(x,y) = \frac{1}{2\pi\sigma^2} e^{-\frac{x^2+y^2}{2\sigma^2}} \]" src="form_0.png">
<p>
 before the sub-sampling to prevent aliasing.<p>
The standard deviation sigma given by:<ul>
<li>sigma = sigma_scale / scale, if scale &lt; 1.0</li><li>sigma = sigma_scale, if scale &gt;= 1.0</li></ul>
<p>
To be able to sub-sample at non-integer steps, some interpolation is needed. In this implementation, the interpolation is done by the Gaussian kernel, so both operations (filtering and sampling) are done at the same time. The Gaussian kernel is computed centered on the coordinates of the required sample. In this way, when applied, it gives directly the result of convolving the image with the kernel and interpolated to that particular position.<p>
A fast algorithm is done using the separability of the Gaussian kernel. Applying the 2D Gaussian kernel is equivalent to applying first a horizontal 1D Gaussian kernel and then a vertical 1D Gaussian kernel (or the other way round). The reason is that <p class=formulaDsp>
<img class=formulaDsp alt="\[ G(x,y) = G(x) * G(y) \]" src="form_1.png">
<p>
 where <p class=formulaDsp>
<img class=formulaDsp alt="\[ G(x) = \frac{1}{\sqrt{2\pi}\sigma} e^{-\frac{x^2}{2\sigma^2}}. \]" src="form_2.png">
<p>
 The algorithm first applies a combined Gaussian kernel and sampling in the x axis, and then the combined Gaussian kernel and sampling in the y axis. 
<p>
Definition at line <a class="el" href="lsd_8c-source.html#l00611">611</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8c-source.html#l00471">image_double_s::data</a>, <a class="el" href="lsd_8c-source.html#l00242">ntuple_list_s::dim</a>, <a class="el" href="lsd_8c-source.html#l00159">error()</a>, <a class="el" href="lsd_8c-source.html#l00478">free_image_double()</a>, <a class="el" href="lsd_8c-source.html#l00249">free_ntuple_list()</a>, <a class="el" href="lsd_8c-source.html#l00548">gaussian_kernel()</a>, <a class="el" href="lsd_8c.html#a15">image_double</a>, <a class="el" href="lsd_8c-source.html#l00489">new_image_double()</a>, <a class="el" href="lsd_8c-source.html#l00261">new_ntuple_list()</a>, <a class="el" href="lsd_8c.html#a12">ntuple_list</a>, <a class="el" href="lsd_8c-source.html#l00243">ntuple_list_s::values</a>, <a class="el" href="lsd_8c-source.html#l00472">image_double_s::xsize</a>, and <a class="el" href="lsd_8c-source.html#l00472">image_double_s::ysize</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l02025">LineSegmentDetection()</a>.
<p>
<div class="fragment"><pre>00613 {
00614   <a class="code" href="structimage__double__s.html">image_double</a> aux,out;
00615   <a class="code" href="structntuple__list__s.html">ntuple_list</a> kernel;
00616   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N,M,h,n,x,y,i;
00617   <span class="keywordtype">int</span> xc,yc,j,double_x_size,double_y_size;
00618   <span class="keywordtype">double</span> sigma,xx,yy,sum,prec;
00619 
00620   <span class="comment">/* check parameters */</span>
00621   <span class="keywordflow">if</span>( in == NULL || in-&gt;<a class="code" href="structimage__double__s.html#o0">data</a> == NULL || in-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a> == 0 || in-&gt;<a class="code" href="structimage__double__s.html#o2">ysize</a> == 0 )
00622     <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"gaussian_sampler: invalid image."</span>);
00623   <span class="keywordflow">if</span>( scale &lt;= 0.0 ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"gaussian_sampler: 'scale' must be positive."</span>);
00624   <span class="keywordflow">if</span>( sigma_scale &lt;= 0.0 )
00625     <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"gaussian_sampler: 'sigma_scale' must be positive."</span>);
00626 
00627   <span class="comment">/* compute new image size and get memory for images */</span>
00628   <span class="keywordflow">if</span>( in-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a> * scale &gt; (<span class="keywordtype">double</span>) UINT_MAX ||
00629       in-&gt;<a class="code" href="structimage__double__s.html#o2">ysize</a> * scale &gt; (<span class="keywordtype">double</span>) UINT_MAX )
00630     <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"gaussian_sampler: the output image size exceeds the handled size."</span>);
00631   N = (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>) ceil( in-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a> * scale );
00632   M = (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>) ceil( in-&gt;<a class="code" href="structimage__double__s.html#o2">ysize</a> * scale );
00633   aux = <a class="code" href="lsd_8c.html#a29">new_image_double</a>(N,in-&gt;<a class="code" href="structimage__double__s.html#o2">ysize</a>);
00634   out = <a class="code" href="lsd_8c.html#a29">new_image_double</a>(N,M);
00635 
00636   <span class="comment">/* sigma, kernel size and memory for the kernel */</span>
00637   sigma = scale &lt; 1.0 ? sigma_scale / scale : sigma_scale;
00638   <span class="comment">/*</span>
00639 <span class="comment">     The size of the kernel is selected to guarantee that the</span>
00640 <span class="comment">     the first discarded term is at least 10^prec times smaller</span>
00641 <span class="comment">     than the central value. For that, h should be larger than x, with</span>
00642 <span class="comment">       e^(-x^2/2sigma^2) = 1/10^prec.</span>
00643 <span class="comment">     Then,</span>
00644 <span class="comment">       x = sigma * sqrt( 2 * prec * ln(10) ).</span>
00645 <span class="comment">   */</span>
00646   prec = 3.0;
00647   h = (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>) ceil( sigma * sqrt( 2.0 * prec * log(10.0) ) );
00648   n = 1+2*h; <span class="comment">/* kernel size */</span>
00649   kernel = <a class="code" href="lsd_8c.html#a20">new_ntuple_list</a>(n);
00650 
00651   <span class="comment">/* auxiliary double image size variables */</span>
00652   double_x_size = (<span class="keywordtype">int</span>) (2 * in-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a>);
00653   double_y_size = (<span class="keywordtype">int</span>) (2 * in-&gt;<a class="code" href="structimage__double__s.html#o2">ysize</a>);
00654 
00655   <span class="comment">/* First subsampling: x axis */</span>
00656   <span class="keywordflow">for</span>(x=0;x&lt;aux-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a>;x++)
00657     {
00658       <span class="comment">/*</span>
00659 <span class="comment">         x   is the coordinate in the new image.</span>
00660 <span class="comment">         xx  is the corresponding x-value in the original size image.</span>
00661 <span class="comment">         xc  is the integer value, the pixel coordinate of xx.</span>
00662 <span class="comment">       */</span>
00663       xx = (<span class="keywordtype">double</span>) x / scale;
00664       <span class="comment">/* coordinate (0.0,0.0) is in the center of pixel (0,0),</span>
00665 <span class="comment">         so the pixel with xc=0 get the values of xx from -0.5 to 0.5 */</span>
00666       xc = (<span class="keywordtype">int</span>) floor( xx + 0.5 );
00667       <a class="code" href="lsd_8c.html#a31">gaussian_kernel</a>( kernel, sigma, (<span class="keywordtype">double</span>) h + xx - (<span class="keywordtype">double</span>) xc );
00668       <span class="comment">/* the kernel must be computed for each x because the fine</span>
00669 <span class="comment">         offset xx-xc is different in each case */</span>
00670 
00671       <span class="keywordflow">for</span>(y=0;y&lt;aux-&gt;<a class="code" href="structimage__double__s.html#o2">ysize</a>;y++)
00672         {
00673           sum = 0.0;
00674           <span class="keywordflow">for</span>(i=0;i&lt;kernel-&gt;<a class="code" href="structntuple__list__s.html#o2">dim</a>;i++)
00675             {
00676               j = xc - h + i;
00677 
00678               <span class="comment">/* symmetry boundary condition */</span>
00679               <span class="keywordflow">while</span>( j &lt; 0 ) j += double_x_size;
00680               <span class="keywordflow">while</span>( j &gt;= double_x_size ) j -= double_x_size;
00681               <span class="keywordflow">if</span>( j &gt;= (<span class="keywordtype">int</span>) in-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a> ) j = double_x_size-1-j;
00682 
00683               sum += in-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>[ j + y * in-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a> ] * kernel-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a>[i];
00684             }
00685           aux-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>[ x + y * aux-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a> ] = sum;
00686         }
00687     }
00688 
00689   <span class="comment">/* Second subsampling: y axis */</span>
00690   <span class="keywordflow">for</span>(y=0;y&lt;out-&gt;<a class="code" href="structimage__double__s.html#o2">ysize</a>;y++)
00691     {
00692       <span class="comment">/*</span>
00693 <span class="comment">         y   is the coordinate in the new image.</span>
00694 <span class="comment">         yy  is the corresponding x-value in the original size image.</span>
00695 <span class="comment">         yc  is the integer value, the pixel coordinate of xx.</span>
00696 <span class="comment">       */</span>
00697       yy = (<span class="keywordtype">double</span>) y / scale;
00698       <span class="comment">/* coordinate (0.0,0.0) is in the center of pixel (0,0),</span>
00699 <span class="comment">         so the pixel with yc=0 get the values of yy from -0.5 to 0.5 */</span>
00700       yc = (<span class="keywordtype">int</span>) floor( yy + 0.5 );
00701       <a class="code" href="lsd_8c.html#a31">gaussian_kernel</a>( kernel, sigma, (<span class="keywordtype">double</span>) h + yy - (<span class="keywordtype">double</span>) yc );
00702       <span class="comment">/* the kernel must be computed for each y because the fine</span>
00703 <span class="comment">         offset yy-yc is different in each case */</span>
00704 
00705       <span class="keywordflow">for</span>(x=0;x&lt;out-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a>;x++)
00706         {
00707           sum = 0.0;
00708           <span class="keywordflow">for</span>(i=0;i&lt;kernel-&gt;<a class="code" href="structntuple__list__s.html#o2">dim</a>;i++)
00709             {
00710               j = yc - h + i;
00711 
00712               <span class="comment">/* symmetry boundary condition */</span>
00713               <span class="keywordflow">while</span>( j &lt; 0 ) j += double_y_size;
00714               <span class="keywordflow">while</span>( j &gt;= double_y_size ) j -= double_y_size;
00715               <span class="keywordflow">if</span>( j &gt;= (<span class="keywordtype">int</span>) in-&gt;<a class="code" href="structimage__double__s.html#o2">ysize</a> ) j = double_y_size-1-j;
00716 
00717               sum += aux-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>[ x + j * aux-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a> ] * kernel-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a>[i];
00718             }
00719           out-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>[ x + y * out-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a> ] = sum;
00720         }
00721     }
00722 
00723   <span class="comment">/* free memory */</span>
00724   <a class="code" href="lsd_8c.html#a19">free_ntuple_list</a>(kernel);
00725   <a class="code" href="lsd_8c.html#a28">free_image_double</a>(aux);
00726 
00727   <span class="keywordflow">return</span> out;
00728 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8c_a32_cgraph.png" border="0" usemap="#lsd_8c_a32_cgraph_map" alt=""></center>
<map name="lsd_8c_a32_cgraph_map">
<area href="lsd_8c.html#a16" shape="rect" coords="560,197,610,224" alt="">
<area href="lsd_8c.html#a28" shape="rect" coords="374,96,510,122" alt="">
<area href="lsd_8c.html#a19" shape="rect" coords="386,146,498,173" alt="">
<area href="lsd_8c.html#a31" shape="rect" coords="197,197,314,224" alt="">
<area href="lsd_8c.html#a29" shape="rect" coords="188,260,324,286" alt="">
<area href="lsd_8c.html#a20" shape="rect" coords="198,336,313,362" alt="">
<area href="lsd_8c.html#a21" shape="rect" coords="376,248,509,274" alt="">
</map>
<a class="anchor" name="a48" doxytag="lsd.c::get_theta" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> double get_theta </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct <a class="el" href="structpoint.html">point</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>reg</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>reg_size</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>x</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>y</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="structimage__double__s.html">image_double</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>modgrad</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>reg_angle</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>prec</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Compute region's angle as the principal inertia axis of the region. 
<p>
The following is the region inertia matrix A: <p class=formulaDsp>
<img class=formulaDsp alt="\[ A = \left(\begin{array}{cc} Ixx &amp; Ixy \\ Ixy &amp; Iyy \\ \end{array}\right) \]" src="form_10.png">
<p>
 where<p>
Ixx = sum_i G(i).(y_i - cx)^2<p>
Iyy = sum_i G(i).(x_i - cy)^2<p>
Ixy = - sum_i G(i).(x_i - cx).(y_i - cy)<p>
and<ul>
<li>G(i) is the gradient norm at pixel i, used as pixel's weight.</li><li>x_i and y_i are the coordinates of pixel i.</li><li>cx and cy are the coordinates of the center of th region.</li></ul>
<p>
lambda1 and lambda2 are the eigenvalues of matrix A, with lambda1 &gt;= lambda2. They are found by solving the characteristic polynomial:<p>
det( lambda I - A) = 0<p>
that gives:<p>
lambda1 = ( Ixx + Iyy + sqrt( (Ixx-Iyy)^2 + 4.0*Ixy*Ixy) ) / 2<p>
lambda2 = ( Ixx + Iyy - sqrt( (Ixx-Iyy)^2 + 4.0*Ixy*Ixy) ) / 2<p>
To get the line segment direction we want to get the angle the eigenvector associated to the smallest eigenvalue. We have to solve for a,b in:<p>
a.Ixx + b.Ixy = a.lambda2<p>
a.Ixy + b.Iyy = b.lambda2<p>
We want the angle theta = atan(b/a). It can be computed with any of the two equations:<p>
theta = atan( (lambda2-Ixx) / Ixy )<p>
or<p>
theta = atan( Ixy / (lambda2-Iyy) )<p>
When |Ixx| &gt; |Iyy| we use the first, otherwise the second (just to get better numeric precision). 
<p>
Definition at line <a class="el" href="lsd_8c-source.html#l01568">1568</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8c-source.html#l00931">angle_diff()</a>, <a class="el" href="lsd_8c-source.html#l00471">image_double_s::data</a>, <a class="el" href="lsd_8c-source.html#l00181">double_equal()</a>, <a class="el" href="lsd_8c-source.html#l00159">error()</a>, <a class="el" href="lsd_8c.html#a15">image_double</a>, <a class="el" href="lsd_8c-source.html#l00111">M_PI</a>, <a class="el" href="lsd_8c-source.html#l00149">point::x</a>, <a class="el" href="lsd_8c-source.html#l00472">image_double_s::xsize</a>, and <a class="el" href="lsd_8c-source.html#l00149">point::y</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l01611">region2rect()</a>.
<p>
<div class="fragment"><pre>01570 {
01571   <span class="keywordtype">double</span> lambda,theta,weight;
01572   <span class="keywordtype">double</span> Ixx = 0.0;
01573   <span class="keywordtype">double</span> Iyy = 0.0;
01574   <span class="keywordtype">double</span> Ixy = 0.0;
01575   <span class="keywordtype">int</span> i;
01576 
01577   <span class="comment">/* check parameters */</span>
01578   <span class="keywordflow">if</span>( reg == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"get_theta: invalid region."</span>);
01579   <span class="keywordflow">if</span>( reg_size &lt;= 1 ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"get_theta: region size &lt;= 1."</span>);
01580   <span class="keywordflow">if</span>( modgrad == NULL || modgrad-&gt;<a class="code" href="structimage__double__s.html#o0">data</a> == NULL )
01581     <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"get_theta: invalid 'modgrad'."</span>);
01582   <span class="keywordflow">if</span>( prec &lt; 0.0 ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"get_theta: 'prec' must be positive."</span>);
01583 
01584   <span class="comment">/* compute inertia matrix */</span>
01585   <span class="keywordflow">for</span>(i=0; i&lt;reg_size; i++)
01586     {
01587       weight = modgrad-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>[ reg[i].<a class="code" href="structpoint.html#o0">x</a> + reg[i].<a class="code" href="structpoint.html#o1">y</a> * modgrad-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a> ];
01588       Ixx += ( (<span class="keywordtype">double</span>) reg[i].<a class="code" href="structpoint.html#o1">y</a> - y ) * ( (<span class="keywordtype">double</span>) reg[i].<a class="code" href="structpoint.html#o1">y</a> - y ) * weight;
01589       Iyy += ( (<span class="keywordtype">double</span>) reg[i].<a class="code" href="structpoint.html#o0">x</a> - x ) * ( (<span class="keywordtype">double</span>) reg[i].<a class="code" href="structpoint.html#o0">x</a> - x ) * weight;
01590       Ixy -= ( (<span class="keywordtype">double</span>) reg[i].<a class="code" href="structpoint.html#o0">x</a> - x ) * ( (<span class="keywordtype">double</span>) reg[i].<a class="code" href="structpoint.html#o1">y</a> - y ) * weight;
01591     }
01592   <span class="keywordflow">if</span>( <a class="code" href="lsd_8c.html#a17">double_equal</a>(Ixx,0.0) &amp;&amp; <a class="code" href="lsd_8c.html#a17">double_equal</a>(Iyy,0.0) &amp;&amp; <a class="code" href="lsd_8c.html#a17">double_equal</a>(Ixy,0.0) )
01593     <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"get_theta: null inertia matrix."</span>);
01594 
01595   <span class="comment">/* compute smallest eigenvalue */</span>
01596   lambda = 0.5 * ( Ixx + Iyy - sqrt( (Ixx-Iyy)*(Ixx-Iyy) + 4.0*Ixy*Ixy ) );
01597 
01598   <span class="comment">/* compute angle */</span>
01599   theta = fabs(Ixx)&gt;fabs(Iyy) ? atan2(lambda-Ixx,Ixy) : atan2(Ixy,lambda-Iyy);
01600 
01601   <span class="comment">/* The previous procedure doesn't cares about orientation,</span>
01602 <span class="comment">     so it could be wrong by 180 degrees. Here is corrected if necessary. */</span>
01603   <span class="keywordflow">if</span>( <a class="code" href="lsd_8c.html#a35">angle_diff</a>(theta,reg_angle) &gt; prec ) theta += <a class="code" href="lsd_8c.html#a1">M_PI</a>;
01604 
01605   <span class="keywordflow">return</span> theta;
01606 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8c_a48_cgraph.png" border="0" usemap="#lsd_8c_a48_cgraph_map" alt=""></center>
<map name="lsd_8c_a48_cgraph_map">
<area href="lsd_8c.html#a35" shape="rect" coords="145,8,225,34" alt="">
<area href="lsd_8c.html#a17" shape="rect" coords="134,58,235,85" alt="">
<area href="lsd_8c.html#a16" shape="rect" coords="159,109,210,136" alt="">
</map>
<a class="anchor" name="a42" doxytag="lsd.c::inter_hi" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> double inter_hi </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">double&nbsp;</td>
          <td class="mdname" nowrap> <em>x</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>x1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>y1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>x2</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>y2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Interpolate y value corresponding to 'x' value given, in the line 'x1,y1' to 'x2,y2'; if 'x1=x2' return the larger of 'y1' and 'y2'. 
<p>
The following restrictions are required:<ul>
<li>x1 &lt;= x2</li><li>x1 &lt;= x</li><li>x &lt;= x2 </li></ul>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l01299">1299</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8c-source.html#l00181">double_equal()</a>, and <a class="el" href="lsd_8c-source.html#l00159">error()</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l01341">ri_inc()</a>.
<p>
<div class="fragment"><pre>01300 {
01301   <span class="comment">/* check parameters */</span>
01302   <span class="keywordflow">if</span>( x1 &gt; x2 || x &lt; x1 || x &gt; x2 )
01303     <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"inter_hi: unsuitable input, 'x1&gt;x2' or 'x&lt;x1' or 'x&gt;x2'."</span>);
01304 
01305   <span class="comment">/* interpolation */</span>
01306   <span class="keywordflow">if</span>( <a class="code" href="lsd_8c.html#a17">double_equal</a>(x1,x2) &amp;&amp; y1&lt;y2 ) <span class="keywordflow">return</span> y2;
01307   <span class="keywordflow">if</span>( <a class="code" href="lsd_8c.html#a17">double_equal</a>(x1,x2) &amp;&amp; y1&gt;y2 ) <span class="keywordflow">return</span> y1;
01308   <span class="keywordflow">return</span> y1 + (x-x1) * (y2-y1) / (x2-x1);
01309 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8c_a42_cgraph.png" border="0" usemap="#lsd_8c_a42_cgraph_map" alt=""></center>
<map name="lsd_8c_a42_cgraph_map">
<area href="lsd_8c.html#a17" shape="rect" coords="124,7,225,34" alt="">
<area href="lsd_8c.html#a16" shape="rect" coords="149,58,200,85" alt="">
</map>
<a class="anchor" name="a41" doxytag="lsd.c::inter_low" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> double inter_low </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">double&nbsp;</td>
          <td class="mdname" nowrap> <em>x</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>x1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>y1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>x2</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>y2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Interpolate y value corresponding to 'x' value given, in the line 'x1,y1' to 'x2,y2'; if 'x1=x2' return the smaller of 'y1' and 'y2'. 
<p>
The following restrictions are required:<ul>
<li>x1 &lt;= x2</li><li>x1 &lt;= x</li><li>x &lt;= x2 </li></ul>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l01277">1277</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8c-source.html#l00181">double_equal()</a>, and <a class="el" href="lsd_8c-source.html#l00159">error()</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l01341">ri_inc()</a>.
<p>
<div class="fragment"><pre>01278 {
01279   <span class="comment">/* check parameters */</span>
01280   <span class="keywordflow">if</span>( x1 &gt; x2 || x &lt; x1 || x &gt; x2 )
01281     <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"inter_low: unsuitable input, 'x1&gt;x2' or 'x&lt;x1' or 'x&gt;x2'."</span>);
01282 
01283   <span class="comment">/* interpolation */</span>
01284   <span class="keywordflow">if</span>( <a class="code" href="lsd_8c.html#a17">double_equal</a>(x1,x2) &amp;&amp; y1&lt;y2 ) <span class="keywordflow">return</span> y1;
01285   <span class="keywordflow">if</span>( <a class="code" href="lsd_8c.html#a17">double_equal</a>(x1,x2) &amp;&amp; y1&gt;y2 ) <span class="keywordflow">return</span> y2;
01286   <span class="keywordflow">return</span> y1 + (x-x1) * (y2-y1) / (x2-x1);
01287 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8c_a41_cgraph.png" border="0" usemap="#lsd_8c_a41_cgraph_map" alt=""></center>
<map name="lsd_8c_a41_cgraph_map">
<area href="lsd_8c.html#a17" shape="rect" coords="134,7,235,34" alt="">
<area href="lsd_8c.html#a16" shape="rect" coords="159,58,210,85" alt="">
</map>
<a class="anchor" name="a34" doxytag="lsd.c::isaligned" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int isaligned </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>x</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>y</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="structimage__double__s.html">image_double</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>angles</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>theta</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>prec</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Is point (x,y) aligned to angle theta, up to precision 'prec'? 
<p>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l00893">893</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8c-source.html#l00471">image_double_s::data</a>, <a class="el" href="lsd_8c-source.html#l00159">error()</a>, <a class="el" href="lsd_8c-source.html#l00115">FALSE</a>, <a class="el" href="lsd_8c.html#a15">image_double</a>, <a class="el" href="lsd_8c-source.html#l00129">M_2__PI</a>, <a class="el" href="lsd_8c-source.html#l00126">M_3_2_PI</a>, <a class="el" href="lsd_8c-source.html#l00123">NOTDEF</a>, <a class="el" href="lsd_8c-source.html#l00472">image_double_s::xsize</a>, and <a class="el" href="lsd_8c-source.html#l00472">image_double_s::ysize</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l01482">rect_nfa()</a>, and <a class="el" href="lsd_8c-source.html#l01704">region_grow()</a>.
<p>
<div class="fragment"><pre>00895 {
00896   <span class="keywordtype">double</span> a;
00897 
00898   <span class="comment">/* check parameters */</span>
00899   <span class="keywordflow">if</span>( angles == NULL || angles-&gt;<a class="code" href="structimage__double__s.html#o0">data</a> == NULL )
00900     <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"isaligned: invalid image 'angles'."</span>);
00901   <span class="keywordflow">if</span>( x &lt; 0 || y &lt; 0 || x &gt;= (<span class="keywordtype">int</span>) angles-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a> || y &gt;= (<span class="keywordtype">int</span>) angles-&gt;<a class="code" href="structimage__double__s.html#o2">ysize</a> )
00902     <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"isaligned: (x,y) out of the image."</span>);
00903   <span class="keywordflow">if</span>( prec &lt; 0.0 ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"isaligned: 'prec' must be positive."</span>);
00904 
00905   <span class="comment">/* angle at pixel (x,y) */</span>
00906   a = angles-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>[ x + y * angles-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a> ];
00907 
00908   <span class="comment">/* pixels whose level-line angle is not defined</span>
00909 <span class="comment">     are considered as NON-aligned */</span>
00910   <span class="keywordflow">if</span>( a == <a class="code" href="lsd_8c.html#a4">NOTDEF</a> ) <span class="keywordflow">return</span> <a class="code" href="lsd_8c.html#a2">FALSE</a>;  <span class="comment">/* there is no need to call the function</span>
00911 <span class="comment">                                      'double_equal' here because there is</span>
00912 <span class="comment">                                      no risk of problems related to the</span>
00913 <span class="comment">                                      comparison doubles, we are only</span>
00914 <span class="comment">                                      interested in the exact NOTDEF value */</span>
00915 
00916   <span class="comment">/* it is assumed that 'theta' and 'a' are in the range [-pi,pi] */</span>
00917   theta -= a;
00918   <span class="keywordflow">if</span>( theta &lt; 0.0 ) theta = -theta;
00919   <span class="keywordflow">if</span>( theta &gt; <a class="code" href="lsd_8c.html#a5">M_3_2_PI</a> )
00920     {
00921       theta -= <a class="code" href="lsd_8c.html#a6">M_2__PI</a>;
00922       <span class="keywordflow">if</span>( theta &lt; 0.0 ) theta = -theta;
00923     }
00924 
00925   <span class="keywordflow">return</span> theta &lt;= prec;
00926 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8c_a34_cgraph.png" border="0" usemap="#lsd_8c_a34_cgraph_map" alt=""></center>
<map name="lsd_8c_a34_cgraph_map">
<area href="lsd_8c.html#a16" shape="rect" coords="130,8,181,34" alt="">
</map>
<a class="anchor" name="a54" doxytag="lsd.c::LineSegmentDetection" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> double* LineSegmentDetection </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int *&nbsp;</td>
          <td class="mdname" nowrap> <em>n_out</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap> <em>img</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>X</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>Y</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>scale</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>sigma_scale</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>quant</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>ang_th</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>log_eps</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>density_th</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>n_bins</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int **&nbsp;</td>
          <td class="mdname" nowrap> <em>reg_img</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>reg_x</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>reg_y</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
LSD Full Interface. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>n_out</em>&nbsp;</td><td>Pointer to an int where LSD will store the number of line segments detected.</td></tr>
    <tr><td valign=top><em>img</em>&nbsp;</td><td>Pointer to input image data. It must be an array of doubles of size X x Y, and the pixel at coordinates (x,y) is obtained by img[x+y*X].</td></tr>
    <tr><td valign=top><em>X</em>&nbsp;</td><td>X size of the image: the number of columns.</td></tr>
    <tr><td valign=top><em>Y</em>&nbsp;</td><td>Y size of the image: the number of rows.</td></tr>
    <tr><td valign=top><em>scale</em>&nbsp;</td><td>When different from 1.0, LSD will scale the input image by 'scale' factor by Gaussian filtering, before detecting line segments. Example: if scale=0.8, the input image will be subsampled to 80% of its size, before the line segment detector is applied. Suggested value: 0.8</td></tr>
    <tr><td valign=top><em>sigma_scale</em>&nbsp;</td><td>When scale!=1.0, the sigma of the Gaussian filter is: sigma = sigma_scale / scale, if scale &lt; 1.0 sigma = sigma_scale, if scale &gt;= 1.0 Suggested value: 0.6</td></tr>
    <tr><td valign=top><em>quant</em>&nbsp;</td><td>Bound to the quantization error on the gradient norm. Example: if gray levels are quantized to integer steps, the gradient (computed by finite differences) error due to quantization will be bounded by 2.0, as the worst case is when the error are 1 and -1, that gives an error of 2.0. Suggested value: 2.0</td></tr>
    <tr><td valign=top><em>ang_th</em>&nbsp;</td><td>Gradient angle tolerance in the region growing algorithm, in degrees. Suggested value: 22.5</td></tr>
    <tr><td valign=top><em>log_eps</em>&nbsp;</td><td>Detection threshold, accept if -log10(NFA) &gt; log_eps. The larger the value, the more strict the detector is, and will result in less detections. (Note that the 'minus sign' makes that this behavior is opposite to the one of NFA.) The value -log10(NFA) is equivalent but more intuitive than NFA:<ul>
<li>-1.0 gives an average of 10 false detections on noise</li><li>0.0 gives an average of 1 false detections on noise</li><li>1.0 gives an average of 0.1 false detections on nose</li><li>2.0 gives an average of 0.01 false detections on noise</li></ul>
Suggested value: 0.0</td></tr>
    <tr><td valign=top><em>density_th</em>&nbsp;</td><td>Minimal proportion of 'supporting' points in a rectangle. Suggested value: 0.7</td></tr>
    <tr><td valign=top><em>n_bins</em>&nbsp;</td><td>Number of bins used in the pseudo-ordering of gradient modulus. Suggested value: 1024</td></tr>
    <tr><td valign=top><em>reg_img</em>&nbsp;</td><td>Optional output: if desired, LSD will return an int image where each pixel indicates the line segment to which it belongs. Unused pixels have the value '0', while the used ones have the number of the line segment, numbered 1,2,3,..., in the same order as in the output list. If desired, a non NULL int** pointer must be assigned, and LSD will make that the pointer point to an int array of size reg_x x reg_y, where the pixel value at (x,y) is obtained with (*reg_img)[x+y*reg_x]. Note that the resulting image has the size of the image used for the processing, that is, the size of the input image scaled by the given factor 'scale'. If scale!=1 this size differs from XxY and that is the reason why its value is given by reg_x and reg_y. Suggested value: NULL</td></tr>
    <tr><td valign=top><em>reg_x</em>&nbsp;</td><td>Pointer to an int where LSD will put the X size 'reg_img' image, when asked for. Suggested value: NULL</td></tr>
    <tr><td valign=top><em>reg_y</em>&nbsp;</td><td>Pointer to an int where LSD will put the Y size 'reg_img' image, when asked for. Suggested value: NULL</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A double array of size 7 x n_out, containing the list of line segments detected. The array contains first 7 values of line segment number 1, then the 7 values of line segment number 2, and so on, and it finish by the 7 values of line segment number n_out. The seven values are:<ul>
<li>x1,y1,x2,y2,width,p,-log10(NFA)</li></ul>
for a line segment from coordinates (x1,y1) to (x2,y2), a width 'width', an angle precision of p in (0,1) given by angle_tolerance/180 degree, and NFA value 'NFA'. If 'out' is the returned pointer, the 7 values of line segment number 'n+1' are obtained with 'out[7*n+0]' to 'out[7*n+6]'. </dd></dl>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l02025">2025</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8c-source.html#l00305">add_7tuple()</a>, <a class="el" href="lsd_8c-source.html#l00416">image_int_s::data</a>, <a class="el" href="lsd_8c-source.html#l00471">image_double_s::data</a>, <a class="el" href="lsd_8c-source.html#l00345">image_char_s::data</a>, <a class="el" href="lsd_8c-source.html#l00159">error()</a>, <a class="el" href="lsd_8c-source.html#l00352">free_image_char()</a>, <a class="el" href="lsd_8c-source.html#l00478">free_image_double()</a>, <a class="el" href="lsd_8c-source.html#l00611">gaussian_sampler()</a>, <a class="el" href="lsd_8c.html#a13">image_char</a>, <a class="el" href="lsd_8c.html#a15">image_double</a>, <a class="el" href="lsd_8c.html#a14">image_int</a>, <a class="el" href="lsd_8c-source.html#l00752">ll_angle()</a>, <a class="el" href="lsd_8c-source.html#l00111">M_PI</a>, <a class="el" href="lsd_8c-source.html#l00388">new_image_char_ini()</a>, <a class="el" href="lsd_8c-source.html#l00513">new_image_double_ptr()</a>, <a class="el" href="lsd_8c-source.html#l00447">new_image_int_ini()</a>, <a class="el" href="lsd_8c-source.html#l00261">new_ntuple_list()</a>, <a class="el" href="lsd_8c-source.html#l00123">NOTDEF</a>, <a class="el" href="lsd_8c-source.html#l00132">NOTUSED</a>, <a class="el" href="lsd_8c.html#a12">ntuple_list</a>, <a class="el" href="lsd_8c-source.html#l01177">rect::p</a>, <a class="el" href="lsd_8c-source.html#l01756">rect_improve()</a>, <a class="el" href="lsd_8c-source.html#l01947">refine()</a>, <a class="el" href="lsd_8c-source.html#l01611">region2rect()</a>, <a class="el" href="lsd_8c-source.html#l01704">region_grow()</a>, <a class="el" href="lsd_8c-source.html#l00240">ntuple_list_s::size</a>, <a class="el" href="lsd_8c-source.html#l00243">ntuple_list_s::values</a>, <a class="el" href="lsd_8c-source.html#l01172">rect::width</a>, <a class="el" href="lsd_8c-source.html#l01171">rect::x1</a>, <a class="el" href="lsd_8c-source.html#l01171">rect::x2</a>, <a class="el" href="lsd_8c-source.html#l00417">image_int_s::xsize</a>, <a class="el" href="lsd_8c-source.html#l00346">image_char_s::xsize</a>, <a class="el" href="lsd_8c-source.html#l00472">image_double_s::xsize</a>, <a class="el" href="lsd_8c-source.html#l01171">rect::y1</a>, <a class="el" href="lsd_8c-source.html#l01171">rect::y2</a>, <a class="el" href="lsd_8c-source.html#l00417">image_int_s::ysize</a>, and <a class="el" href="lsd_8c-source.html#l00472">image_double_s::ysize</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l02212">lsd_scale_region()</a>.
<p>
<div class="fragment"><pre>02031 {
02032   <a class="code" href="structimage__double__s.html">image_double</a> image;
02033   <a class="code" href="structntuple__list__s.html">ntuple_list</a> out = <a class="code" href="lsd_8c.html#a20">new_ntuple_list</a>(7);
02034   <span class="keywordtype">double</span> * return_value;
02035   <a class="code" href="structimage__double__s.html">image_double</a> scaled_image,angles,modgrad;
02036   <a class="code" href="structimage__char__s.html">image_char</a> used;
02037   <a class="code" href="structimage__int__s.html">image_int</a> region = NULL;
02038   <span class="keyword">struct </span><a class="code" href="structcoorlist.html">coorlist</a> * list_p;
02039   <span class="keywordtype">void</span> * mem_p;
02040   <span class="keyword">struct </span><a class="code" href="structrect.html">rect</a> rec;
02041   <span class="keyword">struct </span><a class="code" href="structpoint.html">point</a> * reg;
02042   <span class="keywordtype">int</span> reg_size,min_reg_size,i;
02043   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> xsize,ysize;
02044   <span class="keywordtype">double</span> rho,reg_angle,prec,p,log_nfa,logNT;
02045   <span class="keywordtype">int</span> ls_count = 0;                   <span class="comment">/* line segments are numbered 1,2,3,... */</span>
02046 
02047 
02048   <span class="comment">/* check parameters */</span>
02049   <span class="keywordflow">if</span>( img == NULL || X &lt;= 0 || Y &lt;= 0 ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"invalid image input."</span>);
02050   <span class="keywordflow">if</span>( scale &lt;= 0.0 ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"'scale' value must be positive."</span>);
02051   <span class="keywordflow">if</span>( sigma_scale &lt;= 0.0 ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"'sigma_scale' value must be positive."</span>);
02052   <span class="keywordflow">if</span>( quant &lt; 0.0 ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"'quant' value must be positive."</span>);
02053   <span class="keywordflow">if</span>( ang_th &lt;= 0.0 || ang_th &gt;= 180.0 )
02054     <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"'ang_th' value must be in the range (0,180)."</span>);
02055   <span class="keywordflow">if</span>( density_th &lt; 0.0 || density_th &gt; 1.0 )
02056     <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"'density_th' value must be in the range [0,1]."</span>);
02057   <span class="keywordflow">if</span>( n_bins &lt;= 0 ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"'n_bins' value must be positive."</span>);
02058 
02059 
02060   <span class="comment">/* angle tolerance */</span>
02061   prec = <a class="code" href="lsd_8c.html#a1">M_PI</a> * ang_th / 180.0;
02062   p = ang_th / 180.0;
02063   rho = quant / sin(prec); <span class="comment">/* gradient magnitude threshold */</span>
02064 
02065 
02066   <span class="comment">/* load and scale image (if necessary) and compute angle at each pixel */</span>
02067   image = <a class="code" href="lsd_8c.html#a30">new_image_double_ptr</a>( (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>) X, (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>) Y, img );
02068   <span class="keywordflow">if</span>( scale != 1.0 )
02069     {
02070       scaled_image = <a class="code" href="lsd_8c.html#a32">gaussian_sampler</a>( image, scale, sigma_scale );
02071       angles = <a class="code" href="lsd_8c.html#a33">ll_angle</a>( scaled_image, rho, &amp;list_p, &amp;mem_p,
02072                          &amp;modgrad, (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>) n_bins );
02073       <a class="code" href="lsd_8c.html#a28">free_image_double</a>(scaled_image);
02074     }
02075   <span class="keywordflow">else</span>
02076     angles = <a class="code" href="lsd_8c.html#a33">ll_angle</a>( image, rho, &amp;list_p, &amp;mem_p, &amp;modgrad,
02077                        (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>) n_bins );
02078   xsize = angles-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a>;
02079   ysize = angles-&gt;<a class="code" href="structimage__double__s.html#o2">ysize</a>;
02080 
02081   <span class="comment">/* Number of Tests - NT</span>
02082 <span class="comment"></span>
02083 <span class="comment">     The theoretical number of tests is Np.(XY)^(5/2)</span>
02084 <span class="comment">     where X and Y are number of columns and rows of the image.</span>
02085 <span class="comment">     Np corresponds to the number of angle precisions considered.</span>
02086 <span class="comment">     As the procedure 'rect_improve' tests 5 times to halve the</span>
02087 <span class="comment">     angle precision, and 5 more times after improving other factors,</span>
02088 <span class="comment">     11 different precision values are potentially tested. Thus,</span>
02089 <span class="comment">     the number of tests is</span>
02090 <span class="comment">       11 * (X*Y)^(5/2)</span>
02091 <span class="comment">     whose logarithm value is</span>
02092 <span class="comment">       log10(11) + 5/2 * (log10(X) + log10(Y)).</span>
02093 <span class="comment">  */</span>
02094   logNT = 5.0 * ( log10( (<span class="keywordtype">double</span>) xsize ) + log10( (<span class="keywordtype">double</span>) ysize ) ) / 2.0
02095           + log10(11.0);
02096   min_reg_size = (<span class="keywordtype">int</span>) (-logNT/log10(p)); <span class="comment">/* minimal number of points in region</span>
02097 <span class="comment">                                             that can give a meaningful event */</span>
02098 
02099 
02100   <span class="comment">/* initialize some structures */</span>
02101   <span class="keywordflow">if</span>( reg_img != NULL &amp;&amp; reg_x != NULL &amp;&amp; reg_y != NULL ) <span class="comment">/* save region data */</span>
02102     region = <a class="code" href="lsd_8c.html#a27">new_image_int_ini</a>(angles-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a>,angles-&gt;<a class="code" href="structimage__double__s.html#o2">ysize</a>,0);
02103   used = <a class="code" href="lsd_8c.html#a25">new_image_char_ini</a>(xsize,ysize,NOTUSED);
02104   reg = (<span class="keyword">struct </span><a class="code" href="structpoint.html">point</a> *) calloc( (size_t) (xsize*ysize), <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structpoint.html">point</a>) );
02105   <span class="keywordflow">if</span>( reg == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"not enough memory!"</span>);
02106 
02107 
02108   <span class="comment">/* search for line segments */</span>
02109   <span class="keywordflow">for</span>(; list_p != NULL; list_p = list_p-&gt;next )
02110     <span class="keywordflow">if</span>( used-&gt;<a class="code" href="structimage__char__s.html#o0">data</a>[ list_p-&gt;x + list_p-&gt;y * used-&gt;<a class="code" href="structimage__char__s.html#o1">xsize</a> ] == <a class="code" href="lsd_8c.html#a7">NOTUSED</a> &amp;&amp;
02111         angles-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>[ list_p-&gt;x + list_p-&gt;y * angles-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a> ] != <a class="code" href="lsd_8c.html#a4">NOTDEF</a> )
02112        <span class="comment">/* there is no risk of double comparison problems here</span>
02113 <span class="comment">          because we are only interested in the exact NOTDEF value */</span>
02114       {
02115         <span class="comment">/* find the region of connected point and ~equal angle */</span>
02116         <a class="code" href="lsd_8c.html#a50">region_grow</a>( list_p-&gt;x, list_p-&gt;y, angles, reg, &amp;reg_size,
02117                      &amp;reg_angle, used, prec );
02118 
02119         <span class="comment">/* reject small regions */</span>
02120         <span class="keywordflow">if</span>( reg_size &lt; min_reg_size ) <span class="keywordflow">continue</span>;
02121 
02122         <span class="comment">/* construct rectangular approximation for the region */</span>
02123         <a class="code" href="lsd_8c.html#a49">region2rect</a>(reg,reg_size,modgrad,reg_angle,prec,p,&amp;rec);
02124 
02125         <span class="comment">/* Check if the rectangle exceeds the minimal density of</span>
02126 <span class="comment">           region points. If not, try to improve the region.</span>
02127 <span class="comment">           The rectangle will be rejected if the final one does</span>
02128 <span class="comment">           not fulfill the minimal density condition.</span>
02129 <span class="comment">           This is an addition to the original LSD algorithm published in</span>
02130 <span class="comment">           "LSD: A Fast Line Segment Detector with a False Detection Control"</span>
02131 <span class="comment">           by R. Grompone von Gioi, J. Jakubowicz, J.M. Morel, and G. Randall.</span>
02132 <span class="comment">           The original algorithm is obtained with density_th = 0.0.</span>
02133 <span class="comment">         */</span>
02134         <span class="keywordflow">if</span>( !<a class="code" href="lsd_8c.html#a53">refine</a>( reg, &amp;reg_size, modgrad, reg_angle,
02135                      prec, p, &amp;rec, used, angles, density_th ) ) <span class="keywordflow">continue</span>;
02136 
02137         <span class="comment">/* compute NFA value */</span>
02138         log_nfa = <a class="code" href="lsd_8c.html#a51">rect_improve</a>(&amp;rec,angles,logNT,log_eps);
02139         <span class="keywordflow">if</span>( log_nfa &lt;= log_eps ) <span class="keywordflow">continue</span>;
02140 
02141         <span class="comment">/* A New Line Segment was found! */</span>
02142         ++ls_count;  <span class="comment">/* increase line segment counter */</span>
02143 
02144         <span class="comment">/*</span>
02145 <span class="comment">           The gradient was computed with a 2x2 mask, its value corresponds to</span>
02146 <span class="comment">           points with an offset of (0.5,0.5), that should be added to output.</span>
02147 <span class="comment">           The coordinates origin is at the center of pixel (0,0).</span>
02148 <span class="comment">         */</span>
02149         rec.<a class="code" href="structrect.html#o0">x1</a> += 0.5; rec.<a class="code" href="structrect.html#o1">y1</a> += 0.5;
02150         rec.<a class="code" href="structrect.html#o2">x2</a> += 0.5; rec.<a class="code" href="structrect.html#o3">y2</a> += 0.5;
02151 
02152         <span class="comment">/* scale the result values if a subsampling was performed */</span>
02153         <span class="keywordflow">if</span>( scale != 1.0 )
02154           {
02155             rec.<a class="code" href="structrect.html#o0">x1</a> /= scale; rec.<a class="code" href="structrect.html#o1">y1</a> /= scale;
02156             rec.<a class="code" href="structrect.html#o2">x2</a> /= scale; rec.<a class="code" href="structrect.html#o3">y2</a> /= scale;
02157             rec.<a class="code" href="structrect.html#o4">width</a> /= scale;
02158           }
02159 
02160         <span class="comment">/* add line segment found to output */</span>
02161         <a class="code" href="lsd_8c.html#a22">add_7tuple</a>( out, rec.<a class="code" href="structrect.html#o0">x1</a>, rec.<a class="code" href="structrect.html#o1">y1</a>, rec.<a class="code" href="structrect.html#o2">x2</a>, rec.<a class="code" href="structrect.html#o3">y2</a>,
02162                          rec.<a class="code" href="structrect.html#o4">width</a>, rec.<a class="code" href="structrect.html#o11">p</a>, log_nfa );
02163 
02164         <span class="comment">/* add region number to 'region' image if needed */</span>
02165         <span class="keywordflow">if</span>( region != NULL )
02166           <span class="keywordflow">for</span>(i=0; i&lt;reg_size; i++)
02167             region-&gt;<a class="code" href="structimage__int__s.html#o0">data</a>[ reg[i].x + reg[i].y * region-&gt;<a class="code" href="structimage__int__s.html#o1">xsize</a> ] = ls_count;
02168       }
02169 
02170 
02171   <span class="comment">/* free memory */</span>
02172   free( (<span class="keywordtype">void</span> *) image );   <span class="comment">/* only the double_image structure should be freed,</span>
02173 <span class="comment">                               the data pointer was provided to this functions</span>
02174 <span class="comment">                               and should not be destroyed.                 */</span>
02175   <a class="code" href="lsd_8c.html#a28">free_image_double</a>(angles);
02176   <a class="code" href="lsd_8c.html#a28">free_image_double</a>(modgrad);
02177   <a class="code" href="lsd_8c.html#a23">free_image_char</a>(used);
02178   free( (<span class="keywordtype">void</span> *) reg );
02179   free( (<span class="keywordtype">void</span> *) mem_p );
02180 
02181   <span class="comment">/* return the result */</span>
02182   <span class="keywordflow">if</span>( reg_img != NULL &amp;&amp; reg_x != NULL &amp;&amp; reg_y != NULL )
02183     {
02184       <span class="keywordflow">if</span>( region == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"'region' should be a valid image."</span>);
02185       *reg_img = region-&gt;<a class="code" href="structimage__int__s.html#o0">data</a>;
02186       <span class="keywordflow">if</span>( region-&gt;<a class="code" href="structimage__int__s.html#o1">xsize</a> &gt; (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>) INT_MAX ||
02187           region-&gt;<a class="code" href="structimage__int__s.html#o1">xsize</a> &gt; (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>) INT_MAX )
02188         <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"region image to big to fit in INT sizes."</span>);
02189       *reg_x = (<span class="keywordtype">int</span>) (region-&gt;<a class="code" href="structimage__int__s.html#o1">xsize</a>);
02190       *reg_y = (<span class="keywordtype">int</span>) (region-&gt;<a class="code" href="structimage__int__s.html#o2">ysize</a>);
02191 
02192       <span class="comment">/* free the 'region' structure.</span>
02193 <span class="comment">         we cannot use the function 'free_image_int' because we need to keep</span>
02194 <span class="comment">         the memory with the image data to be returned by this function. */</span>
02195       free( (<span class="keywordtype">void</span> *) region );
02196     }
02197   <span class="keywordflow">if</span>( out-&gt;<a class="code" href="structntuple__list__s.html#o0">size</a> &gt; (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>) INT_MAX )
02198     <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"too many detections to fit in an INT."</span>);
02199   *n_out = (<span class="keywordtype">int</span>) (out-&gt;<a class="code" href="structntuple__list__s.html#o0">size</a>);
02200 
02201   return_value = out-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a>;
02202   free( (<span class="keywordtype">void</span> *) out );  <span class="comment">/* only the 'ntuple_list' structure must be freed,</span>
02203 <span class="comment">                            but the 'values' pointer must be keep to return</span>
02204 <span class="comment">                            as a result. */</span>
02205 
02206   <span class="keywordflow">return</span> return_value;
02207 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8c_a54_cgraph.png" border="0" usemap="#lsd_8c_a54_cgraph_map" alt=""></center>
<map name="lsd_8c_a54_cgraph_map">
<area href="lsd_8c.html#a22" shape="rect" coords="449,7,537,34" alt="">
<area href="lsd_8c.html#a16" shape="rect" coords="610,286,661,313" alt="">
<area href="lsd_8c.html#a23" shape="rect" coords="431,109,554,135" alt="">
<area href="lsd_8c.html#a28" shape="rect" coords="425,159,561,186" alt="">
<area href="lsd_8c.html#a32" shape="rect" coords="229,210,359,237" alt="">
<area href="lsd_8c.html#a20" shape="rect" coords="435,261,550,287" alt="">
<area href="lsd_8c.html#a33" shape="rect" coords="459,311,526,338" alt="">
<area href="lsd_8c.html#a25" shape="rect" coords="222,362,366,389" alt="">
<area href="lsd_8c.html#a30" shape="rect" coords="214,413,374,439" alt="">
<area href="lsd_8c.html#a27" shape="rect" coords="227,463,361,490" alt="">
<area href="lsd_8c.html#a51" shape="rect" coords="245,514,343,541" alt="">
<area href="lsd_8c.html#a53" shape="rect" coords="266,615,322,642" alt="">
<area href="lsd_8c.html#a49" shape="rect" coords="449,539,537,566" alt="">
<area href="lsd_8c.html#a50" shape="rect" coords="446,641,539,667" alt="">
</map>
<a class="anchor" name="a33" doxytag="lsd.c::ll_angle" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="structimage__double__s.html">image_double</a> ll_angle </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structimage__double__s.html">image_double</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>in</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>threshold</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>struct <a class="el" href="structcoorlist.html">coorlist</a> **&nbsp;</td>
          <td class="mdname" nowrap> <em>list_p</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>void **&nbsp;</td>
          <td class="mdname" nowrap> <em>mem_p</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="structimage__double__s.html">image_double</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>modgrad</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>unsigned int&nbsp;</td>
          <td class="mdname" nowrap> <em>n_bins</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Computes the direction of the level line of 'in' at each point. 
<p>
The result is:<ul>
<li>an image_double with the angle at each pixel, or NOTDEF if not defined.</li><li>the image_double 'modgrad' (a pointer is passed as argument) with the gradient magnitude at each point.</li><li>a list of pixels 'list_p' roughly ordered by decreasing gradient magnitude. (The order is made by classifying points into bins by gradient magnitude. The parameters 'n_bins' and 'max_grad' specify the number of bins and the gradient modulus at the highest bin. The pixels in the list would be in decreasing gradient magnitude, up to a precision of the size of the bins.)</li><li>a pointer 'mem_p' to the memory used by 'list_p' to be able to free the memory when it is not used anymore. </li></ul>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l00752">752</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8c-source.html#l00471">image_double_s::data</a>, <a class="el" href="lsd_8c-source.html#l00159">error()</a>, <a class="el" href="lsd_8c.html#a15">image_double</a>, <a class="el" href="lsd_8c-source.html#l00489">new_image_double()</a>, <a class="el" href="lsd_8c-source.html#l00123">NOTDEF</a>, <a class="el" href="lsd_8c-source.html#l00472">image_double_s::xsize</a>, and <a class="el" href="lsd_8c-source.html#l00472">image_double_s::ysize</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l02025">LineSegmentDetection()</a>.
<p>
<div class="fragment"><pre>00755 {
00756   <a class="code" href="structimage__double__s.html">image_double</a> g;
00757   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n,p,x,y,adr,i;
00758   <span class="keywordtype">double</span> com1,com2,gx,gy,norm,norm2;
00759   <span class="comment">/* the rest of the variables are used for pseudo-ordering</span>
00760 <span class="comment">     the gradient magnitude values */</span>
00761   <span class="keywordtype">int</span> list_count = 0;
00762   <span class="keyword">struct </span><a class="code" href="structcoorlist.html">coorlist</a> * list;
00763   <span class="keyword">struct </span><a class="code" href="structcoorlist.html">coorlist</a> ** range_l_s; <span class="comment">/* array of pointers to start of bin list */</span>
00764   <span class="keyword">struct </span><a class="code" href="structcoorlist.html">coorlist</a> ** range_l_e; <span class="comment">/* array of pointers to end of bin list */</span>
00765   <span class="keyword">struct </span><a class="code" href="structcoorlist.html">coorlist</a> * start;
00766   <span class="keyword">struct </span><a class="code" href="structcoorlist.html">coorlist</a> * end;
00767   <span class="keywordtype">double</span> max_grad = 0.0;
00768 
00769   <span class="comment">/* check parameters */</span>
00770   <span class="keywordflow">if</span>( in == NULL || in-&gt;<a class="code" href="structimage__double__s.html#o0">data</a> == NULL || in-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a> == 0 || in-&gt;<a class="code" href="structimage__double__s.html#o2">ysize</a> == 0 )
00771     <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"ll_angle: invalid image."</span>);
00772   <span class="keywordflow">if</span>( threshold &lt; 0.0 ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"ll_angle: 'threshold' must be positive."</span>);
00773   <span class="keywordflow">if</span>( list_p == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"ll_angle: NULL pointer 'list_p'."</span>);
00774   <span class="keywordflow">if</span>( mem_p == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"ll_angle: NULL pointer 'mem_p'."</span>);
00775   <span class="keywordflow">if</span>( modgrad == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"ll_angle: NULL pointer 'modgrad'."</span>);
00776   <span class="keywordflow">if</span>( n_bins == 0 ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"ll_angle: 'n_bins' must be positive."</span>);
00777 
00778   <span class="comment">/* image size shortcuts */</span>
00779   n = in-&gt;<a class="code" href="structimage__double__s.html#o2">ysize</a>;
00780   p = in-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a>;
00781 
00782   <span class="comment">/* allocate output image */</span>
00783   g = <a class="code" href="lsd_8c.html#a29">new_image_double</a>(in-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a>,in-&gt;<a class="code" href="structimage__double__s.html#o2">ysize</a>);
00784 
00785   <span class="comment">/* get memory for the image of gradient modulus */</span>
00786   *modgrad = <a class="code" href="lsd_8c.html#a29">new_image_double</a>(in-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a>,in-&gt;<a class="code" href="structimage__double__s.html#o2">ysize</a>);
00787 
00788   <span class="comment">/* get memory for "ordered" list of pixels */</span>
00789   list = (<span class="keyword">struct </span><a class="code" href="structcoorlist.html">coorlist</a> *) calloc( (size_t) (n*p), <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structcoorlist.html">coorlist</a>) );
00790   *mem_p = (<span class="keywordtype">void</span> *) list;
00791   range_l_s = (<span class="keyword">struct </span><a class="code" href="structcoorlist.html">coorlist</a> **) calloc( (size_t) n_bins,
00792                                            <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structcoorlist.html">coorlist</a> *) );
00793   range_l_e = (<span class="keyword">struct </span><a class="code" href="structcoorlist.html">coorlist</a> **) calloc( (size_t) n_bins,
00794                                            <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structcoorlist.html">coorlist</a> *) );
00795   <span class="keywordflow">if</span>( list == NULL || range_l_s == NULL || range_l_e == NULL )
00796     <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"not enough memory."</span>);
00797   <span class="keywordflow">for</span>(i=0;i&lt;n_bins;i++) range_l_s[i] = range_l_e[i] = NULL;
00798 
00799   <span class="comment">/* 'undefined' on the down and right boundaries */</span>
00800   <span class="keywordflow">for</span>(x=0;x&lt;p;x++) g-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>[(n-1)*p+x] = <a class="code" href="lsd_8c.html#a4">NOTDEF</a>;
00801   <span class="keywordflow">for</span>(y=0;y&lt;n;y++) g-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>[p*y+p-1]   = <a class="code" href="lsd_8c.html#a4">NOTDEF</a>;
00802 
00803   <span class="comment">/* compute gradient on the remaining pixels */</span>
00804   <span class="keywordflow">for</span>(x=0;x&lt;p-1;x++)
00805     <span class="keywordflow">for</span>(y=0;y&lt;n-1;y++)
00806       {
00807         adr = y*p+x;
00808 
00809         <span class="comment">/*</span>
00810 <span class="comment">           Norm 2 computation using 2x2 pixel window:</span>
00811 <span class="comment">             A B</span>
00812 <span class="comment">             C D</span>
00813 <span class="comment">           and</span>
00814 <span class="comment">             com1 = D-A,  com2 = B-C.</span>
00815 <span class="comment">           Then</span>
00816 <span class="comment">             gx = B+D - (A+C)   horizontal difference</span>
00817 <span class="comment">             gy = C+D - (A+B)   vertical difference</span>
00818 <span class="comment">           com1 and com2 are just to avoid 2 additions.</span>
00819 <span class="comment">         */</span>
00820         com1 = in-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>[adr+p+1] - in-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>[adr];
00821         com2 = in-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>[adr+1]   - in-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>[adr+p];
00822 
00823         gx = com1+com2; <span class="comment">/* gradient x component */</span>
00824         gy = com1-com2; <span class="comment">/* gradient y component */</span>
00825         norm2 = gx*gx+gy*gy;
00826         norm = sqrt( norm2 / 4.0 ); <span class="comment">/* gradient norm */</span>
00827 
00828         (*modgrad)-&gt;data[adr] = norm; <span class="comment">/* store gradient norm */</span>
00829 
00830         <span class="keywordflow">if</span>( norm &lt;= threshold ) <span class="comment">/* norm too small, gradient no defined */</span>
00831           g-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>[adr] = <a class="code" href="lsd_8c.html#a4">NOTDEF</a>; <span class="comment">/* gradient angle not defined */</span>
00832         <span class="keywordflow">else</span>
00833           {
00834             <span class="comment">/* gradient angle computation */</span>
00835             g-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>[adr] = atan2(gx,-gy);
00836 
00837             <span class="comment">/* look for the maximum of the gradient */</span>
00838             <span class="keywordflow">if</span>( norm &gt; max_grad ) max_grad = norm;
00839           }
00840       }
00841 
00842   <span class="comment">/* compute histogram of gradient values */</span>
00843   <span class="keywordflow">for</span>(x=0;x&lt;p-1;x++)
00844     <span class="keywordflow">for</span>(y=0;y&lt;n-1;y++)
00845       {
00846         norm = (*modgrad)-&gt;data[y*p+x];
00847 
00848         <span class="comment">/* store the point in the right bin according to its norm */</span>
00849         i = (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>) (norm * (<span class="keywordtype">double</span>) n_bins / max_grad);
00850         <span class="keywordflow">if</span>( i &gt;= n_bins ) i = n_bins-1;
00851         <span class="keywordflow">if</span>( range_l_e[i] == NULL )
00852           range_l_s[i] = range_l_e[i] = list+list_count++;
00853         <span class="keywordflow">else</span>
00854           {
00855             range_l_e[i]-&gt;next = list+list_count;
00856             range_l_e[i] = list+list_count++;
00857           }
00858         range_l_e[i]-&gt;x = (<span class="keywordtype">int</span>) x;
00859         range_l_e[i]-&gt;y = (<span class="keywordtype">int</span>) y;
00860         range_l_e[i]-&gt;next = NULL;
00861       }
00862 
00863   <span class="comment">/* Make the list of pixels (almost) ordered by norm value.</span>
00864 <span class="comment">     It starts by the larger bin, so the list starts by the</span>
00865 <span class="comment">     pixels with the highest gradient value. Pixels would be ordered</span>
00866 <span class="comment">     by norm value, up to a precision given by max_grad/n_bins.</span>
00867 <span class="comment">   */</span>
00868   <span class="keywordflow">for</span>(i=n_bins-1; i&gt;0 &amp;&amp; range_l_s[i]==NULL; i--);
00869   start = range_l_s[i];
00870   end = range_l_e[i];
00871   <span class="keywordflow">if</span>( start != NULL )
00872     <span class="keywordflow">while</span>(i&gt;0)
00873       {
00874         --i;
00875         <span class="keywordflow">if</span>( range_l_s[i] != NULL )
00876           {
00877             end-&gt;next = range_l_s[i];
00878             end = range_l_e[i];
00879           }
00880       }
00881   *list_p = start;
00882 
00883   <span class="comment">/* free memory */</span>
00884   free( (<span class="keywordtype">void</span> *) range_l_s );
00885   free( (<span class="keywordtype">void</span> *) range_l_e );
00886 
00887   <span class="keywordflow">return</span> g;
00888 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8c_a33_cgraph.png" border="0" usemap="#lsd_8c_a33_cgraph_map" alt=""></center>
<map name="lsd_8c_a33_cgraph_map">
<area href="lsd_8c.html#a16" shape="rect" coords="312,33,362,59" alt="">
<area href="lsd_8c.html#a29" shape="rect" coords="126,58,262,85" alt="">
</map>
<a class="anchor" name="a37" doxytag="lsd.c::log_gamma_lanczos" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> double log_gamma_lanczos </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">double&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>x</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Computes the natural logarithm of the absolute value of the gamma function of x using the Lanczos approximation. 
<p>
See <a href="http://www.rskey.org/gamma.htm">http://www.rskey.org/gamma.htm</a><p>
The formula used is <p class=formulaDsp>
<img class=formulaDsp alt="\[ \Gamma(x) = \frac{ \sum_{n=0}^{N} q_n x^n }{ \Pi_{n=0}^{N} (x+n) } (x+5.5)^{x+0.5} e^{-(x+5.5)} \]" src="form_3.png">
<p>
 so <p class=formulaDsp>
<img class=formulaDsp alt="\[ \log\Gamma(x) = \log\left( \sum_{n=0}^{N} q_n x^n \right) + (x+0.5) \log(x+5.5) - (x+5.5) - \sum_{n=0}^{N} \log(x+n) \]" src="form_4.png">
<p>
 and q0 = 75122.6331530, q1 = 80916.6278952, q2 = 36308.2951477, q3 = 8687.24529705, q4 = 1168.92649479, q5 = 83.8676043424, q6 = 2.50662827511. 
<p>
Definition at line <a class="el" href="lsd_8c-source.html#l00980">980</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
<div class="fragment"><pre>00981 {
00982   <span class="keyword">static</span> <span class="keywordtype">double</span> q[7] = { 75122.6331530, 80916.6278952, 36308.2951477,
00983                          8687.24529705, 1168.92649479, 83.8676043424,
00984                          2.50662827511 };
00985   <span class="keywordtype">double</span> a = (x+0.5) * log(x+5.5) - (x+5.5);
00986   <span class="keywordtype">double</span> b = 0.0;
00987   <span class="keywordtype">int</span> n;
00988 
00989   <span class="keywordflow">for</span>(n=0;n&lt;7;n++)
00990     {
00991       a -= log( x + (<span class="keywordtype">double</span>) n );
00992       b += q[n] * pow( x, (<span class="keywordtype">double</span>) n );
00993     }
00994   <span class="keywordflow">return</span> a + log(b);
00995 }
</pre></div>    </td>
  </tr>
</table>
<a class="anchor" name="a38" doxytag="lsd.c::log_gamma_windschitl" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> double log_gamma_windschitl </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">double&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>x</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Computes the natural logarithm of the absolute value of the gamma function of x using Windschitl method. 
<p>
See <a href="http://www.rskey.org/gamma.htm">http://www.rskey.org/gamma.htm</a><p>
The formula used is <p class=formulaDsp>
<img class=formulaDsp alt="\[ \Gamma(x) = \sqrt{\frac{2\pi}{x}} \left( \frac{x}{e} \sqrt{ x\sinh(1/x) + \frac{1}{810x^6} } \right)^x \]" src="form_5.png">
<p>
 so <p class=formulaDsp>
<img class=formulaDsp alt="\[ \log\Gamma(x) = 0.5\log(2\pi) + (x-0.5)\log(x) - x + 0.5x\log\left( x\sinh(1/x) + \frac{1}{810x^6} \right). \]" src="form_6.png">
<p>
 This formula is a good approximation when x &gt; 15. 
<p>
Definition at line <a class="el" href="lsd_8c-source.html#l01014">1014</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
<div class="fragment"><pre>01015 {
01016   <span class="keywordflow">return</span> 0.918938533204673 + (x-0.5)*log(x) - x
01017          + 0.5*x*log( x*sinh(1/x) + 1/(810.0*pow(x,6.0)) );
01018 }
</pre></div>    </td>
  </tr>
</table>
<a class="anchor" name="a57" doxytag="lsd.c::lsd" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> double* lsd </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int *&nbsp;</td>
          <td class="mdname" nowrap> <em>n_out</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap> <em>img</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>X</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>Y</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
LSD Simple Interface. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>n_out</em>&nbsp;</td><td>Pointer to an int where LSD will store the number of line segments detected.</td></tr>
    <tr><td valign=top><em>img</em>&nbsp;</td><td>Pointer to input image data. It must be an array of doubles of size X x Y, and the pixel at coordinates (x,y) is obtained by img[x+y*X].</td></tr>
    <tr><td valign=top><em>X</em>&nbsp;</td><td>X size of the image: the number of columns.</td></tr>
    <tr><td valign=top><em>Y</em>&nbsp;</td><td>Y size of the image: the number of rows.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A double array of size 7 x n_out, containing the list of line segments detected. The array contains first 7 values of line segment number 1, then the 7 values of line segment number 2, and so on, and it finish by the 7 values of line segment number n_out. The seven values are:<ul>
<li>x1,y1,x2,y2,width,p,-log10(NFA)</li></ul>
for a line segment from coordinates (x1,y1) to (x2,y2), a width 'width', an angle precision of p in (0,1) given by angle_tolerance/180 degree, and NFA value 'NFA'. If 'out' is the returned pointer, the 7 values of line segment number 'n+1' are obtained with 'out[7*n+0]' to 'out[7*n+6]'. </dd></dl>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l02243">2243</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8c-source.html#l02235">lsd_scale()</a>.
<p>
<div class="fragment"><pre>02244 {
02245   <span class="comment">/* LSD parameters */</span>
02246   <span class="keywordtype">double</span> scale = 0.8;       <span class="comment">/* Scale the image by Gaussian filter to 'scale'. */</span>
02247 
02248   <span class="keywordflow">return</span> <a class="code" href="lsd_8c.html#a56">lsd_scale</a>(n_out,img,X,Y,scale);
02249 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8c_a57_cgraph.png" border="0" usemap="#lsd_8c_a57_cgraph_map" alt=""></center>
<map name="lsd_8c_a57_cgraph_map">
<area href="lsd_8c.html#a56" shape="rect" coords="95,8,173,34" alt="">
<area href="lsd_8c.html#a55" shape="rect" coords="221,8,343,34" alt="">
<area href="lsd_8c.html#a54" shape="rect" coords="391,8,549,34" alt="">
</map>
<a class="anchor" name="a56" doxytag="lsd.c::lsd_scale" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> double* lsd_scale </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int *&nbsp;</td>
          <td class="mdname" nowrap> <em>n_out</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap> <em>img</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>X</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>Y</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>scale</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
LSD Simple Interface with Scale. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>n_out</em>&nbsp;</td><td>Pointer to an int where LSD will store the number of line segments detected.</td></tr>
    <tr><td valign=top><em>img</em>&nbsp;</td><td>Pointer to input image data. It must be an array of doubles of size X x Y, and the pixel at coordinates (x,y) is obtained by img[x+y*X].</td></tr>
    <tr><td valign=top><em>X</em>&nbsp;</td><td>X size of the image: the number of columns.</td></tr>
    <tr><td valign=top><em>Y</em>&nbsp;</td><td>Y size of the image: the number of rows.</td></tr>
    <tr><td valign=top><em>scale</em>&nbsp;</td><td>When different from 1.0, LSD will scale the input image by 'scale' factor by Gaussian filtering, before detecting line segments. Example: if scale=0.8, the input image will be subsampled to 80% of its size, before the line segment detector is applied. Suggested value: 0.8</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A double array of size 7 x n_out, containing the list of line segments detected. The array contains first 7 values of line segment number 1, then the 7 values of line segment number 2, and so on, and it finish by the 7 values of line segment number n_out. The seven values are:<ul>
<li>x1,y1,x2,y2,width,p,-log10(NFA)</li></ul>
for a line segment from coordinates (x1,y1) to (x2,y2), a width 'width', an angle precision of p in (0,1) given by angle_tolerance/180 degree, and NFA value 'NFA'. If 'out' is the returned pointer, the 7 values of line segment number 'n+1' are obtained with 'out[7*n+0]' to 'out[7*n+6]'. </dd></dl>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l02235">2235</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8c-source.html#l02212">lsd_scale_region()</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l02243">lsd()</a>.
<p>
<div class="fragment"><pre>02236 {
02237   <span class="keywordflow">return</span> <a class="code" href="lsd_8c.html#a55">lsd_scale_region</a>(n_out,img,X,Y,scale,NULL,NULL,NULL);
02238 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8c_a56_cgraph.png" border="0" usemap="#lsd_8c_a56_cgraph_map" alt=""></center>
<map name="lsd_8c_a56_cgraph_map">
<area href="lsd_8c.html#a55" shape="rect" coords="133,337,255,363" alt="">
<area href="lsd_8c.html#a54" shape="rect" coords="303,337,461,363" alt="">
<area href="lsd_8c.html#a22" shape="rect" coords="745,7,833,34" alt="">
<area href="lsd_8c.html#a16" shape="rect" coords="906,286,957,313" alt="">
<area href="lsd_8c.html#a23" shape="rect" coords="727,109,850,135" alt="">
<area href="lsd_8c.html#a28" shape="rect" coords="721,159,857,186" alt="">
<area href="lsd_8c.html#a32" shape="rect" coords="525,210,655,237" alt="">
<area href="lsd_8c.html#a20" shape="rect" coords="731,261,846,287" alt="">
<area href="lsd_8c.html#a33" shape="rect" coords="755,311,822,338" alt="">
<area href="lsd_8c.html#a25" shape="rect" coords="518,362,662,389" alt="">
<area href="lsd_8c.html#a30" shape="rect" coords="510,413,670,439" alt="">
<area href="lsd_8c.html#a27" shape="rect" coords="523,463,657,490" alt="">
<area href="lsd_8c.html#a51" shape="rect" coords="541,514,639,541" alt="">
<area href="lsd_8c.html#a53" shape="rect" coords="562,615,618,642" alt="">
<area href="lsd_8c.html#a49" shape="rect" coords="745,539,833,566" alt="">
<area href="lsd_8c.html#a50" shape="rect" coords="742,641,835,667" alt="">
</map>
<a class="anchor" name="a55" doxytag="lsd.c::lsd_scale_region" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> double* lsd_scale_region </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int *&nbsp;</td>
          <td class="mdname" nowrap> <em>n_out</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap> <em>img</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>X</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>Y</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>scale</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int **&nbsp;</td>
          <td class="mdname" nowrap> <em>reg_img</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>reg_x</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>reg_y</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
LSD Simple Interface with Scale and Region output. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>n_out</em>&nbsp;</td><td>Pointer to an int where LSD will store the number of line segments detected.</td></tr>
    <tr><td valign=top><em>img</em>&nbsp;</td><td>Pointer to input image data. It must be an array of doubles of size X x Y, and the pixel at coordinates (x,y) is obtained by img[x+y*X].</td></tr>
    <tr><td valign=top><em>X</em>&nbsp;</td><td>X size of the image: the number of columns.</td></tr>
    <tr><td valign=top><em>Y</em>&nbsp;</td><td>Y size of the image: the number of rows.</td></tr>
    <tr><td valign=top><em>scale</em>&nbsp;</td><td>When different from 1.0, LSD will scale the input image by 'scale' factor by Gaussian filtering, before detecting line segments. Example: if scale=0.8, the input image will be subsampled to 80% of its size, before the line segment detector is applied. Suggested value: 0.8</td></tr>
    <tr><td valign=top><em>reg_img</em>&nbsp;</td><td>Optional output: if desired, LSD will return an int image where each pixel indicates the line segment to which it belongs. Unused pixels have the value '0', while the used ones have the number of the line segment, numbered 1,2,3,..., in the same order as in the output list. If desired, a non NULL int** pointer must be assigned, and LSD will make that the pointer point to an int array of size reg_x x reg_y, where the pixel value at (x,y) is obtained with (*reg_img)[x+y*reg_x]. Note that the resulting image has the size of the image used for the processing, that is, the size of the input image scaled by the given factor 'scale'. If scale!=1 this size differs from XxY and that is the reason why its value is given by reg_x and reg_y. Suggested value: NULL</td></tr>
    <tr><td valign=top><em>reg_x</em>&nbsp;</td><td>Pointer to an int where LSD will put the X size 'reg_img' image, when asked for. Suggested value: NULL</td></tr>
    <tr><td valign=top><em>reg_y</em>&nbsp;</td><td>Pointer to an int where LSD will put the Y size 'reg_img' image, when asked for. Suggested value: NULL</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A double array of size 7 x n_out, containing the list of line segments detected. The array contains first 7 values of line segment number 1, then the 7 values of line segment number 2, and so on, and it finish by the 7 values of line segment number n_out. The seven values are:<ul>
<li>x1,y1,x2,y2,width,p,-log10(NFA)</li></ul>
for a line segment from coordinates (x1,y1) to (x2,y2), a width 'width', an angle precision of p in (0,1) given by angle_tolerance/180 degree, and NFA value 'NFA'. If 'out' is the returned pointer, the 7 values of line segment number 'n+1' are obtained with 'out[7*n+0]' to 'out[7*n+6]'. </dd></dl>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l02212">2212</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8c-source.html#l02025">LineSegmentDetection()</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l02235">lsd_scale()</a>.
<p>
<div class="fragment"><pre>02215 {
02216   <span class="comment">/* LSD parameters */</span>
02217   <span class="keywordtype">double</span> sigma_scale = 0.6; <span class="comment">/* Sigma for Gaussian filter is computed as</span>
02218 <span class="comment">                                sigma = sigma_scale/scale.                    */</span>
02219   <span class="keywordtype">double</span> quant = 2.0;       <span class="comment">/* Bound to the quantization error on the</span>
02220 <span class="comment">                                gradient norm.                                */</span>
02221   <span class="keywordtype">double</span> ang_th = 22.5;     <span class="comment">/* Gradient angle tolerance in degrees.           */</span>
02222   <span class="keywordtype">double</span> log_eps = 0.0;     <span class="comment">/* Detection threshold: -log10(NFA) &gt; log_eps     */</span>
02223   <span class="keywordtype">double</span> density_th = 0.7;  <span class="comment">/* Minimal density of region points in rectangle. */</span>
02224   <span class="keywordtype">int</span> n_bins = 1024;        <span class="comment">/* Number of bins in pseudo-ordering of gradient</span>
02225 <span class="comment">                               modulus.                                       */</span>
02226 
02227   <span class="keywordflow">return</span> <a class="code" href="lsd_8c.html#a54">LineSegmentDetection</a>( n_out, img, X, Y, scale, sigma_scale, quant,
02228                                ang_th, log_eps, density_th, n_bins,
02229                                reg_img, reg_x, reg_y );
02230 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8c_a55_cgraph.png" border="0" usemap="#lsd_8c_a55_cgraph_map" alt=""></center>
<map name="lsd_8c_a55_cgraph_map">
<area href="lsd_8c.html#a54" shape="rect" coords="178,337,336,363" alt="">
<area href="lsd_8c.html#a22" shape="rect" coords="620,7,708,34" alt="">
<area href="lsd_8c.html#a16" shape="rect" coords="781,286,832,313" alt="">
<area href="lsd_8c.html#a23" shape="rect" coords="602,109,725,135" alt="">
<area href="lsd_8c.html#a28" shape="rect" coords="596,159,732,186" alt="">
<area href="lsd_8c.html#a32" shape="rect" coords="400,210,530,237" alt="">
<area href="lsd_8c.html#a20" shape="rect" coords="606,261,721,287" alt="">
<area href="lsd_8c.html#a33" shape="rect" coords="630,311,697,338" alt="">
<area href="lsd_8c.html#a25" shape="rect" coords="393,362,537,389" alt="">
<area href="lsd_8c.html#a30" shape="rect" coords="385,413,545,439" alt="">
<area href="lsd_8c.html#a27" shape="rect" coords="398,463,532,490" alt="">
<area href="lsd_8c.html#a51" shape="rect" coords="416,514,514,541" alt="">
<area href="lsd_8c.html#a53" shape="rect" coords="437,615,493,642" alt="">
<area href="lsd_8c.html#a49" shape="rect" coords="620,539,708,566" alt="">
<area href="lsd_8c.html#a50" shape="rect" coords="617,641,710,667" alt="">
</map>
<a class="anchor" name="a24" doxytag="lsd.c::new_image_char" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="structimage__char__s.html">image_char</a> new_image_char </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned int&nbsp;</td>
          <td class="mdname" nowrap> <em>xsize</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>unsigned int&nbsp;</td>
          <td class="mdname" nowrap> <em>ysize</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create a new image_char of size 'xsize' times 'ysize'. 
<p>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l00363">363</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8c-source.html#l00345">image_char_s::data</a>, <a class="el" href="lsd_8c-source.html#l00159">error()</a>, <a class="el" href="lsd_8c.html#a13">image_char</a>, <a class="el" href="lsd_8c-source.html#l00346">image_char_s::xsize</a>, and <a class="el" href="lsd_8c-source.html#l00346">image_char_s::ysize</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l00388">new_image_char_ini()</a>.
<p>
<div class="fragment"><pre>00364 {
00365   <a class="code" href="structimage__char__s.html">image_char</a> image;
00366 
00367   <span class="comment">/* check parameters */</span>
00368   <span class="keywordflow">if</span>( xsize == 0 || ysize == 0 ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"new_image_char: invalid image size."</span>);
00369 
00370   <span class="comment">/* get memory */</span>
00371   image = (<a class="code" href="structimage__char__s.html">image_char</a>) malloc( <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structimage__char__s.html">image_char_s</a>) );
00372   <span class="keywordflow">if</span>( image == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"not enough memory."</span>);
00373   image-&gt;<a class="code" href="structimage__char__s.html#o0">data</a> = (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *) calloc( (size_t) (xsize*ysize),
00374                                           <span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>) );
00375   <span class="keywordflow">if</span>( image-&gt;<a class="code" href="structimage__char__s.html#o0">data</a> == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"not enough memory."</span>);
00376 
00377   <span class="comment">/* set image size */</span>
00378   image-&gt;<a class="code" href="structimage__char__s.html#o1">xsize</a> = xsize;
00379   image-&gt;<a class="code" href="structimage__char__s.html#o2">ysize</a> = ysize;
00380 
00381   <span class="keywordflow">return</span> image;
00382 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8c_a24_cgraph.png" border="0" usemap="#lsd_8c_a24_cgraph_map" alt=""></center>
<map name="lsd_8c_a24_cgraph_map">
<area href="lsd_8c.html#a16" shape="rect" coords="181,8,232,34" alt="">
</map>
<a class="anchor" name="a25" doxytag="lsd.c::new_image_char_ini" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="structimage__char__s.html">image_char</a> new_image_char_ini </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned int&nbsp;</td>
          <td class="mdname" nowrap> <em>xsize</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>unsigned int&nbsp;</td>
          <td class="mdname" nowrap> <em>ysize</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>unsigned char&nbsp;</td>
          <td class="mdname" nowrap> <em>fill_value</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create a new image_char of size 'xsize' times 'ysize', initialized to the value 'fill_value'. 
<p>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l00388">388</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8c-source.html#l00345">image_char_s::data</a>, <a class="el" href="lsd_8c-source.html#l00159">error()</a>, <a class="el" href="lsd_8c.html#a13">image_char</a>, and <a class="el" href="lsd_8c-source.html#l00363">new_image_char()</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l02025">LineSegmentDetection()</a>.
<p>
<div class="fragment"><pre>00390 {
00391   <a class="code" href="structimage__char__s.html">image_char</a> image = <a class="code" href="lsd_8c.html#a24">new_image_char</a>(xsize,ysize); <span class="comment">/* create image */</span>
00392   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N = xsize*ysize;
00393   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i;
00394 
00395   <span class="comment">/* check parameters */</span>
00396   <span class="keywordflow">if</span>( image == NULL || image-&gt;<a class="code" href="structimage__char__s.html#o0">data</a> == NULL )
00397     <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"new_image_char_ini: invalid image."</span>);
00398 
00399   <span class="comment">/* initialize */</span>
00400   <span class="keywordflow">for</span>(i=0; i&lt;N; i++) image-&gt;<a class="code" href="structimage__char__s.html#o0">data</a>[i] = fill_value;
00401 
00402   <span class="keywordflow">return</span> image;
00403 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8c_a25_cgraph.png" border="0" usemap="#lsd_8c_a25_cgraph_map" alt=""></center>
<map name="lsd_8c_a25_cgraph_map">
<area href="lsd_8c.html#a16" shape="rect" coords="376,33,426,59" alt="">
<area href="lsd_8c.html#a24" shape="rect" coords="204,58,326,85" alt="">
</map>
<a class="anchor" name="a29" doxytag="lsd.c::new_image_double" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="structimage__double__s.html">image_double</a> new_image_double </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned int&nbsp;</td>
          <td class="mdname" nowrap> <em>xsize</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>unsigned int&nbsp;</td>
          <td class="mdname" nowrap> <em>ysize</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create a new image_double of size 'xsize' times 'ysize'. 
<p>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l00489">489</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8c-source.html#l00471">image_double_s::data</a>, <a class="el" href="lsd_8c-source.html#l00159">error()</a>, <a class="el" href="lsd_8c.html#a15">image_double</a>, <a class="el" href="lsd_8c-source.html#l00472">image_double_s::xsize</a>, and <a class="el" href="lsd_8c-source.html#l00472">image_double_s::ysize</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l00611">gaussian_sampler()</a>, and <a class="el" href="lsd_8c-source.html#l00752">ll_angle()</a>.
<p>
<div class="fragment"><pre>00490 {
00491   <a class="code" href="structimage__double__s.html">image_double</a> image;
00492 
00493   <span class="comment">/* check parameters */</span>
00494   <span class="keywordflow">if</span>( xsize == 0 || ysize == 0 ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"new_image_double: invalid image size."</span>);
00495 
00496   <span class="comment">/* get memory */</span>
00497   image = (<a class="code" href="structimage__double__s.html">image_double</a>) malloc( <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structimage__double__s.html">image_double_s</a>) );
00498   <span class="keywordflow">if</span>( image == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"not enough memory."</span>);
00499   image-&gt;<a class="code" href="structimage__double__s.html#o0">data</a> = (<span class="keywordtype">double</span> *) calloc( (size_t) (xsize*ysize), <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>) );
00500   <span class="keywordflow">if</span>( image-&gt;<a class="code" href="structimage__double__s.html#o0">data</a> == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"not enough memory."</span>);
00501 
00502   <span class="comment">/* set image size */</span>
00503   image-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a> = xsize;
00504   image-&gt;<a class="code" href="structimage__double__s.html#o2">ysize</a> = ysize;
00505 
00506   <span class="keywordflow">return</span> image;
00507 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8c_a29_cgraph.png" border="0" usemap="#lsd_8c_a29_cgraph_map" alt=""></center>
<map name="lsd_8c_a29_cgraph_map">
<area href="lsd_8c.html#a16" shape="rect" coords="194,8,245,34" alt="">
</map>
<a class="anchor" name="a30" doxytag="lsd.c::new_image_double_ptr" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="structimage__double__s.html">image_double</a> new_image_double_ptr </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned int&nbsp;</td>
          <td class="mdname" nowrap> <em>xsize</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>unsigned int&nbsp;</td>
          <td class="mdname" nowrap> <em>ysize</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap> <em>data</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create a new image_double of size 'xsize' times 'ysize' with the data pointed by 'data'. 
<p>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l00513">513</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8c-source.html#l00471">image_double_s::data</a>, <a class="el" href="lsd_8c-source.html#l00159">error()</a>, <a class="el" href="lsd_8c.html#a15">image_double</a>, <a class="el" href="lsd_8c-source.html#l00472">image_double_s::xsize</a>, and <a class="el" href="lsd_8c-source.html#l00472">image_double_s::ysize</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l02025">LineSegmentDetection()</a>.
<p>
<div class="fragment"><pre>00515 {
00516   <a class="code" href="structimage__double__s.html">image_double</a> image;
00517 
00518   <span class="comment">/* check parameters */</span>
00519   <span class="keywordflow">if</span>( xsize == 0 || ysize == 0 )
00520     <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"new_image_double_ptr: invalid image size."</span>);
00521   <span class="keywordflow">if</span>( data == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"new_image_double_ptr: NULL data pointer."</span>);
00522 
00523   <span class="comment">/* get memory */</span>
00524   image = (<a class="code" href="structimage__double__s.html">image_double</a>) malloc( <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structimage__double__s.html">image_double_s</a>) );
00525   <span class="keywordflow">if</span>( image == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"not enough memory."</span>);
00526 
00527   <span class="comment">/* set image */</span>
00528   image-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a> = xsize;
00529   image-&gt;<a class="code" href="structimage__double__s.html#o2">ysize</a> = ysize;
00530   image-&gt;<a class="code" href="structimage__double__s.html#o0">data</a> = data;
00531 
00532   <span class="keywordflow">return</span> image;
00533 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8c_a30_cgraph.png" border="0" usemap="#lsd_8c_a30_cgraph_map" alt=""></center>
<map name="lsd_8c_a30_cgraph_map">
<area href="lsd_8c.html#a16" shape="rect" coords="218,8,269,34" alt="">
</map>
<a class="anchor" name="a26" doxytag="lsd.c::new_image_int" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="structimage__int__s.html">image_int</a> new_image_int </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned int&nbsp;</td>
          <td class="mdname" nowrap> <em>xsize</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>unsigned int&nbsp;</td>
          <td class="mdname" nowrap> <em>ysize</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create a new image_int of size 'xsize' times 'ysize'. 
<p>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l00423">423</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8c-source.html#l00416">image_int_s::data</a>, <a class="el" href="lsd_8c-source.html#l00159">error()</a>, <a class="el" href="lsd_8c.html#a14">image_int</a>, <a class="el" href="lsd_8c-source.html#l00417">image_int_s::xsize</a>, and <a class="el" href="lsd_8c-source.html#l00417">image_int_s::ysize</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l00447">new_image_int_ini()</a>.
<p>
<div class="fragment"><pre>00424 {
00425   <a class="code" href="structimage__int__s.html">image_int</a> image;
00426 
00427   <span class="comment">/* check parameters */</span>
00428   <span class="keywordflow">if</span>( xsize == 0 || ysize == 0 ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"new_image_int: invalid image size."</span>);
00429 
00430   <span class="comment">/* get memory */</span>
00431   image = (<a class="code" href="structimage__int__s.html">image_int</a>) malloc( <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structimage__int__s.html">image_int_s</a>) );
00432   <span class="keywordflow">if</span>( image == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"not enough memory."</span>);
00433   image-&gt;<a class="code" href="structimage__int__s.html#o0">data</a> = (<span class="keywordtype">int</span> *) calloc( (size_t) (xsize*ysize), <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>) );
00434   <span class="keywordflow">if</span>( image-&gt;<a class="code" href="structimage__int__s.html#o0">data</a> == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"not enough memory."</span>);
00435 
00436   <span class="comment">/* set image size */</span>
00437   image-&gt;<a class="code" href="structimage__int__s.html#o1">xsize</a> = xsize;
00438   image-&gt;<a class="code" href="structimage__int__s.html#o2">ysize</a> = ysize;
00439 
00440   <span class="keywordflow">return</span> image;
00441 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8c_a26_cgraph.png" border="0" usemap="#lsd_8c_a26_cgraph_map" alt=""></center>
<map name="lsd_8c_a26_cgraph_map">
<area href="lsd_8c.html#a16" shape="rect" coords="168,8,218,34" alt="">
</map>
<a class="anchor" name="a27" doxytag="lsd.c::new_image_int_ini" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="structimage__int__s.html">image_int</a> new_image_int_ini </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned int&nbsp;</td>
          <td class="mdname" nowrap> <em>xsize</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>unsigned int&nbsp;</td>
          <td class="mdname" nowrap> <em>ysize</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>fill_value</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create a new image_int of size 'xsize' times 'ysize', initialized to the value 'fill_value'. 
<p>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l00447">447</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8c-source.html#l00416">image_int_s::data</a>, <a class="el" href="lsd_8c.html#a14">image_int</a>, and <a class="el" href="lsd_8c-source.html#l00423">new_image_int()</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l02025">LineSegmentDetection()</a>.
<p>
<div class="fragment"><pre>00449 {
00450   <a class="code" href="structimage__int__s.html">image_int</a> image = <a class="code" href="lsd_8c.html#a26">new_image_int</a>(xsize,ysize); <span class="comment">/* create image */</span>
00451   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N = xsize*ysize;
00452   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i;
00453 
00454   <span class="comment">/* initialize */</span>
00455   <span class="keywordflow">for</span>(i=0; i&lt;N; i++) image-&gt;<a class="code" href="structimage__int__s.html#o0">data</a>[i] = fill_value;
00456 
00457   <span class="keywordflow">return</span> image;
00458 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8c_a27_cgraph.png" border="0" usemap="#lsd_8c_a27_cgraph_map" alt=""></center>
<map name="lsd_8c_a27_cgraph_map">
<area href="lsd_8c.html#a26" shape="rect" coords="189,8,301,34" alt="">
<area href="lsd_8c.html#a16" shape="rect" coords="349,8,400,34" alt="">
</map>
<a class="anchor" name="a20" doxytag="lsd.c::new_ntuple_list" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="structntuple__list__s.html">ntuple_list</a> new_ntuple_list </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>dim</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create an n-tuple list and allocate memory for one element. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>dim</em>&nbsp;</td><td>the dimension (n) of the n-tuple. </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l00261">261</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8c-source.html#l00242">ntuple_list_s::dim</a>, <a class="el" href="lsd_8c-source.html#l00159">error()</a>, <a class="el" href="lsd_8c-source.html#l00241">ntuple_list_s::max_size</a>, <a class="el" href="lsd_8c.html#a12">ntuple_list</a>, <a class="el" href="lsd_8c-source.html#l00240">ntuple_list_s::size</a>, and <a class="el" href="lsd_8c-source.html#l00243">ntuple_list_s::values</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l00611">gaussian_sampler()</a>, and <a class="el" href="lsd_8c-source.html#l02025">LineSegmentDetection()</a>.
<p>
<div class="fragment"><pre>00262 {
00263   <a class="code" href="structntuple__list__s.html">ntuple_list</a> n_tuple;
00264 
00265   <span class="comment">/* check parameters */</span>
00266   <span class="keywordflow">if</span>( dim == 0 ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"new_ntuple_list: 'dim' must be positive."</span>);
00267 
00268   <span class="comment">/* get memory for list structure */</span>
00269   n_tuple = (<a class="code" href="structntuple__list__s.html">ntuple_list</a>) malloc( <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structntuple__list__s.html">ntuple_list_s</a>) );
00270   <span class="keywordflow">if</span>( n_tuple == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"not enough memory."</span>);
00271 
00272   <span class="comment">/* initialize list */</span>
00273   n_tuple-&gt;<a class="code" href="structntuple__list__s.html#o0">size</a> = 0;
00274   n_tuple-&gt;<a class="code" href="structntuple__list__s.html#o1">max_size</a> = 1;
00275   n_tuple-&gt;<a class="code" href="structntuple__list__s.html#o2">dim</a> = dim;
00276 
00277   <span class="comment">/* get memory for tuples */</span>
00278   n_tuple-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a> = (<span class="keywordtype">double</span> *) malloc( dim*n_tuple-&gt;<a class="code" href="structntuple__list__s.html#o1">max_size</a> * <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>) );
00279   <span class="keywordflow">if</span>( n_tuple-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a> == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"not enough memory."</span>);
00280 
00281   <span class="keywordflow">return</span> n_tuple;
00282 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8c_a20_cgraph.png" border="0" usemap="#lsd_8c_a20_cgraph_map" alt=""></center>
<map name="lsd_8c_a20_cgraph_map">
<area href="lsd_8c.html#a16" shape="rect" coords="170,8,221,34" alt="">
</map>
<a class="anchor" name="a39" doxytag="lsd.c::nfa" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> double nfa </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>n</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>k</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>p</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>logNT</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Computes -log10(NFA). 
<p>
NFA stands for Number of False Alarms: <p class=formulaDsp>
<img class=formulaDsp alt="\[ \mathrm{NFA} = NT \cdot B(n,k,p) \]" src="form_7.png">
<p>
<p>
<ul>
<li>NT - number of tests</li><li>B(n,k,p) - tail of binomial distribution with parameters n,k and p: <p class=formulaDsp>
<img class=formulaDsp alt="\[ B(n,k,p) = \sum_{j=k}^n \left(\begin{array}{c}n\\j\end{array}\right) p^{j} (1-p)^{n-j} \]" src="form_8.png">
<p>
</li></ul>
<p>
The value -log10(NFA) is equivalent but more intuitive than NFA:<ul>
<li>-1 corresponds to 10 mean false alarms</li><li>0 corresponds to 1 mean false alarm</li><li>1 corresponds to 0.1 mean false alarms</li><li>2 corresponds to 0.01 mean false alarms</li><li>...</li></ul>
<p>
Used this way, the bigger the value, better the detection, and a logarithmic scale is used.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>n,k,p</em>&nbsp;</td><td>binomial parameters. </td></tr>
    <tr><td valign=top><em>logNT</em>&nbsp;</td><td>logarithm of Number of Tests</td></tr>
  </table>
</dl>
The computation is based in the gamma function by the following relation: <p class=formulaDsp>
<img class=formulaDsp alt="\[ \left(\begin{array}{c}n\\k\end{array}\right) = \frac{ \Gamma(n+1) }{ \Gamma(k+1) \cdot \Gamma(n-k+1) }. \]" src="form_9.png">
<p>
 We use efficient algorithms to compute the logarithm of the gamma function.<p>
To make the computation faster, not all the sum is computed, part of the terms are neglected based on a bound to the error obtained (an error of 10% in the result is accepted). 
<p>
Definition at line <a class="el" href="lsd_8c-source.html#l01074">1074</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8c-source.html#l00181">double_equal()</a>, <a class="el" href="lsd_8c-source.html#l00159">error()</a>, <a class="el" href="lsd_8c-source.html#l01025">log_gamma</a>, <a class="el" href="lsd_8c-source.html#l00106">M_LN10</a>, and <a class="el" href="lsd_8c-source.html#l01030">TABSIZE</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l01482">rect_nfa()</a>.
<p>
<div class="fragment"><pre>01075 {
01076   <span class="keyword">static</span> <span class="keywordtype">double</span> inv[<a class="code" href="lsd_8c.html#a11">TABSIZE</a>];   <span class="comment">/* table to keep computed inverse values */</span>
01077   <span class="keywordtype">double</span> tolerance = 0.1;       <span class="comment">/* an error of 10% in the result is accepted */</span>
01078   <span class="keywordtype">double</span> log1term,term,bin_term,mult_term,bin_tail,err,p_term;
01079   <span class="keywordtype">int</span> i;
01080 
01081   <span class="comment">/* check parameters */</span>
01082   <span class="keywordflow">if</span>( n&lt;0 || k&lt;0 || k&gt;n || p&lt;=0.0 || p&gt;=1.0 )
01083     <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"nfa: wrong n, k or p values."</span>);
01084 
01085   <span class="comment">/* trivial cases */</span>
01086   <span class="keywordflow">if</span>( n==0 || k==0 ) <span class="keywordflow">return</span> -logNT;
01087   <span class="keywordflow">if</span>( n==k ) <span class="keywordflow">return</span> -logNT - (<span class="keywordtype">double</span>) n * log10(p);
01088 
01089   <span class="comment">/* probability term */</span>
01090   p_term = p / (1.0-p);
01091 
01092   <span class="comment">/* compute the first term of the series */</span>
01093   <span class="comment">/*</span>
01094 <span class="comment">     binomial_tail(n,k,p) = sum_{i=k}^n bincoef(n,i) * p^i * (1-p)^{n-i}</span>
01095 <span class="comment">     where bincoef(n,i) are the binomial coefficients.</span>
01096 <span class="comment">     But</span>
01097 <span class="comment">       bincoef(n,k) = gamma(n+1) / ( gamma(k+1) * gamma(n-k+1) ).</span>
01098 <span class="comment">     We use this to compute the first term. Actually the log of it.</span>
01099 <span class="comment">   */</span>
01100   log1term = <a class="code" href="lsd_8c.html#a10">log_gamma</a>( (<span class="keywordtype">double</span>) n + 1.0 ) - <a class="code" href="lsd_8c.html#a10">log_gamma</a>( (<span class="keywordtype">double</span>) k + 1.0 )
01101            - <a class="code" href="lsd_8c.html#a10">log_gamma</a>( (<span class="keywordtype">double</span>) (n-k) + 1.0 )
01102            + (<span class="keywordtype">double</span>) k * log(p) + (<span class="keywordtype">double</span>) (n-k) * log(1.0-p);
01103   term = exp(log1term);
01104 
01105   <span class="comment">/* in some cases no more computations are needed */</span>
01106   <span class="keywordflow">if</span>( <a class="code" href="lsd_8c.html#a17">double_equal</a>(term,0.0) )              <span class="comment">/* the first term is almost zero */</span>
01107     {
01108       <span class="keywordflow">if</span>( (<span class="keywordtype">double</span>) k &gt; (<span class="keywordtype">double</span>) n * p )     <span class="comment">/* at begin or end of the tail?  */</span>
01109         <span class="keywordflow">return</span> -log1term / <a class="code" href="lsd_8c.html#a0">M_LN10</a> - logNT;  <span class="comment">/* end: use just the first term  */</span>
01110       <span class="keywordflow">else</span>
01111         <span class="keywordflow">return</span> -logNT;                      <span class="comment">/* begin: the tail is roughly 1  */</span>
01112     }
01113 
01114   <span class="comment">/* compute more terms if needed */</span>
01115   bin_tail = term;
01116   <span class="keywordflow">for</span>(i=k+1;i&lt;=n;i++)
01117     {
01118       <span class="comment">/*</span>
01119 <span class="comment">         As</span>
01120 <span class="comment">           term_i = bincoef(n,i) * p^i * (1-p)^(n-i)</span>
01121 <span class="comment">         and</span>
01122 <span class="comment">           bincoef(n,i)/bincoef(n,i-1) = n-1+1 / i,</span>
01123 <span class="comment">         then,</span>
01124 <span class="comment">           term_i / term_i-1 = (n-i+1)/i * p/(1-p)</span>
01125 <span class="comment">         and</span>
01126 <span class="comment">           term_i = term_i-1 * (n-i+1)/i * p/(1-p).</span>
01127 <span class="comment">         1/i is stored in a table as they are computed,</span>
01128 <span class="comment">         because divisions are expensive.</span>
01129 <span class="comment">         p/(1-p) is computed only once and stored in 'p_term'.</span>
01130 <span class="comment">       */</span>
01131       bin_term = (<span class="keywordtype">double</span>) (n-i+1) * ( i&lt;<a class="code" href="lsd_8c.html#a11">TABSIZE</a> ?
01132                    ( inv[i]!=0.0 ? inv[i] : ( inv[i] = 1.0 / (<span class="keywordtype">double</span>) i ) ) :
01133                    1.0 / (<span class="keywordtype">double</span>) i );
01134 
01135       mult_term = bin_term * p_term;
01136       term *= mult_term;
01137       bin_tail += term;
01138       <span class="keywordflow">if</span>(bin_term&lt;1.0)
01139         {
01140           <span class="comment">/* When bin_term&lt;1 then mult_term_j&lt;mult_term_i for j&gt;i.</span>
01141 <span class="comment">             Then, the error on the binomial tail when truncated at</span>
01142 <span class="comment">             the i term can be bounded by a geometric series of form</span>
01143 <span class="comment">             term_i * sum mult_term_i^j.                            */</span>
01144           err = term * ( ( 1.0 - pow( mult_term, (<span class="keywordtype">double</span>) (n-i+1) ) ) /
01145                          (1.0-mult_term) - 1.0 );
01146 
01147           <span class="comment">/* One wants an error at most of tolerance*final_result, or:</span>
01148 <span class="comment">             tolerance * abs(-log10(bin_tail)-logNT).</span>
01149 <span class="comment">             Now, the error that can be accepted on bin_tail is</span>
01150 <span class="comment">             given by tolerance*final_result divided by the derivative</span>
01151 <span class="comment">             of -log10(x) when x=bin_tail. that is:</span>
01152 <span class="comment">             tolerance * abs(-log10(bin_tail)-logNT) / (1/bin_tail)</span>
01153 <span class="comment">             Finally, we truncate the tail if the error is less than:</span>
01154 <span class="comment">             tolerance * abs(-log10(bin_tail)-logNT) * bin_tail        */</span>
01155           <span class="keywordflow">if</span>( err &lt; tolerance * fabs(-log10(bin_tail)-logNT) * bin_tail ) <span class="keywordflow">break</span>;
01156         }
01157     }
01158   <span class="keywordflow">return</span> -log10(bin_tail) - logNT;
01159 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8c_a39_cgraph.png" border="0" usemap="#lsd_8c_a39_cgraph_map" alt=""></center>
<map name="lsd_8c_a39_cgraph_map">
<area href="lsd_8c.html#a17" shape="rect" coords="100,7,201,34" alt="">
<area href="lsd_8c.html#a16" shape="rect" coords="125,58,176,85" alt="">
</map>
<a class="anchor" name="a40" doxytag="lsd.c::rect_copy" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void rect_copy </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct <a class="el" href="structrect.html">rect</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>in</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>struct <a class="el" href="structrect.html">rect</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>out</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Copy one rectangle structure to another. 
<p>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l01183">1183</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8c-source.html#l01175">rect::dx</a>, <a class="el" href="lsd_8c-source.html#l01175">rect::dy</a>, <a class="el" href="lsd_8c-source.html#l00159">error()</a>, <a class="el" href="lsd_8c-source.html#l01177">rect::p</a>, <a class="el" href="lsd_8c-source.html#l01176">rect::prec</a>, <a class="el" href="lsd_8c-source.html#l01174">rect::theta</a>, <a class="el" href="lsd_8c-source.html#l01172">rect::width</a>, <a class="el" href="lsd_8c-source.html#l01173">rect::x</a>, <a class="el" href="lsd_8c-source.html#l01171">rect::x1</a>, <a class="el" href="lsd_8c-source.html#l01171">rect::x2</a>, <a class="el" href="lsd_8c-source.html#l01173">rect::y</a>, <a class="el" href="lsd_8c-source.html#l01171">rect::y1</a>, and <a class="el" href="lsd_8c-source.html#l01171">rect::y2</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l01756">rect_improve()</a>.
<p>
<div class="fragment"><pre>01184 {
01185   <span class="comment">/* check parameters */</span>
01186   <span class="keywordflow">if</span>( in == NULL || out == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"rect_copy: invalid 'in' or 'out'."</span>);
01187 
01188   <span class="comment">/* copy values */</span>
01189   out-&gt;<a class="code" href="structrect.html#o0">x1</a> = in-&gt;<a class="code" href="structrect.html#o0">x1</a>;
01190   out-&gt;<a class="code" href="structrect.html#o1">y1</a> = in-&gt;<a class="code" href="structrect.html#o1">y1</a>;
01191   out-&gt;<a class="code" href="structrect.html#o2">x2</a> = in-&gt;<a class="code" href="structrect.html#o2">x2</a>;
01192   out-&gt;<a class="code" href="structrect.html#o3">y2</a> = in-&gt;<a class="code" href="structrect.html#o3">y2</a>;
01193   out-&gt;<a class="code" href="structrect.html#o4">width</a> = in-&gt;<a class="code" href="structrect.html#o4">width</a>;
01194   out-&gt;<a class="code" href="structrect.html#o5">x</a> = in-&gt;<a class="code" href="structrect.html#o5">x</a>;
01195   out-&gt;<a class="code" href="structrect.html#o6">y</a> = in-&gt;<a class="code" href="structrect.html#o6">y</a>;
01196   out-&gt;<a class="code" href="structrect.html#o7">theta</a> = in-&gt;<a class="code" href="structrect.html#o7">theta</a>;
01197   out-&gt;<a class="code" href="structrect.html#o8">dx</a> = in-&gt;<a class="code" href="structrect.html#o8">dx</a>;
01198   out-&gt;<a class="code" href="structrect.html#o9">dy</a> = in-&gt;<a class="code" href="structrect.html#o9">dy</a>;
01199   out-&gt;<a class="code" href="structrect.html#o10">prec</a> = in-&gt;<a class="code" href="structrect.html#o10">prec</a>;
01200   out-&gt;<a class="code" href="structrect.html#o11">p</a> = in-&gt;<a class="code" href="structrect.html#o11">p</a>;
01201 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8c_a40_cgraph.png" border="0" usemap="#lsd_8c_a40_cgraph_map" alt=""></center>
<map name="lsd_8c_a40_cgraph_map">
<area href="lsd_8c.html#a16" shape="rect" coords="136,8,186,34" alt="">
</map>
<a class="anchor" name="a51" doxytag="lsd.c::rect_improve" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> double rect_improve </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct <a class="el" href="structrect.html">rect</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>rec</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="structimage__double__s.html">image_double</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>angles</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>logNT</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>log_eps</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Try some rectangles variations to improve NFA value. 
<p>
Only if the rectangle is not meaningful (i.e., log_nfa &lt;= log_eps). 
<p>
Definition at line <a class="el" href="lsd_8c-source.html#l01756">1756</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8c-source.html#l01175">rect::dx</a>, <a class="el" href="lsd_8c-source.html#l01175">rect::dy</a>, <a class="el" href="lsd_8c.html#a15">image_double</a>, <a class="el" href="lsd_8c-source.html#l00111">M_PI</a>, <a class="el" href="lsd_8c-source.html#l01177">rect::p</a>, <a class="el" href="lsd_8c-source.html#l01176">rect::prec</a>, <a class="el" href="lsd_8c-source.html#l01183">rect_copy()</a>, <a class="el" href="lsd_8c-source.html#l01482">rect_nfa()</a>, <a class="el" href="lsd_8c-source.html#l01172">rect::width</a>, <a class="el" href="lsd_8c-source.html#l01171">rect::x1</a>, <a class="el" href="lsd_8c-source.html#l01171">rect::x2</a>, <a class="el" href="lsd_8c-source.html#l01171">rect::y1</a>, and <a class="el" href="lsd_8c-source.html#l01171">rect::y2</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l02025">LineSegmentDetection()</a>.
<p>
<div class="fragment"><pre>01758 {
01759   <span class="keyword">struct </span><a class="code" href="structrect.html">rect</a> r;
01760   <span class="keywordtype">double</span> log_nfa,log_nfa_new;
01761   <span class="keywordtype">double</span> delta = 0.5;
01762   <span class="keywordtype">double</span> delta_2 = delta / 2.0;
01763   <span class="keywordtype">int</span> n;
01764 
01765   log_nfa = <a class="code" href="lsd_8c.html#a47">rect_nfa</a>(rec,angles,logNT);
01766 
01767   <span class="keywordflow">if</span>( log_nfa &gt; log_eps ) <span class="keywordflow">return</span> log_nfa;
01768 
01769   <span class="comment">/* try finer precisions */</span>
01770   <a class="code" href="lsd_8c.html#a40">rect_copy</a>(rec,&amp;r);
01771   <span class="keywordflow">for</span>(n=0; n&lt;5; n++)
01772     {
01773       r.<a class="code" href="structrect.html#o11">p</a> /= 2.0;
01774       r.<a class="code" href="structrect.html#o10">prec</a> = r.<a class="code" href="structrect.html#o11">p</a> * <a class="code" href="lsd_8c.html#a1">M_PI</a>;
01775       log_nfa_new = <a class="code" href="lsd_8c.html#a47">rect_nfa</a>(&amp;r,angles,logNT);
01776       <span class="keywordflow">if</span>( log_nfa_new &gt; log_nfa )
01777         {
01778           log_nfa = log_nfa_new;
01779           <a class="code" href="lsd_8c.html#a40">rect_copy</a>(&amp;r,rec);
01780         }
01781     }
01782 
01783   <span class="keywordflow">if</span>( log_nfa &gt; log_eps ) <span class="keywordflow">return</span> log_nfa;
01784 
01785   <span class="comment">/* try to reduce width */</span>
01786   <a class="code" href="lsd_8c.html#a40">rect_copy</a>(rec,&amp;r);
01787   <span class="keywordflow">for</span>(n=0; n&lt;5; n++)
01788     {
01789       <span class="keywordflow">if</span>( (r.<a class="code" href="structrect.html#o4">width</a> - delta) &gt;= 0.5 )
01790         {
01791           r.<a class="code" href="structrect.html#o4">width</a> -= delta;
01792           log_nfa_new = <a class="code" href="lsd_8c.html#a47">rect_nfa</a>(&amp;r,angles,logNT);
01793           <span class="keywordflow">if</span>( log_nfa_new &gt; log_nfa )
01794             {
01795               <a class="code" href="lsd_8c.html#a40">rect_copy</a>(&amp;r,rec);
01796               log_nfa = log_nfa_new;
01797             }
01798         }
01799     }
01800 
01801   <span class="keywordflow">if</span>( log_nfa &gt; log_eps ) <span class="keywordflow">return</span> log_nfa;
01802 
01803   <span class="comment">/* try to reduce one side of the rectangle */</span>
01804   <a class="code" href="lsd_8c.html#a40">rect_copy</a>(rec,&amp;r);
01805   <span class="keywordflow">for</span>(n=0; n&lt;5; n++)
01806     {
01807       <span class="keywordflow">if</span>( (r.<a class="code" href="structrect.html#o4">width</a> - delta) &gt;= 0.5 )
01808         {
01809           r.<a class="code" href="structrect.html#o0">x1</a> += -r.<a class="code" href="structrect.html#o9">dy</a> * delta_2;
01810           r.<a class="code" href="structrect.html#o1">y1</a> +=  r.<a class="code" href="structrect.html#o8">dx</a> * delta_2;
01811           r.<a class="code" href="structrect.html#o2">x2</a> += -r.<a class="code" href="structrect.html#o9">dy</a> * delta_2;
01812           r.<a class="code" href="structrect.html#o3">y2</a> +=  r.<a class="code" href="structrect.html#o8">dx</a> * delta_2;
01813           r.<a class="code" href="structrect.html#o4">width</a> -= delta;
01814           log_nfa_new = <a class="code" href="lsd_8c.html#a47">rect_nfa</a>(&amp;r,angles,logNT);
01815           <span class="keywordflow">if</span>( log_nfa_new &gt; log_nfa )
01816             {
01817               <a class="code" href="lsd_8c.html#a40">rect_copy</a>(&amp;r,rec);
01818               log_nfa = log_nfa_new;
01819             }
01820         }
01821     }
01822 
01823   <span class="keywordflow">if</span>( log_nfa &gt; log_eps ) <span class="keywordflow">return</span> log_nfa;
01824 
01825   <span class="comment">/* try to reduce the other side of the rectangle */</span>
01826   <a class="code" href="lsd_8c.html#a40">rect_copy</a>(rec,&amp;r);
01827   <span class="keywordflow">for</span>(n=0; n&lt;5; n++)
01828     {
01829       <span class="keywordflow">if</span>( (r.<a class="code" href="structrect.html#o4">width</a> - delta) &gt;= 0.5 )
01830         {
01831           r.<a class="code" href="structrect.html#o0">x1</a> -= -r.<a class="code" href="structrect.html#o9">dy</a> * delta_2;
01832           r.<a class="code" href="structrect.html#o1">y1</a> -=  r.<a class="code" href="structrect.html#o8">dx</a> * delta_2;
01833           r.<a class="code" href="structrect.html#o2">x2</a> -= -r.<a class="code" href="structrect.html#o9">dy</a> * delta_2;
01834           r.<a class="code" href="structrect.html#o3">y2</a> -=  r.<a class="code" href="structrect.html#o8">dx</a> * delta_2;
01835           r.<a class="code" href="structrect.html#o4">width</a> -= delta;
01836           log_nfa_new = <a class="code" href="lsd_8c.html#a47">rect_nfa</a>(&amp;r,angles,logNT);
01837           <span class="keywordflow">if</span>( log_nfa_new &gt; log_nfa )
01838             {
01839               <a class="code" href="lsd_8c.html#a40">rect_copy</a>(&amp;r,rec);
01840               log_nfa = log_nfa_new;
01841             }
01842         }
01843     }
01844 
01845   <span class="keywordflow">if</span>( log_nfa &gt; log_eps ) <span class="keywordflow">return</span> log_nfa;
01846 
01847   <span class="comment">/* try even finer precisions */</span>
01848   <a class="code" href="lsd_8c.html#a40">rect_copy</a>(rec,&amp;r);
01849   <span class="keywordflow">for</span>(n=0; n&lt;5; n++)
01850     {
01851       r.<a class="code" href="structrect.html#o11">p</a> /= 2.0;
01852       r.<a class="code" href="structrect.html#o10">prec</a> = r.<a class="code" href="structrect.html#o11">p</a> * <a class="code" href="lsd_8c.html#a1">M_PI</a>;
01853       log_nfa_new = <a class="code" href="lsd_8c.html#a47">rect_nfa</a>(&amp;r,angles,logNT);
01854       <span class="keywordflow">if</span>( log_nfa_new &gt; log_nfa )
01855         {
01856           log_nfa = log_nfa_new;
01857           <a class="code" href="lsd_8c.html#a40">rect_copy</a>(&amp;r,rec);
01858         }
01859     }
01860 
01861   <span class="keywordflow">return</span> log_nfa;
01862 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8c_a51_cgraph.png" border="0" usemap="#lsd_8c_a51_cgraph_map" alt=""></center>
<map name="lsd_8c_a51_cgraph_map">
<area href="lsd_8c.html#a40" shape="rect" coords="381,8,461,34" alt="">
<area href="lsd_8c.html#a47" shape="rect" coords="158,185,228,212" alt="">
<area href="lsd_8c.html#a16" shape="rect" coords="661,236,712,262" alt="">
<area href="lsd_8c.html#a34" shape="rect" coords="384,109,458,136" alt="">
<area href="lsd_8c.html#a39" shape="rect" coords="528,464,568,490" alt="">
<area href="lsd_8c.html#a43" shape="rect" coords="278,160,332,186" alt="">
<area href="lsd_8c.html#a44" shape="rect" coords="518,261,577,288" alt="">
<area href="lsd_8c.html#a45" shape="rect" coords="394,312,448,338" alt="">
<area href="lsd_8c.html#a46" shape="rect" coords="280,210,330,237" alt="">
<area href="lsd_8c.html#a17" shape="rect" coords="636,413,737,440" alt="">
<area href="lsd_8c.html#a42" shape="rect" coords="514,362,581,389" alt="">
<area href="lsd_8c.html#a41" shape="rect" coords="510,413,585,440" alt="">
</map>
<a class="anchor" name="a47" doxytag="lsd.c::rect_nfa" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> double rect_nfa </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct <a class="el" href="structrect.html">rect</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>rec</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="structimage__double__s.html">image_double</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>angles</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>logNT</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Compute a rectangle's NFA value. 
<p>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l01482">1482</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8c-source.html#l00159">error()</a>, <a class="el" href="lsd_8c.html#a15">image_double</a>, <a class="el" href="lsd_8c-source.html#l00893">isaligned()</a>, <a class="el" href="lsd_8c-source.html#l01074">nfa()</a>, <a class="el" href="lsd_8c-source.html#l01177">rect::p</a>, <a class="el" href="lsd_8c-source.html#l01176">rect::prec</a>, <a class="el" href="lsd_8c-source.html#l01314">ri_del()</a>, <a class="el" href="lsd_8c-source.html#l01325">ri_end()</a>, <a class="el" href="lsd_8c-source.html#l01341">ri_inc()</a>, <a class="el" href="lsd_8c-source.html#l01411">ri_ini()</a>, <a class="el" href="lsd_8c-source.html#l01174">rect::theta</a>, <a class="el" href="lsd_8c-source.html#l01264">rect_iter::x</a>, <a class="el" href="lsd_8c-source.html#l00472">image_double_s::xsize</a>, <a class="el" href="lsd_8c-source.html#l01264">rect_iter::y</a>, and <a class="el" href="lsd_8c-source.html#l00472">image_double_s::ysize</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l01756">rect_improve()</a>.
<p>
<div class="fragment"><pre>01483 {
01484   <a class="code" href="structrect__iter.html">rect_iter</a> * i;
01485   <span class="keywordtype">int</span> pts = 0;
01486   <span class="keywordtype">int</span> alg = 0;
01487 
01488   <span class="comment">/* check parameters */</span>
01489   <span class="keywordflow">if</span>( rec == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"rect_nfa: invalid rectangle."</span>);
01490   <span class="keywordflow">if</span>( angles == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"rect_nfa: invalid 'angles'."</span>);
01491 
01492   <span class="comment">/* compute the total number of pixels and of aligned points in 'rec' */</span>
01493   <span class="keywordflow">for</span>(i=<a class="code" href="lsd_8c.html#a46">ri_ini</a>(rec); !<a class="code" href="lsd_8c.html#a44">ri_end</a>(i); <a class="code" href="lsd_8c.html#a45">ri_inc</a>(i)) <span class="comment">/* rectangle iterator */</span>
01494     <span class="keywordflow">if</span>( i-&gt;<a class="code" href="structrect__iter.html#o4">x</a> &gt;= 0 &amp;&amp; i-&gt;<a class="code" href="structrect__iter.html#o5">y</a> &gt;= 0 &amp;&amp;
01495         i-&gt;<a class="code" href="structrect__iter.html#o4">x</a> &lt; (<span class="keywordtype">int</span>) angles-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a> &amp;&amp; i-&gt;<a class="code" href="structrect__iter.html#o5">y</a> &lt; (<span class="keywordtype">int</span>) angles-&gt;<a class="code" href="structimage__double__s.html#o2">ysize</a> )
01496       {
01497         ++pts; <span class="comment">/* total number of pixels counter */</span>
01498         <span class="keywordflow">if</span>( <a class="code" href="lsd_8c.html#a34">isaligned</a>(i-&gt;<a class="code" href="structrect__iter.html#o4">x</a>, i-&gt;<a class="code" href="structrect__iter.html#o5">y</a>, angles, rec-&gt;<a class="code" href="structrect.html#o7">theta</a>, rec-&gt;<a class="code" href="structrect.html#o10">prec</a>) )
01499           ++alg; <span class="comment">/* aligned points counter */</span>
01500       }
01501   <a class="code" href="lsd_8c.html#a43">ri_del</a>(i); <span class="comment">/* delete iterator */</span>
01502 
01503   <span class="keywordflow">return</span> <a class="code" href="lsd_8c.html#a39">nfa</a>(pts,alg,rec-&gt;<a class="code" href="structrect.html#o11">p</a>,logNT); <span class="comment">/* compute NFA value */</span>
01504 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8c_a47_cgraph.png" border="0" usemap="#lsd_8c_a47_cgraph_map" alt=""></center>
<map name="lsd_8c_a47_cgraph_map">
<area href="lsd_8c.html#a16" shape="rect" coords="506,210,557,237" alt="">
<area href="lsd_8c.html#a34" shape="rect" coords="232,109,306,136" alt="">
<area href="lsd_8c.html#a39" shape="rect" coords="373,312,413,338" alt="">
<area href="lsd_8c.html#a43" shape="rect" coords="129,8,182,34" alt="">
<area href="lsd_8c.html#a44" shape="rect" coords="364,160,422,186" alt="">
<area href="lsd_8c.html#a45" shape="rect" coords="242,325,296,352" alt="">
<area href="lsd_8c.html#a46" shape="rect" coords="130,286,181,313" alt="">
<area href="lsd_8c.html#a17" shape="rect" coords="481,362,582,389" alt="">
<area href="lsd_8c.html#a42" shape="rect" coords="360,362,426,389" alt="">
<area href="lsd_8c.html#a41" shape="rect" coords="356,413,430,440" alt="">
</map>
<a class="anchor" name="a52" doxytag="lsd.c::reduce_region_radius" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int reduce_region_radius </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct <a class="el" href="structpoint.html">point</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>reg</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>reg_size</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="structimage__double__s.html">image_double</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>modgrad</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>reg_angle</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>prec</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>p</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>struct <a class="el" href="structrect.html">rect</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>rec</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="structimage__char__s.html">image_char</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>used</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="structimage__double__s.html">image_double</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>angles</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>density_th</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Reduce the region size, by elimination the points far from the starting point, until that leads to rectangle with the right density of region points or to discard the region if too small. 
<p>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l01869">1869</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8c-source.html#l00471">image_double_s::data</a>, <a class="el" href="lsd_8c-source.html#l00345">image_char_s::data</a>, <a class="el" href="lsd_8c-source.html#l00207">dist()</a>, <a class="el" href="lsd_8c-source.html#l00159">error()</a>, <a class="el" href="lsd_8c-source.html#l00115">FALSE</a>, <a class="el" href="lsd_8c.html#a13">image_char</a>, <a class="el" href="lsd_8c.html#a15">image_double</a>, <a class="el" href="lsd_8c-source.html#l00132">NOTUSED</a>, <a class="el" href="lsd_8c-source.html#l01611">region2rect()</a>, <a class="el" href="lsd_8c-source.html#l00119">TRUE</a>, <a class="el" href="lsd_8c-source.html#l01172">rect::width</a>, <a class="el" href="lsd_8c-source.html#l00149">point::x</a>, <a class="el" href="lsd_8c-source.html#l01171">rect::x1</a>, <a class="el" href="lsd_8c-source.html#l01171">rect::x2</a>, <a class="el" href="lsd_8c-source.html#l00346">image_char_s::xsize</a>, <a class="el" href="lsd_8c-source.html#l00149">point::y</a>, <a class="el" href="lsd_8c-source.html#l01171">rect::y1</a>, and <a class="el" href="lsd_8c-source.html#l01171">rect::y2</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l01947">refine()</a>.
<p>
<div class="fragment"><pre>01874 {
01875   <span class="keywordtype">double</span> density,rad1,rad2,rad,xc,yc;
01876   <span class="keywordtype">int</span> i;
01877 
01878   <span class="comment">/* check parameters */</span>
01879   <span class="keywordflow">if</span>( reg == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"reduce_region_radius: invalid pointer 'reg'."</span>);
01880   <span class="keywordflow">if</span>( reg_size == NULL )
01881     <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"reduce_region_radius: invalid pointer 'reg_size'."</span>);
01882   <span class="keywordflow">if</span>( prec &lt; 0.0 ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"reduce_region_radius: 'prec' must be positive."</span>);
01883   <span class="keywordflow">if</span>( rec == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"reduce_region_radius: invalid pointer 'rec'."</span>);
01884   <span class="keywordflow">if</span>( used == NULL || used-&gt;<a class="code" href="structimage__char__s.html#o0">data</a> == NULL )
01885     <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"reduce_region_radius: invalid image 'used'."</span>);
01886   <span class="keywordflow">if</span>( angles == NULL || angles-&gt;<a class="code" href="structimage__double__s.html#o0">data</a> == NULL )
01887     <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"reduce_region_radius: invalid image 'angles'."</span>);
01888 
01889   <span class="comment">/* compute region points density */</span>
01890   density = (<span class="keywordtype">double</span>) *reg_size /
01891                          ( <a class="code" href="lsd_8c.html#a18">dist</a>(rec-&gt;<a class="code" href="structrect.html#o0">x1</a>,rec-&gt;<a class="code" href="structrect.html#o1">y1</a>,rec-&gt;<a class="code" href="structrect.html#o2">x2</a>,rec-&gt;<a class="code" href="structrect.html#o3">y2</a>) * rec-&gt;<a class="code" href="structrect.html#o4">width</a> );
01892 
01893   <span class="comment">/* if the density criterion is satisfied there is nothing to do */</span>
01894   <span class="keywordflow">if</span>( density &gt;= density_th ) <span class="keywordflow">return</span> <a class="code" href="lsd_8c.html#a3">TRUE</a>;
01895 
01896   <span class="comment">/* compute region's radius */</span>
01897   xc = (<span class="keywordtype">double</span>) reg[0].<a class="code" href="structpoint.html#o0">x</a>;
01898   yc = (<span class="keywordtype">double</span>) reg[0].<a class="code" href="structpoint.html#o1">y</a>;
01899   rad1 = <a class="code" href="lsd_8c.html#a18">dist</a>( xc, yc, rec-&gt;<a class="code" href="structrect.html#o0">x1</a>, rec-&gt;<a class="code" href="structrect.html#o1">y1</a> );
01900   rad2 = <a class="code" href="lsd_8c.html#a18">dist</a>( xc, yc, rec-&gt;<a class="code" href="structrect.html#o2">x2</a>, rec-&gt;<a class="code" href="structrect.html#o3">y2</a> );
01901   rad = rad1 &gt; rad2 ? rad1 : rad2;
01902 
01903   <span class="comment">/* while the density criterion is not satisfied, remove farther pixels */</span>
01904   <span class="keywordflow">while</span>( density &lt; density_th )
01905     {
01906       rad *= 0.75; <span class="comment">/* reduce region's radius to 75% of its value */</span>
01907 
01908       <span class="comment">/* remove points from the region and update 'used' map */</span>
01909       <span class="keywordflow">for</span>(i=0; i&lt;*reg_size; i++)
01910         <span class="keywordflow">if</span>( <a class="code" href="lsd_8c.html#a18">dist</a>( xc, yc, (<span class="keywordtype">double</span>) reg[i].x, (<span class="keywordtype">double</span>) reg[i].y ) &gt; rad )
01911           {
01912             <span class="comment">/* point not kept, mark it as NOTUSED */</span>
01913             used-&gt;<a class="code" href="structimage__char__s.html#o0">data</a>[ reg[i].<a class="code" href="structpoint.html#o0">x</a> + reg[i].<a class="code" href="structpoint.html#o1">y</a> * used-&gt;<a class="code" href="structimage__char__s.html#o1">xsize</a> ] = <a class="code" href="lsd_8c.html#a7">NOTUSED</a>;
01914             <span class="comment">/* remove point from the region */</span>
01915             reg[i].<a class="code" href="structpoint.html#o0">x</a> = reg[*reg_size-1].<a class="code" href="structpoint.html#o0">x</a>; <span class="comment">/* if i==*reg_size-1 copy itself */</span>
01916             reg[i].<a class="code" href="structpoint.html#o1">y</a> = reg[*reg_size-1].<a class="code" href="structpoint.html#o1">y</a>;
01917             --(*reg_size);
01918             --i; <span class="comment">/* to avoid skipping one point */</span>
01919           }
01920 
01921       <span class="comment">/* reject if the region is too small.</span>
01922 <span class="comment">         2 is the minimal region size for 'region2rect' to work. */</span>
01923       <span class="keywordflow">if</span>( *reg_size &lt; 2 ) <span class="keywordflow">return</span> <a class="code" href="lsd_8c.html#a2">FALSE</a>;
01924 
01925       <span class="comment">/* re-compute rectangle */</span>
01926       <a class="code" href="lsd_8c.html#a49">region2rect</a>(reg,*reg_size,modgrad,reg_angle,prec,p,rec);
01927 
01928       <span class="comment">/* re-compute region points density */</span>
01929       density = (<span class="keywordtype">double</span>) *reg_size /
01930                          ( <a class="code" href="lsd_8c.html#a18">dist</a>(rec-&gt;<a class="code" href="structrect.html#o0">x1</a>,rec-&gt;<a class="code" href="structrect.html#o1">y1</a>,rec-&gt;<a class="code" href="structrect.html#o2">x2</a>,rec-&gt;<a class="code" href="structrect.html#o3">y2</a>) * rec-&gt;<a class="code" href="structrect.html#o4">width</a> );
01931     }
01932 
01933   <span class="comment">/* if this point is reached, the density criterion is satisfied */</span>
01934   <span class="keywordflow">return</span> <a class="code" href="lsd_8c.html#a3">TRUE</a>;
01935 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8c_a52_cgraph.png" border="0" usemap="#lsd_8c_a52_cgraph_map" alt=""></center>
<map name="lsd_8c_a52_cgraph_map">
<area href="lsd_8c.html#a18" shape="rect" coords="232,7,274,34" alt="">
<area href="lsd_8c.html#a16" shape="rect" coords="498,109,549,135" alt="">
<area href="lsd_8c.html#a49" shape="rect" coords="209,109,297,135" alt="">
<area href="lsd_8c.html#a48" shape="rect" coords="346,159,424,186" alt="">
<area href="lsd_8c.html#a35" shape="rect" coords="484,159,564,186" alt="">
<area href="lsd_8c.html#a17" shape="rect" coords="473,210,574,237" alt="">
</map>
<a class="anchor" name="a53" doxytag="lsd.c::refine" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int refine </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct <a class="el" href="structpoint.html">point</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>reg</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>reg_size</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="structimage__double__s.html">image_double</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>modgrad</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>reg_angle</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>prec</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>p</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>struct <a class="el" href="structrect.html">rect</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>rec</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="structimage__char__s.html">image_char</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>used</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="structimage__double__s.html">image_double</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>angles</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>density_th</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Refine a rectangle. 
<p>
For that, an estimation of the angle tolerance is performed by the standard deviation of the angle at points near the region's starting point. Then, a new region is grown starting from the same point, but using the estimated angle tolerance. If this fails to produce a rectangle with the right density of region points, 'reduce_region_radius' is called to try to satisfy this condition. 
<p>
Definition at line <a class="el" href="lsd_8c-source.html#l01947">1947</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8c-source.html#l00943">angle_diff_signed()</a>, <a class="el" href="lsd_8c-source.html#l00471">image_double_s::data</a>, <a class="el" href="lsd_8c-source.html#l00345">image_char_s::data</a>, <a class="el" href="lsd_8c-source.html#l00207">dist()</a>, <a class="el" href="lsd_8c-source.html#l00159">error()</a>, <a class="el" href="lsd_8c-source.html#l00115">FALSE</a>, <a class="el" href="lsd_8c.html#a13">image_char</a>, <a class="el" href="lsd_8c.html#a15">image_double</a>, <a class="el" href="lsd_8c-source.html#l00132">NOTUSED</a>, <a class="el" href="lsd_8c-source.html#l01869">reduce_region_radius()</a>, <a class="el" href="lsd_8c-source.html#l01611">region2rect()</a>, <a class="el" href="lsd_8c-source.html#l01704">region_grow()</a>, <a class="el" href="lsd_8c-source.html#l00119">TRUE</a>, <a class="el" href="lsd_8c-source.html#l01172">rect::width</a>, <a class="el" href="lsd_8c-source.html#l00149">point::x</a>, <a class="el" href="lsd_8c-source.html#l01171">rect::x1</a>, <a class="el" href="lsd_8c-source.html#l01171">rect::x2</a>, <a class="el" href="lsd_8c-source.html#l00346">image_char_s::xsize</a>, <a class="el" href="lsd_8c-source.html#l00472">image_double_s::xsize</a>, <a class="el" href="lsd_8c-source.html#l00149">point::y</a>, <a class="el" href="lsd_8c-source.html#l01171">rect::y1</a>, and <a class="el" href="lsd_8c-source.html#l01171">rect::y2</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l02025">LineSegmentDetection()</a>.
<p>
<div class="fragment"><pre>01950 {
01951   <span class="keywordtype">double</span> angle,ang_d,mean_angle,tau,density,xc,yc,ang_c,sum,s_sum;
01952   <span class="keywordtype">int</span> i,n;
01953 
01954   <span class="comment">/* check parameters */</span>
01955   <span class="keywordflow">if</span>( reg == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"refine: invalid pointer 'reg'."</span>);
01956   <span class="keywordflow">if</span>( reg_size == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"refine: invalid pointer 'reg_size'."</span>);
01957   <span class="keywordflow">if</span>( prec &lt; 0.0 ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"refine: 'prec' must be positive."</span>);
01958   <span class="keywordflow">if</span>( rec == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"refine: invalid pointer 'rec'."</span>);
01959   <span class="keywordflow">if</span>( used == NULL || used-&gt;<a class="code" href="structimage__char__s.html#o0">data</a> == NULL )
01960     <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"refine: invalid image 'used'."</span>);
01961   <span class="keywordflow">if</span>( angles == NULL || angles-&gt;<a class="code" href="structimage__double__s.html#o0">data</a> == NULL )
01962     <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"refine: invalid image 'angles'."</span>);
01963 
01964   <span class="comment">/* compute region points density */</span>
01965   density = (<span class="keywordtype">double</span>) *reg_size /
01966                          ( <a class="code" href="lsd_8c.html#a18">dist</a>(rec-&gt;<a class="code" href="structrect.html#o0">x1</a>,rec-&gt;<a class="code" href="structrect.html#o1">y1</a>,rec-&gt;<a class="code" href="structrect.html#o2">x2</a>,rec-&gt;<a class="code" href="structrect.html#o3">y2</a>) * rec-&gt;<a class="code" href="structrect.html#o4">width</a> );
01967 
01968   <span class="comment">/* if the density criterion is satisfied there is nothing to do */</span>
01969   <span class="keywordflow">if</span>( density &gt;= density_th ) <span class="keywordflow">return</span> <a class="code" href="lsd_8c.html#a3">TRUE</a>;
01970 
01971   <span class="comment">/*------ First try: reduce angle tolerance ------*/</span>
01972 
01973   <span class="comment">/* compute the new mean angle and tolerance */</span>
01974   xc = (<span class="keywordtype">double</span>) reg[0].<a class="code" href="structpoint.html#o0">x</a>;
01975   yc = (<span class="keywordtype">double</span>) reg[0].<a class="code" href="structpoint.html#o1">y</a>;
01976   ang_c = angles-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>[ reg[0].<a class="code" href="structpoint.html#o0">x</a> + reg[0].<a class="code" href="structpoint.html#o1">y</a> * angles-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a> ];
01977   sum = s_sum = 0.0;
01978   n = 0;
01979   <span class="keywordflow">for</span>(i=0; i&lt;*reg_size; i++)
01980     {
01981       used-&gt;<a class="code" href="structimage__char__s.html#o0">data</a>[ reg[i].<a class="code" href="structpoint.html#o0">x</a> + reg[i].<a class="code" href="structpoint.html#o1">y</a> * used-&gt;<a class="code" href="structimage__char__s.html#o1">xsize</a> ] = <a class="code" href="lsd_8c.html#a7">NOTUSED</a>;
01982       <span class="keywordflow">if</span>( <a class="code" href="lsd_8c.html#a18">dist</a>( xc, yc, (<span class="keywordtype">double</span>) reg[i].x, (<span class="keywordtype">double</span>) reg[i].y ) &lt; rec-&gt;<a class="code" href="structrect.html#o4">width</a> )
01983         {
01984           angle = angles-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>[ reg[i].<a class="code" href="structpoint.html#o0">x</a> + reg[i].<a class="code" href="structpoint.html#o1">y</a> * angles-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a> ];
01985           ang_d = <a class="code" href="lsd_8c.html#a36">angle_diff_signed</a>(angle,ang_c);
01986           sum += ang_d;
01987           s_sum += ang_d * ang_d;
01988           ++n;
01989         }
01990     }
01991   mean_angle = sum / (<span class="keywordtype">double</span>) n;
01992   tau = 2.0 * sqrt( (s_sum - 2.0 * mean_angle * sum) / (<span class="keywordtype">double</span>) n
01993                          + mean_angle*mean_angle ); <span class="comment">/* 2 * standard deviation */</span>
01994 
01995   <span class="comment">/* find a new region from the same starting point and new angle tolerance */</span>
01996   <a class="code" href="lsd_8c.html#a50">region_grow</a>(reg[0].x,reg[0].y,angles,reg,reg_size,&amp;reg_angle,used,tau);
01997 
01998   <span class="comment">/* if the region is too small, reject */</span>
01999   <span class="keywordflow">if</span>( *reg_size &lt; 2 ) <span class="keywordflow">return</span> <a class="code" href="lsd_8c.html#a2">FALSE</a>;
02000 
02001   <span class="comment">/* re-compute rectangle */</span>
02002   <a class="code" href="lsd_8c.html#a49">region2rect</a>(reg,*reg_size,modgrad,reg_angle,prec,p,rec);
02003 
02004   <span class="comment">/* re-compute region points density */</span>
02005   density = (<span class="keywordtype">double</span>) *reg_size /
02006                       ( <a class="code" href="lsd_8c.html#a18">dist</a>(rec-&gt;<a class="code" href="structrect.html#o0">x1</a>,rec-&gt;<a class="code" href="structrect.html#o1">y1</a>,rec-&gt;<a class="code" href="structrect.html#o2">x2</a>,rec-&gt;<a class="code" href="structrect.html#o3">y2</a>) * rec-&gt;<a class="code" href="structrect.html#o4">width</a> );
02007 
02008   <span class="comment">/*------ Second try: reduce region radius ------*/</span>
02009   <span class="keywordflow">if</span>( density &lt; density_th )
02010     <span class="keywordflow">return</span> <a class="code" href="lsd_8c.html#a52">reduce_region_radius</a>( reg, reg_size, modgrad, reg_angle, prec, p,
02011                                  rec, used, angles, density_th );
02012 
02013   <span class="comment">/* if this point is reached, the density criterion is satisfied */</span>
02014   <span class="keywordflow">return</span> <a class="code" href="lsd_8c.html#a3">TRUE</a>;
02015 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8c_a53_cgraph.png" border="0" usemap="#lsd_8c_a53_cgraph_map" alt=""></center>
<map name="lsd_8c_a53_cgraph_map">
<area href="lsd_8c.html#a36" shape="rect" coords="125,8,250,34" alt="">
<area href="lsd_8c.html#a18" shape="rect" coords="338,160,381,186" alt="">
<area href="lsd_8c.html#a16" shape="rect" coords="607,210,658,237" alt="">
<area href="lsd_8c.html#a52" shape="rect" coords="113,210,262,237" alt="">
<area href="lsd_8c.html#a49" shape="rect" coords="315,261,403,288" alt="">
<area href="lsd_8c.html#a50" shape="rect" coords="313,109,406,136" alt="">
<area href="lsd_8c.html#a48" shape="rect" coords="455,312,533,338" alt="">
<area href="lsd_8c.html#a35" shape="rect" coords="593,337,673,364" alt="">
<area href="lsd_8c.html#a17" shape="rect" coords="582,286,683,313" alt="">
<area href="lsd_8c.html#a34" shape="rect" coords="457,160,531,186" alt="">
</map>
<a class="anchor" name="a49" doxytag="lsd.c::region2rect" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void region2rect </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct <a class="el" href="structpoint.html">point</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>reg</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>reg_size</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="structimage__double__s.html">image_double</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>modgrad</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>reg_angle</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>prec</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>p</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>struct <a class="el" href="structrect.html">rect</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>rec</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Computes a rectangle that covers a region of points. 
<p>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l01611">1611</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8c-source.html#l00471">image_double_s::data</a>, <a class="el" href="lsd_8c-source.html#l01175">rect::dx</a>, <a class="el" href="lsd_8c-source.html#l01175">rect::dy</a>, <a class="el" href="lsd_8c-source.html#l00159">error()</a>, <a class="el" href="lsd_8c-source.html#l01568">get_theta()</a>, <a class="el" href="lsd_8c.html#a15">image_double</a>, <a class="el" href="lsd_8c-source.html#l01177">rect::p</a>, <a class="el" href="lsd_8c-source.html#l01176">rect::prec</a>, <a class="el" href="lsd_8c-source.html#l01174">rect::theta</a>, <a class="el" href="lsd_8c-source.html#l01172">rect::width</a>, <a class="el" href="lsd_8c-source.html#l01173">rect::x</a>, <a class="el" href="lsd_8c-source.html#l00149">point::x</a>, <a class="el" href="lsd_8c-source.html#l01171">rect::x1</a>, <a class="el" href="lsd_8c-source.html#l01171">rect::x2</a>, <a class="el" href="lsd_8c-source.html#l00472">image_double_s::xsize</a>, <a class="el" href="lsd_8c-source.html#l01173">rect::y</a>, <a class="el" href="lsd_8c-source.html#l00149">point::y</a>, <a class="el" href="lsd_8c-source.html#l01171">rect::y1</a>, and <a class="el" href="lsd_8c-source.html#l01171">rect::y2</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l02025">LineSegmentDetection()</a>, <a class="el" href="lsd_8c-source.html#l01869">reduce_region_radius()</a>, and <a class="el" href="lsd_8c-source.html#l01947">refine()</a>.
<p>
<div class="fragment"><pre>01614 {
01615   <span class="keywordtype">double</span> x,y,dx,dy,l,w,theta,weight,sum,l_min,l_max,w_min,w_max;
01616   <span class="keywordtype">int</span> i;
01617 
01618   <span class="comment">/* check parameters */</span>
01619   <span class="keywordflow">if</span>( reg == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"region2rect: invalid region."</span>);
01620   <span class="keywordflow">if</span>( reg_size &lt;= 1 ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"region2rect: region size &lt;= 1."</span>);
01621   <span class="keywordflow">if</span>( modgrad == NULL || modgrad-&gt;<a class="code" href="structimage__double__s.html#o0">data</a> == NULL )
01622     <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"region2rect: invalid image 'modgrad'."</span>);
01623   <span class="keywordflow">if</span>( rec == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"region2rect: invalid 'rec'."</span>);
01624 
01625   <span class="comment">/* center of the region:</span>
01626 <span class="comment"></span>
01627 <span class="comment">     It is computed as the weighted sum of the coordinates</span>
01628 <span class="comment">     of all the pixels in the region. The norm of the gradient</span>
01629 <span class="comment">     is used as the weight of a pixel. The sum is as follows:</span>
01630 <span class="comment">       cx = \sum_i G(i).x_i</span>
01631 <span class="comment">       cy = \sum_i G(i).y_i</span>
01632 <span class="comment">     where G(i) is the norm of the gradient of pixel i</span>
01633 <span class="comment">     and x_i,y_i are its coordinates.</span>
01634 <span class="comment">   */</span>
01635   x = y = sum = 0.0;
01636   <span class="keywordflow">for</span>(i=0; i&lt;reg_size; i++)
01637     {
01638       weight = modgrad-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>[ reg[i].<a class="code" href="structpoint.html#o0">x</a> + reg[i].<a class="code" href="structpoint.html#o1">y</a> * modgrad-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a> ];
01639       x += (<span class="keywordtype">double</span>) reg[i].<a class="code" href="structpoint.html#o0">x</a> * weight;
01640       y += (<span class="keywordtype">double</span>) reg[i].<a class="code" href="structpoint.html#o1">y</a> * weight;
01641       sum += weight;
01642     }
01643   <span class="keywordflow">if</span>( sum &lt;= 0.0 ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"region2rect: weights sum equal to zero."</span>);
01644   x /= sum;
01645   y /= sum;
01646 
01647   <span class="comment">/* theta */</span>
01648   theta = <a class="code" href="lsd_8c.html#a48">get_theta</a>(reg,reg_size,x,y,modgrad,reg_angle,prec);
01649 
01650   <span class="comment">/* length and width:</span>
01651 <span class="comment"></span>
01652 <span class="comment">     'l' and 'w' are computed as the distance from the center of the</span>
01653 <span class="comment">     region to pixel i, projected along the rectangle axis (dx,dy) and</span>
01654 <span class="comment">     to the orthogonal axis (-dy,dx), respectively.</span>
01655 <span class="comment"></span>
01656 <span class="comment">     The length of the rectangle goes from l_min to l_max, where l_min</span>
01657 <span class="comment">     and l_max are the minimum and maximum values of l in the region.</span>
01658 <span class="comment">     Analogously, the width is selected from w_min to w_max, where</span>
01659 <span class="comment">     w_min and w_max are the minimum and maximum of w for the pixels</span>
01660 <span class="comment">     in the region.</span>
01661 <span class="comment">   */</span>
01662   dx = cos(theta);
01663   dy = sin(theta);
01664   l_min = l_max = w_min = w_max = 0.0;
01665   <span class="keywordflow">for</span>(i=0; i&lt;reg_size; i++)
01666     {
01667       l =  ( (<span class="keywordtype">double</span>) reg[i].<a class="code" href="structpoint.html#o0">x</a> - x) * dx + ( (<span class="keywordtype">double</span>) reg[i].<a class="code" href="structpoint.html#o1">y</a> - y) * dy;
01668       w = -( (<span class="keywordtype">double</span>) reg[i].<a class="code" href="structpoint.html#o0">x</a> - x) * dy + ( (<span class="keywordtype">double</span>) reg[i].<a class="code" href="structpoint.html#o1">y</a> - y) * dx;
01669 
01670       <span class="keywordflow">if</span>( l &gt; l_max ) l_max = l;
01671       <span class="keywordflow">if</span>( l &lt; l_min ) l_min = l;
01672       <span class="keywordflow">if</span>( w &gt; w_max ) w_max = w;
01673       <span class="keywordflow">if</span>( w &lt; w_min ) w_min = w;
01674     }
01675 
01676   <span class="comment">/* store values */</span>
01677   rec-&gt;<a class="code" href="structrect.html#o0">x1</a> = x + l_min * dx;
01678   rec-&gt;<a class="code" href="structrect.html#o1">y1</a> = y + l_min * dy;
01679   rec-&gt;<a class="code" href="structrect.html#o2">x2</a> = x + l_max * dx;
01680   rec-&gt;<a class="code" href="structrect.html#o3">y2</a> = y + l_max * dy;
01681   rec-&gt;<a class="code" href="structrect.html#o4">width</a> = w_max - w_min;
01682   rec-&gt;<a class="code" href="structrect.html#o5">x</a> = x;
01683   rec-&gt;<a class="code" href="structrect.html#o6">y</a> = y;
01684   rec-&gt;<a class="code" href="structrect.html#o7">theta</a> = theta;
01685   rec-&gt;<a class="code" href="structrect.html#o8">dx</a> = dx;
01686   rec-&gt;<a class="code" href="structrect.html#o9">dy</a> = dy;
01687   rec-&gt;<a class="code" href="structrect.html#o10">prec</a> = prec;
01688   rec-&gt;<a class="code" href="structrect.html#o11">p</a> = p;
01689 
01690   <span class="comment">/* we impose a minimal width of one pixel</span>
01691 <span class="comment"></span>
01692 <span class="comment">     A sharp horizontal or vertical step would produce a perfectly</span>
01693 <span class="comment">     horizontal or vertical region. The width computed would be</span>
01694 <span class="comment">     zero. But that corresponds to a one pixels width transition in</span>
01695 <span class="comment">     the image.</span>
01696 <span class="comment">   */</span>
01697   <span class="keywordflow">if</span>( rec-&gt;<a class="code" href="structrect.html#o4">width</a> &lt; 1.0 ) rec-&gt;<a class="code" href="structrect.html#o4">width</a> = 1.0;
01698 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8c_a49_cgraph.png" border="0" usemap="#lsd_8c_a49_cgraph_map" alt=""></center>
<map name="lsd_8c_a49_cgraph_map">
<area href="lsd_8c.html#a16" shape="rect" coords="298,8,349,34" alt="">
<area href="lsd_8c.html#a48" shape="rect" coords="146,58,224,85" alt="">
<area href="lsd_8c.html#a35" shape="rect" coords="284,58,364,85" alt="">
<area href="lsd_8c.html#a17" shape="rect" coords="273,109,374,136" alt="">
</map>
<a class="anchor" name="a50" doxytag="lsd.c::region_grow" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void region_grow </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>x</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>y</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="structimage__double__s.html">image_double</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>angles</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>struct <a class="el" href="structpoint.html">point</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>reg</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>reg_size</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap> <em>reg_angle</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="structimage__char__s.html">image_char</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>used</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>prec</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Build a region of pixels that share the same angle, up to a tolerance 'prec', starting at point (x,y). 
<p>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l01704">1704</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8c-source.html#l00345">image_char_s::data</a>, <a class="el" href="lsd_8c-source.html#l00471">image_double_s::data</a>, <a class="el" href="lsd_8c-source.html#l00159">error()</a>, <a class="el" href="lsd_8c.html#a13">image_char</a>, <a class="el" href="lsd_8c.html#a15">image_double</a>, <a class="el" href="lsd_8c-source.html#l00893">isaligned()</a>, <a class="el" href="lsd_8c-source.html#l00135">USED</a>, <a class="el" href="lsd_8c-source.html#l00149">point::x</a>, <a class="el" href="lsd_8c-source.html#l00346">image_char_s::xsize</a>, <a class="el" href="lsd_8c-source.html#l00472">image_double_s::xsize</a>, <a class="el" href="lsd_8c-source.html#l00149">point::y</a>, <a class="el" href="lsd_8c-source.html#l00346">image_char_s::ysize</a>, and <a class="el" href="lsd_8c-source.html#l00472">image_double_s::ysize</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l02025">LineSegmentDetection()</a>, and <a class="el" href="lsd_8c-source.html#l01947">refine()</a>.
<p>
<div class="fragment"><pre>01707 {
01708   <span class="keywordtype">double</span> sumdx,sumdy;
01709   <span class="keywordtype">int</span> xx,yy,i;
01710 
01711   <span class="comment">/* check parameters */</span>
01712   <span class="keywordflow">if</span>( x &lt; 0 || y &lt; 0 || x &gt;= (<span class="keywordtype">int</span>) angles-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a> || y &gt;= (<span class="keywordtype">int</span>) angles-&gt;<a class="code" href="structimage__double__s.html#o2">ysize</a> )
01713     <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"region_grow: (x,y) out of the image."</span>);
01714   <span class="keywordflow">if</span>( angles == NULL || angles-&gt;<a class="code" href="structimage__double__s.html#o0">data</a> == NULL )
01715     <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"region_grow: invalid image 'angles'."</span>);
01716   <span class="keywordflow">if</span>( reg == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"region_grow: invalid 'reg'."</span>);
01717   <span class="keywordflow">if</span>( reg_size == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"region_grow: invalid pointer 'reg_size'."</span>);
01718   <span class="keywordflow">if</span>( reg_angle == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"region_grow: invalid pointer 'reg_angle'."</span>);
01719   <span class="keywordflow">if</span>( used == NULL || used-&gt;<a class="code" href="structimage__char__s.html#o0">data</a> == NULL )
01720     <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"region_grow: invalid image 'used'."</span>);
01721 
01722   <span class="comment">/* first point of the region */</span>
01723   *reg_size = 1;
01724   reg[0].<a class="code" href="structpoint.html#o0">x</a> = x;
01725   reg[0].<a class="code" href="structpoint.html#o1">y</a> = y;
01726   *reg_angle = angles-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>[x+y*angles-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a>];  <span class="comment">/* region's angle */</span>
01727   sumdx = cos(*reg_angle);
01728   sumdy = sin(*reg_angle);
01729   used-&gt;<a class="code" href="structimage__char__s.html#o0">data</a>[x+y*used-&gt;<a class="code" href="structimage__char__s.html#o1">xsize</a>] = <a class="code" href="lsd_8c.html#a8">USED</a>;
01730 
01731   <span class="comment">/* try neighbors as new region points */</span>
01732   <span class="keywordflow">for</span>(i=0; i&lt;*reg_size; i++)
01733     <span class="keywordflow">for</span>(xx=reg[i].<a class="code" href="structpoint.html#o0">x</a>-1; xx&lt;=reg[i].x+1; xx++)
01734       <span class="keywordflow">for</span>(yy=reg[i].y-1; yy&lt;=reg[i].y+1; yy++)
01735         <span class="keywordflow">if</span>( xx&gt;=0 &amp;&amp; yy&gt;=0 &amp;&amp; xx&lt;(<span class="keywordtype">int</span>)used-&gt;<a class="code" href="structimage__char__s.html#o1">xsize</a> &amp;&amp; yy&lt;(<span class="keywordtype">int</span>)used-&gt;<a class="code" href="structimage__char__s.html#o2">ysize</a> &amp;&amp;
01736             used-&gt;<a class="code" href="structimage__char__s.html#o0">data</a>[xx+yy*used-&gt;<a class="code" href="structimage__char__s.html#o1">xsize</a>] != <a class="code" href="lsd_8c.html#a8">USED</a> &amp;&amp;
01737             <a class="code" href="lsd_8c.html#a34">isaligned</a>(xx,yy,angles,*reg_angle,prec) )
01738           {
01739             <span class="comment">/* add point */</span>
01740             used-&gt;<a class="code" href="structimage__char__s.html#o0">data</a>[xx+yy*used-&gt;<a class="code" href="structimage__char__s.html#o1">xsize</a>] = <a class="code" href="lsd_8c.html#a8">USED</a>;
01741             reg[*reg_size].x = xx;
01742             reg[*reg_size].y = yy;
01743             ++(*reg_size);
01744 
01745             <span class="comment">/* update region's angle */</span>
01746             sumdx += cos( angles-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>[xx+yy*angles-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a>] );
01747             sumdy += sin( angles-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>[xx+yy*angles-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a>] );
01748             *reg_angle = atan2(sumdy,sumdx);
01749           }
01750 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8c_a50_cgraph.png" border="0" usemap="#lsd_8c_a50_cgraph_map" alt=""></center>
<map name="lsd_8c_a50_cgraph_map">
<area href="lsd_8c.html#a16" shape="rect" coords="274,33,325,59" alt="">
<area href="lsd_8c.html#a34" shape="rect" coords="151,58,226,85" alt="">
</map>
<a class="anchor" name="a43" doxytag="lsd.c::ri_del" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void ri_del </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structrect__iter.html">rect_iter</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>iter</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Free memory used by a rectangle iterator. 
<p>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l01314">1314</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8c-source.html#l00159">error()</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l01482">rect_nfa()</a>.
<p>
<div class="fragment"><pre>01315 {
01316   <span class="keywordflow">if</span>( iter == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"ri_del: NULL iterator."</span>);
01317   free( (<span class="keywordtype">void</span> *) iter );
01318 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8c_a43_cgraph.png" border="0" usemap="#lsd_8c_a43_cgraph_map" alt=""></center>
<map name="lsd_8c_a43_cgraph_map">
<area href="lsd_8c.html#a16" shape="rect" coords="112,8,162,34" alt="">
</map>
<a class="anchor" name="a44" doxytag="lsd.c::ri_end" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int ri_end </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structrect__iter.html">rect_iter</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>i</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Check if the iterator finished the full iteration. 
<p>
See details in <a class="el" href="structrect__iter.html">rect_iter</a> 
<p>
Definition at line <a class="el" href="lsd_8c-source.html#l01325">1325</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8c-source.html#l00159">error()</a>, <a class="el" href="lsd_8c-source.html#l01261">rect_iter::vx</a>, and <a class="el" href="lsd_8c-source.html#l01264">rect_iter::x</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l01482">rect_nfa()</a>, and <a class="el" href="lsd_8c-source.html#l01341">ri_inc()</a>.
<p>
<div class="fragment"><pre>01326 {
01327   <span class="comment">/* check input */</span>
01328   <span class="keywordflow">if</span>( i == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"ri_end: NULL iterator."</span>);
01329 
01330   <span class="comment">/* if the current x value is larger than the largest</span>
01331 <span class="comment">     x value in the rectangle (vx[2]), we know the full</span>
01332 <span class="comment">     exploration of the rectangle is finished. */</span>
01333   <span class="keywordflow">return</span> (<span class="keywordtype">double</span>)(i-&gt;<a class="code" href="structrect__iter.html#o4">x</a>) &gt; i-&gt;<a class="code" href="structrect__iter.html#o0">vx</a>[2];
01334 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8c_a44_cgraph.png" border="0" usemap="#lsd_8c_a44_cgraph_map" alt=""></center>
<map name="lsd_8c_a44_cgraph_map">
<area href="lsd_8c.html#a16" shape="rect" coords="114,8,165,34" alt="">
</map>
<a class="anchor" name="a45" doxytag="lsd.c::ri_inc" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void ri_inc </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structrect__iter.html">rect_iter</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>i</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Increment a rectangle iterator. 
<p>
See details in <a class="el" href="structrect__iter.html">rect_iter</a> 
<p>
Definition at line <a class="el" href="lsd_8c-source.html#l01341">1341</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8c-source.html#l00159">error()</a>, <a class="el" href="lsd_8c-source.html#l01299">inter_hi()</a>, <a class="el" href="lsd_8c-source.html#l01277">inter_low()</a>, <a class="el" href="lsd_8c-source.html#l01325">ri_end()</a>, <a class="el" href="lsd_8c-source.html#l01261">rect_iter::vx</a>, <a class="el" href="lsd_8c-source.html#l01262">rect_iter::vy</a>, <a class="el" href="lsd_8c-source.html#l01264">rect_iter::x</a>, <a class="el" href="lsd_8c-source.html#l01264">rect_iter::y</a>, <a class="el" href="lsd_8c-source.html#l01263">rect_iter::ye</a>, and <a class="el" href="lsd_8c-source.html#l01263">rect_iter::ys</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l01482">rect_nfa()</a>, and <a class="el" href="lsd_8c-source.html#l01411">ri_ini()</a>.
<p>
<div class="fragment"><pre>01342 {
01343   <span class="comment">/* check input */</span>
01344   <span class="keywordflow">if</span>( i == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"ri_inc: NULL iterator."</span>);
01345 
01346   <span class="comment">/* if not at end of exploration,</span>
01347 <span class="comment">     increase y value for next pixel in the 'column' */</span>
01348   <span class="keywordflow">if</span>( !<a class="code" href="lsd_8c.html#a44">ri_end</a>(i) ) i-&gt;<a class="code" href="structrect__iter.html#o5">y</a>++;
01349 
01350   <span class="comment">/* if the end of the current 'column' is reached,</span>
01351 <span class="comment">     and it is not the end of exploration,</span>
01352 <span class="comment">     advance to the next 'column' */</span>
01353   <span class="keywordflow">while</span>( (<span class="keywordtype">double</span>) (i-&gt;<a class="code" href="structrect__iter.html#o5">y</a>) &gt; i-&gt;<a class="code" href="structrect__iter.html#o3">ye</a> &amp;&amp; !<a class="code" href="lsd_8c.html#a44">ri_end</a>(i) )
01354     {
01355       <span class="comment">/* increase x, next 'column' */</span>
01356       i-&gt;<a class="code" href="structrect__iter.html#o4">x</a>++;
01357 
01358       <span class="comment">/* if end of exploration, return */</span>
01359       <span class="keywordflow">if</span>( <a class="code" href="lsd_8c.html#a44">ri_end</a>(i) ) <span class="keywordflow">return</span>;
01360 
01361       <span class="comment">/* update lower y limit (start) for the new 'column'.</span>
01362 <span class="comment"></span>
01363 <span class="comment">         We need to interpolate the y value that corresponds to the</span>
01364 <span class="comment">         lower side of the rectangle. The first thing is to decide if</span>
01365 <span class="comment">         the corresponding side is</span>
01366 <span class="comment"></span>
01367 <span class="comment">           vx[0],vy[0] to vx[3],vy[3] or</span>
01368 <span class="comment">           vx[3],vy[3] to vx[2],vy[2]</span>
01369 <span class="comment"></span>
01370 <span class="comment">         Then, the side is interpolated for the x value of the</span>
01371 <span class="comment">         'column'. But, if the side is vertical (as it could happen if</span>
01372 <span class="comment">         the rectangle is vertical and we are dealing with the first</span>
01373 <span class="comment">         or last 'columns') then we pick the lower value of the side</span>
01374 <span class="comment">         by using 'inter_low'.</span>
01375 <span class="comment">       */</span>
01376       <span class="keywordflow">if</span>( (<span class="keywordtype">double</span>) i-&gt;<a class="code" href="structrect__iter.html#o4">x</a> &lt; i-&gt;<a class="code" href="structrect__iter.html#o0">vx</a>[3] )
01377         i-&gt;<a class="code" href="structrect__iter.html#o2">ys</a> = <a class="code" href="lsd_8c.html#a41">inter_low</a>((<span class="keywordtype">double</span>)i-&gt;<a class="code" href="structrect__iter.html#o4">x</a>,i-&gt;<a class="code" href="structrect__iter.html#o0">vx</a>[0],i-&gt;<a class="code" href="structrect__iter.html#o1">vy</a>[0],i-&gt;<a class="code" href="structrect__iter.html#o0">vx</a>[3],i-&gt;<a class="code" href="structrect__iter.html#o1">vy</a>[3]);
01378       <span class="keywordflow">else</span>
01379         i-&gt;<a class="code" href="structrect__iter.html#o2">ys</a> = <a class="code" href="lsd_8c.html#a41">inter_low</a>((<span class="keywordtype">double</span>)i-&gt;<a class="code" href="structrect__iter.html#o4">x</a>,i-&gt;<a class="code" href="structrect__iter.html#o0">vx</a>[3],i-&gt;<a class="code" href="structrect__iter.html#o1">vy</a>[3],i-&gt;<a class="code" href="structrect__iter.html#o0">vx</a>[2],i-&gt;<a class="code" href="structrect__iter.html#o1">vy</a>[2]);
01380 
01381       <span class="comment">/* update upper y limit (end) for the new 'column'.</span>
01382 <span class="comment"></span>
01383 <span class="comment">         We need to interpolate the y value that corresponds to the</span>
01384 <span class="comment">         upper side of the rectangle. The first thing is to decide if</span>
01385 <span class="comment">         the corresponding side is</span>
01386 <span class="comment"></span>
01387 <span class="comment">           vx[0],vy[0] to vx[1],vy[1] or</span>
01388 <span class="comment">           vx[1],vy[1] to vx[2],vy[2]</span>
01389 <span class="comment"></span>
01390 <span class="comment">         Then, the side is interpolated for the x value of the</span>
01391 <span class="comment">         'column'. But, if the side is vertical (as it could happen if</span>
01392 <span class="comment">         the rectangle is vertical and we are dealing with the first</span>
01393 <span class="comment">         or last 'columns') then we pick the lower value of the side</span>
01394 <span class="comment">         by using 'inter_low'.</span>
01395 <span class="comment">       */</span>
01396       <span class="keywordflow">if</span>( (<span class="keywordtype">double</span>)i-&gt;<a class="code" href="structrect__iter.html#o4">x</a> &lt; i-&gt;<a class="code" href="structrect__iter.html#o0">vx</a>[1] )
01397         i-&gt;<a class="code" href="structrect__iter.html#o3">ye</a> = <a class="code" href="lsd_8c.html#a42">inter_hi</a>((<span class="keywordtype">double</span>)i-&gt;<a class="code" href="structrect__iter.html#o4">x</a>,i-&gt;<a class="code" href="structrect__iter.html#o0">vx</a>[0],i-&gt;<a class="code" href="structrect__iter.html#o1">vy</a>[0],i-&gt;<a class="code" href="structrect__iter.html#o0">vx</a>[1],i-&gt;<a class="code" href="structrect__iter.html#o1">vy</a>[1]);
01398       <span class="keywordflow">else</span>
01399         i-&gt;<a class="code" href="structrect__iter.html#o3">ye</a> = <a class="code" href="lsd_8c.html#a42">inter_hi</a>((<span class="keywordtype">double</span>)i-&gt;<a class="code" href="structrect__iter.html#o4">x</a>,i-&gt;<a class="code" href="structrect__iter.html#o0">vx</a>[1],i-&gt;<a class="code" href="structrect__iter.html#o1">vy</a>[1],i-&gt;<a class="code" href="structrect__iter.html#o0">vx</a>[2],i-&gt;<a class="code" href="structrect__iter.html#o1">vy</a>[2]);
01400 
01401       <span class="comment">/* new y */</span>
01402       i-&gt;<a class="code" href="structrect__iter.html#o5">y</a> = (<span class="keywordtype">int</span>) ceil(i-&gt;<a class="code" href="structrect__iter.html#o2">ys</a>);
01403     }
01404 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8c_a45_cgraph.png" border="0" usemap="#lsd_8c_a45_cgraph_map" alt=""></center>
<map name="lsd_8c_a45_cgraph_map">
<area href="lsd_8c.html#a16" shape="rect" coords="263,72,314,98" alt="">
<area href="lsd_8c.html#a42" shape="rect" coords="117,109,183,136" alt="">
<area href="lsd_8c.html#a41" shape="rect" coords="113,160,187,186" alt="">
<area href="lsd_8c.html#a44" shape="rect" coords="121,58,179,85" alt="">
<area href="lsd_8c.html#a17" shape="rect" coords="238,148,339,174" alt="">
</map>
<a class="anchor" name="a46" doxytag="lsd.c::ri_ini" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="structrect__iter.html">rect_iter</a>* ri_ini </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct <a class="el" href="structrect.html">rect</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>r</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create and initialize a rectangle iterator. 
<p>
See details in <a class="el" href="structrect__iter.html">rect_iter</a> 
<p>
Definition at line <a class="el" href="lsd_8c-source.html#l01411">1411</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8c-source.html#l01175">rect::dx</a>, <a class="el" href="lsd_8c-source.html#l01175">rect::dy</a>, <a class="el" href="lsd_8c-source.html#l00159">error()</a>, <a class="el" href="lsd_8c-source.html#l01341">ri_inc()</a>, <a class="el" href="lsd_8c-source.html#l01261">rect_iter::vx</a>, <a class="el" href="lsd_8c-source.html#l01262">rect_iter::vy</a>, <a class="el" href="lsd_8c-source.html#l01172">rect::width</a>, <a class="el" href="lsd_8c-source.html#l01264">rect_iter::x</a>, <a class="el" href="lsd_8c-source.html#l01171">rect::x1</a>, <a class="el" href="lsd_8c-source.html#l01171">rect::x2</a>, <a class="el" href="lsd_8c-source.html#l01264">rect_iter::y</a>, <a class="el" href="lsd_8c-source.html#l01171">rect::y1</a>, <a class="el" href="lsd_8c-source.html#l01171">rect::y2</a>, <a class="el" href="lsd_8c-source.html#l01263">rect_iter::ye</a>, and <a class="el" href="lsd_8c-source.html#l01263">rect_iter::ys</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l01482">rect_nfa()</a>.
<p>
<div class="fragment"><pre>01412 {
01413   <span class="keywordtype">double</span> vx[4],vy[4];
01414   <span class="keywordtype">int</span> n,offset;
01415   <a class="code" href="structrect__iter.html">rect_iter</a> * i;
01416 
01417   <span class="comment">/* check parameters */</span>
01418   <span class="keywordflow">if</span>( r == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"ri_ini: invalid rectangle."</span>);
01419 
01420   <span class="comment">/* get memory */</span>
01421   i = (<a class="code" href="structrect__iter.html">rect_iter</a> *) malloc(<span class="keyword">sizeof</span>(<a class="code" href="structrect__iter.html">rect_iter</a>));
01422   <span class="keywordflow">if</span>( i == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"ri_ini: Not enough memory."</span>);
01423 
01424   <span class="comment">/* build list of rectangle corners ordered</span>
01425 <span class="comment">     in a circular way around the rectangle */</span>
01426   vx[0] = r-&gt;<a class="code" href="structrect.html#o0">x1</a> - r-&gt;<a class="code" href="structrect.html#o9">dy</a> * r-&gt;<a class="code" href="structrect.html#o4">width</a> / 2.0;
01427   vy[0] = r-&gt;<a class="code" href="structrect.html#o1">y1</a> + r-&gt;<a class="code" href="structrect.html#o8">dx</a> * r-&gt;<a class="code" href="structrect.html#o4">width</a> / 2.0;
01428   vx[1] = r-&gt;<a class="code" href="structrect.html#o2">x2</a> - r-&gt;<a class="code" href="structrect.html#o9">dy</a> * r-&gt;<a class="code" href="structrect.html#o4">width</a> / 2.0;
01429   vy[1] = r-&gt;<a class="code" href="structrect.html#o3">y2</a> + r-&gt;<a class="code" href="structrect.html#o8">dx</a> * r-&gt;<a class="code" href="structrect.html#o4">width</a> / 2.0;
01430   vx[2] = r-&gt;<a class="code" href="structrect.html#o2">x2</a> + r-&gt;<a class="code" href="structrect.html#o9">dy</a> * r-&gt;<a class="code" href="structrect.html#o4">width</a> / 2.0;
01431   vy[2] = r-&gt;<a class="code" href="structrect.html#o3">y2</a> - r-&gt;<a class="code" href="structrect.html#o8">dx</a> * r-&gt;<a class="code" href="structrect.html#o4">width</a> / 2.0;
01432   vx[3] = r-&gt;<a class="code" href="structrect.html#o0">x1</a> + r-&gt;<a class="code" href="structrect.html#o9">dy</a> * r-&gt;<a class="code" href="structrect.html#o4">width</a> / 2.0;
01433   vy[3] = r-&gt;<a class="code" href="structrect.html#o1">y1</a> - r-&gt;<a class="code" href="structrect.html#o8">dx</a> * r-&gt;<a class="code" href="structrect.html#o4">width</a> / 2.0;
01434 
01435   <span class="comment">/* compute rotation of index of corners needed so that the first</span>
01436 <span class="comment">     point has the smaller x.</span>
01437 <span class="comment"></span>
01438 <span class="comment">     if one side is vertical, thus two corners have the same smaller x</span>
01439 <span class="comment">     value, the one with the largest y value is selected as the first.</span>
01440 <span class="comment">   */</span>
01441   <span class="keywordflow">if</span>( r-&gt;<a class="code" href="structrect.html#o0">x1</a> &lt; r-&gt;<a class="code" href="structrect.html#o2">x2</a> &amp;&amp; r-&gt;<a class="code" href="structrect.html#o1">y1</a> &lt;= r-&gt;<a class="code" href="structrect.html#o3">y2</a> ) offset = 0;
01442   <span class="keywordflow">else</span> <span class="keywordflow">if</span>( r-&gt;<a class="code" href="structrect.html#o0">x1</a> &gt;= r-&gt;<a class="code" href="structrect.html#o2">x2</a> &amp;&amp; r-&gt;<a class="code" href="structrect.html#o1">y1</a> &lt; r-&gt;<a class="code" href="structrect.html#o3">y2</a> ) offset = 1;
01443   <span class="keywordflow">else</span> <span class="keywordflow">if</span>( r-&gt;<a class="code" href="structrect.html#o0">x1</a> &gt; r-&gt;<a class="code" href="structrect.html#o2">x2</a> &amp;&amp; r-&gt;<a class="code" href="structrect.html#o1">y1</a> &gt;= r-&gt;<a class="code" href="structrect.html#o3">y2</a> ) offset = 2;
01444   <span class="keywordflow">else</span> offset = 3;
01445 
01446   <span class="comment">/* apply rotation of index. */</span>
01447   <span class="keywordflow">for</span>(n=0; n&lt;4; n++)
01448     {
01449       i-&gt;<a class="code" href="structrect__iter.html#o0">vx</a>[n] = vx[(offset+n)%4];
01450       i-&gt;<a class="code" href="structrect__iter.html#o1">vy</a>[n] = vy[(offset+n)%4];
01451     }
01452 
01453   <span class="comment">/* Set an initial condition.</span>
01454 <span class="comment"></span>
01455 <span class="comment">     The values are set to values that will cause 'ri_inc' (that will</span>
01456 <span class="comment">     be called immediately) to initialize correctly the first 'column'</span>
01457 <span class="comment">     and compute the limits 'ys' and 'ye'.</span>
01458 <span class="comment"></span>
01459 <span class="comment">     'y' is set to the integer value of vy[0], the starting corner.</span>
01460 <span class="comment"></span>
01461 <span class="comment">     'ys' and 'ye' are set to very small values, so 'ri_inc' will</span>
01462 <span class="comment">     notice that it needs to start a new 'column'.</span>
01463 <span class="comment"></span>
01464 <span class="comment">     The smallest integer coordinate inside of the rectangle is</span>
01465 <span class="comment">     'ceil(vx[0])'. The current 'x' value is set to that value minus</span>
01466 <span class="comment">     one, so 'ri_inc' (that will increase x by one) will advance to</span>
01467 <span class="comment">     the first 'column'.</span>
01468 <span class="comment">   */</span>
01469   i-&gt;<a class="code" href="structrect__iter.html#o4">x</a> = (<span class="keywordtype">int</span>) ceil(i-&gt;<a class="code" href="structrect__iter.html#o0">vx</a>[0]) - 1;
01470   i-&gt;<a class="code" href="structrect__iter.html#o5">y</a> = (<span class="keywordtype">int</span>) ceil(i-&gt;<a class="code" href="structrect__iter.html#o1">vy</a>[0]);
01471   i-&gt;<a class="code" href="structrect__iter.html#o2">ys</a> = i-&gt;<a class="code" href="structrect__iter.html#o3">ye</a> = -DBL_MAX;
01472 
01473   <span class="comment">/* advance to the first pixel */</span>
01474   <a class="code" href="lsd_8c.html#a45">ri_inc</a>(i);
01475 
01476   <span class="keywordflow">return</span> i;
01477 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8c_a46_cgraph.png" border="0" usemap="#lsd_8c_a46_cgraph_map" alt=""></center>
<map name="lsd_8c_a46_cgraph_map">
<area href="lsd_8c.html#a16" shape="rect" coords="362,109,413,135" alt="">
<area href="lsd_8c.html#a45" shape="rect" coords="108,109,161,135" alt="">
<area href="lsd_8c.html#a42" shape="rect" coords="216,159,282,186" alt="">
<area href="lsd_8c.html#a41" shape="rect" coords="212,210,286,237" alt="">
<area href="lsd_8c.html#a44" shape="rect" coords="220,109,278,135" alt="">
<area href="lsd_8c.html#a17" shape="rect" coords="337,185,438,211" alt="">
</map>
<hr size="1"><address style="align: right;"><small>Generated on Fri Nov 11 11:11:11 2011 for LSD by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.4 </small></address>
</body>
</html>
